[
    {
        "id": 1,
        "topic": "BigQuery",
        "question": "You need to store 5 years of historical logs (500 TB) in BigQuery for occasional auditing. The logs are rarely queried (once a quarter). Which storage class should you use to minimize costs?",
        "options": [
            "Active Storage",
            "Long-term Storage",
            "Nearline Storage",
            "Coldline Storage"
        ],
        "answer": "Long-term Storage",
        "explanation": "BigQuery automatically moves data to Long-term Storage if it hasn't been modified for 90 days. storage price drops by ~50%. Note: 'Nearline' and 'Coldline' are GCS storage classes, not BigQuery native storage classes (though you can query external tables).",
        "companies": [
            "Google"
        ],
        "frequency_score": 10
    },
    {
        "id": 2,
        "topic": "Dataflow",
        "question": "You are designing a streaming pipeline in Dataflow using the Apache Beam SDK. You need to handle late data that arrives up to 2 hours after the event time. Which windowing concept should you configure?",
        "options": [
            "Triggers",
            "Watermarks",
            "Allowed Lateness",
            "Session Windows"
        ],
        "answer": "Allowed Lateness",
        "explanation": "'Allowed Lateness' defines how long the system waits for late data before dropping it. Watermarks track the system's notion of completeness, but Allowed Lateness explicitly handles the data arriving after the watermark.",
        "companies": [
            "Google"
        ],
        "frequency_score": 9
    },
    {
        "id": 3,
        "topic": "Cloud Spanner",
        "question": "Your global application requires strong consistency and horizontal scalability for a relational database. It serves users in US, Europe, and Asia. Which Google Cloud service is the best fit?",
        "options": [
            "Cloud SQL",
            "Cloud Spanner",
            "Bigtable",
            "Firestore"
        ],
        "answer": "Cloud Spanner",
        "explanation": "Cloud Spanner is the only fully managed relational database service that offers strong consistency and horizontal scalability across global regions.",
        "companies": [
            "Google"
        ],
        "frequency_score": 8
    },
    {
        "id": 4,
        "topic": "BigQuery",
        "question": "You have a BigQuery table with 10 PB of data partitioned by date. Users frequently query by 'customer_id' within a specific date range. Performance is still slow. What optimization should you apply first?",
        "options": [
            "Create a new partition by customer_id",
            "Cluster the table by customer_id",
            "Add a secondary index on customer_id",
            "Denormalize the data"
        ],
        "answer": "Cluster the table by customer_id",
        "explanation": "Clustering sorts the data within each partition. If users query by partition key (date) AND a filter column (customer_id), clustering by customer_id will drastically reduce the amount of data scanned.",
        "companies": [
            "Google"
        ],
        "frequency_score": 10
    },
    {
        "id": 5,
        "topic": "Pub/Sub",
        "question": "You need to ingest millions of IoT sensor events per second. The events must be processed in the EXACT order they were generated per sensor. How should you configure Pub/Sub?",
        "options": [
            "Enable message ordering and use a unique ordering key (sensor_id) for messages",
            "Use a FIFO subscription",
            "Pub/Sub guarantees global ordering by default",
            "Use Cloud Tasks instead"
        ],
        "answer": "Enable message ordering and use a unique ordering key (sensor_id) for messages",
        "explanation": "Pub/Sub does not guarantee global ordering. To ensure ordering, you must enable message ordering on the subscription and publish messages with an ordering key (like sensor_id).",
        "companies": [
            "Google"
        ],
        "frequency_score": 7
    },
    {
        "id": 6,
        "topic": "Data Modeling",
        "question": "You are designing a data warehouse schema for a retail company. You have a large 'Sales' fact table and small 'Product' and 'Store' dimension tables. Which schema type fits best for analytical queries in BigQuery?",
        "options": [
            "3rd Normal Form (3NF)",
            "Star Schema (denormalized where appropriate)",
            "Graph Schema",
            "Key-Value Store"
        ],
        "answer": "Star Schema (denormalized where appropriate)",
        "explanation": "BigQuery performs best with denormalized data or Star Schema designs. Avoiding excessive joins (like in 3NF or Snowflake) improves performance. Nested and repeated fields are often preferred over pure Star Schema.",
        "companies": [
            "Google"
        ],
        "frequency_score": 5
    },
    {
        "id": 7,
        "topic": "Google Cloud Storage",
        "question": "You need to store data that must be accessed instantly but only once a month. Availability must be 99%. Which storage class is most cost-effective?",
        "options": [
            "Standard",
            "Nearline",
            "Coldline",
            "Archive"
        ],
        "answer": "Nearline",
        "explanation": "Nearline is for data accessed less than once a month. Coldline is for less than once a quarter. Archive is for less than once a year. Standard is for hot data.",
        "companies": [
            "Google"
        ],
        "frequency_score": 5
    },
    {
        "id": 8,
        "topic": "Bigtable",
        "question": "You are designing a row key for a Bigtable table storing time-series data from sensors. The queries will be 'Get all readings for Sensor X in time range T1-T2'. Which row key logic avoids hotspots?",
        "options": [
            "Timestamp#SensorID",
            "SensorID#Timestamp",
            "ReverseTimestamp#SensorID",
            "SensorID#ReverseTimestamp"
        ],
        "answer": "SensorID#Timestamp",
        "explanation": "If you put Timestamp first, all writes for 'now' go to the same node (hotspotting). Putting SensorID first distributes writes across nodes (assuming many sensors). 'SensorID#Timestamp' allows efficient range scans for a specific sensor.",
        "companies": [
            "Google"
        ],
        "frequency_score": 7
    },
    {
        "id": 9,
        "topic": "Cloud Composer",
        "question": "You have a complex ETL workflow with dependencies between BigQuery jobs, Dataflow jobs, and GCS transfers. Which tool is best for orchestration?",
        "options": [
            "Cloud Scheduler",
            "Cloud Composer (Apache Airflow)",
            "Cloud Functions",
            "Cron jobs on Compute Engine"
        ],
        "answer": "Cloud Composer (Apache Airflow)",
        "explanation": "Cloud Composer is a managed Apache Airflow service designed specifically for orchestrating complex workflows with dependencies (DAGs).",
        "companies": [
            "Google"
        ],
        "frequency_score": 5
    },
    {
        "id": 10,
        "topic": "IAM & Security",
        "question": "You want to give a data analyst access to query a specific BigQuery dataset, but NOT permission to delete tables or create new datasets. Which role should you grant?",
        "options": [
            "BigQuery Admin",
            "BigQuery Data Owner",
            "BigQuery Data Viewer + BigQuery Job User",
            "BigQuery Data Editor"
        ],
        "answer": "BigQuery Data Viewer + BigQuery Job User",
        "explanation": "Data Viewer allows reading data. Job User allows running queries (computation). Admin/Owner/Editor grant modify/delete permissions.",
        "companies": [
            "Google"
        ],
        "frequency_score": 5
    },
    {
        "id": 11,
        "topic": "Dataflow",
        "question": "In a Dataflow pipeline, a specific key creates a 'hot key' issue because it has 100x more data than others, slowing down the job. How can you mitigate this?",
        "options": [
            "Increase the number of workers",
            "Enable Streaming Engine",
            "Use 'Combine.PerKey' with a hot-key fanout",
            "Use a larger machine type"
        ],
        "answer": "Use 'Combine.PerKey' with a hot-key fanout",
        "explanation": "Adding workers doesn't solve hot keys (one worker gets stuck). Hot Key Fanout breaks the large key into sub-keys, aggregates them in parallel, and then aggregates the results.",
        "companies": [
            "Google"
        ],
        "frequency_score": 9
    },
    {
        "id": 12,
        "topic": "BigQuery",
        "question": "A user complains that a query 'SELECT * FROM huge_table LIMIT 10' is costing too much money. Why?",
        "options": [
            "LIMIT does not reduce the amount of data scanned in BigQuery",
            "The table is not partitioned",
            "The query uses legacy SQL",
            "BigQuery charges per row returned"
        ],
        "answer": "LIMIT does not reduce the amount of data scanned in BigQuery",
        "explanation": "BigQuery is a columnar store. 'SELECT *' scans ALL columns. LIMIT is applied *after* scanning the data. To save cost, select specific columns and use WHERE clauses (esp on partitions).",
        "companies": [
            "Google"
        ],
        "frequency_score": 10
    },
    {
        "id": 13,
        "topic": "SQL",
        "question": "You have a table `employees` with `department_id` and `salary`. You want to find the highest salary in EACH department. Which query is most efficient?",
        "options": [
            "SELECT department_id, MAX(salary) FROM employees GROUP BY department_id",
            "SELECT * FROM employees ORDER BY salary DESC LIMIT 1",
            "SELECT department_id, salary FROM employees WHERE salary = MAX(salary)",
            "Select DISTINCT department_id FROM employees"
        ],
        "answer": "SELECT department_id, MAX(salary) FROM employees GROUP BY department_id",
        "explanation": "Standard aggregation with GROUP BY is the correct and efficient way to find per-group maximums.",
        "companies": [
            "Google"
        ],
        "frequency_score": 5
    },
    {
        "id": 14,
        "topic": "Data Transfer",
        "question": "You need to migrate 50 PB of data from an on-premise data center to Google Cloud Storage. Bandwidth is limited. What is the fastest method?",
        "options": [
            "gsutil cp -m",
            "Storage Transfer Service",
            "Transfer Appliance",
            "Google Drive"
        ],
        "answer": "Transfer Appliance",
        "explanation": "For 50 PB with limited bandwidth, shipping physical Transfer Appliances is significantly faster than network transfer.",
        "companies": [
            "Google"
        ],
        "frequency_score": 5
    },
    {
        "id": 15,
        "topic": "Dataproc",
        "question": "You possess existing Spark and Hadoop jobs running on an on-premise cluster. You want to migrate them to GCP with minimal code changes. Which service should you use?",
        "options": [
            "Dataflow",
            "BigQuery",
            "Dataproc",
            "Compute Engine"
        ],
        "answer": "Dataproc",
        "explanation": "Dataproc is Managed Hadoop/Spark. It allows 'lift and shift' of existing Hadoop/Spark jobs with minimal changes.",
        "companies": [
            "Google"
        ],
        "frequency_score": 5
    },
    {
        "id": 16,
        "topic": "BigQuery",
        "question": "You are loading CSV data into BigQuery. Some rows have a 'date' column with invalid formats, causing the load job to fail. You want to skip these bad rows and load the rest. What do you do?",
        "options": [
            "Set `max_bad_records` to a higher number in the load job configuration",
            "Use Dataflow to clean the data first",
            "Edit the CSV manually",
            "Use Federated Query"
        ],
        "answer": "Set `max_bad_records` to a higher number in the load job configuration",
        "explanation": "BigQuery load jobs allow specifying `max_bad_records` to tolerate a certain number of invalid rows without failing the entire job.",
        "companies": [
            "Google"
        ],
        "frequency_score": 10
    },
    {
        "id": 17,
        "topic": "Dataflow",
        "question": "What is the difference between a Side Input and a Main Input in Apache Beam?",
        "options": [
            "Main inputs are for streaming, Side inputs for batch",
            "Main input is the primary data to process; Side input is auxiliary data (smaller) accessible by all workers",
            "Side inputs are only for joining tables",
            "There is no difference"
        ],
        "answer": "Main input is the primary data to process; Side input is auxiliary data (smaller) accessible by all workers",
        "explanation": "Side inputs inject additional data (like a lookup table or a configuration variable) into a ParDo operation alongside the main data stream.",
        "companies": [
            "Google"
        ],
        "frequency_score": 9
    },
    {
        "id": 18,
        "topic": "Cloud SQL",
        "question": "You need to perform analytics on your transactional Cloud SQL (PostgreSQL) database without impacting performance for the production application. What should you do?",
        "options": [
            "Increase machine type size",
            "Create a Read Replica and point analytics queries to it",
            "Use Bigtable",
            "Enable High Availability"
        ],
        "answer": "Create a Read Replica and point analytics queries to it",
        "explanation": "Read Replicas allow offloading read-heavy workloads (like analytics) from the primary instance, preserving the primary's resources for writes and transactional reads.",
        "companies": [
            "Google"
        ],
        "frequency_score": 5
    },
    {
        "id": 19,
        "topic": "General",
        "question": "What does CAP theorem state about distributed databases?",
        "options": [
            "You can have Consistency, Availability, and Partition Tolerance all at the same time",
            "You can only pick 2 out of 3: Consistency, Availability, Partition Tolerance",
            "Consistency is always more important than Availability",
            "Cloud Spanner breaks the CAP theorem"
        ],
        "answer": "You can only pick 2 out of 3: Consistency, Availability, Partition Tolerance",
        "explanation": "The CAP theorem states that a distributed datastore can provide at most two of the three guarantees. (Note: Spanner claims to be effectively CA, but technically is CP with very high availability).",
        "companies": [
            "Google"
        ],
        "frequency_score": 5
    },
    {
        "id": 20,
        "topic": "BigQuery",
        "question": "How does BigQuery optimize storage costs for data that is physically deleted but might need to be recovered within 7 days?",
        "options": [
            "Time Travel (7 days built-in)",
            "Snapshot Tables",
            "Backup and Restore",
            "It doesn't, deleted data is gone immediately"
        ],
        "answer": "Time Travel (7 days built-in)",
        "explanation": "BigQuery Time Travel allows you to query data as it was at any point in the past 7 days, enabling recovery from accidental deletions without prior backups.",
        "companies": [
            "Google"
        ],
        "frequency_score": 10
    },
    {
        "id": 21,
        "topic": "BigQuery",
        "question": "You need to deduplicate a table in BigQuery based on `transaction_id`, keeping only the most recent record based on `timestamp`. Which function is most useful?",
        "options": [
            "GROUP BY",
            "DISTINCT",
            "QUALIFY ROW_NUMBER() OVER (PARTITION BY ... ORDER BY ...)",
            "JOIN"
        ],
        "answer": "QUALIFY ROW_NUMBER() OVER (PARTITION BY ... ORDER BY ...)",
        "explanation": "`QUALIFY ROW_NUMBER() OVER (PARTITION BY transaction_id ORDER BY timestamp DESC) = 1` is the standard and most readable pattern for deduplication in BigQuery.",
        "companies": [
            "Google"
        ],
        "frequency_score": 10
    },
    {
        "id": 22,
        "topic": "Dataflow",
        "question": "You are running a streaming Dataflow pipeline. You deploy a new version of the pipeline code with `update` option. What happens to the in-flight state?",
        "options": [
            "All state is lost",
            "The pipeline drains and restarts with empty state",
            "Dataflow attempts to migrate the state to the new steps if compatible",
            "You cannot update a streaming pipeline"
        ],
        "answer": "Dataflow attempts to migrate the state to the new steps if compatible",
        "explanation": "Dataflow allows updating running streaming jobs. It preserves the checkpointed state (windowing, watermarks, etc.) if the new graph is compatible with the old one.",
        "companies": [
            "Google"
        ],
        "frequency_score": 9
    },
    {
        "id": 23,
        "topic": "IAM",
        "question": "What is the principle of 'Least Privilege'?",
        "options": [
            "Giving users all permissions so they are not blocked",
            "Granting only the minimum permissions necessary for a user to perform their job",
            "Using primitive roles like Editor/Owner everywhere",
            "Disabling all access by default"
        ],
        "answer": "Granting only the minimum permissions necessary for a user to perform their job",
        "explanation": "Least Privilege is a security best practice. In GCP, this means using Predefined or Custom roles instead of Basic roles (Owner/Editor) whenever possible.",
        "companies": [
            "Google"
        ],
        "frequency_score": 9
    },
    {
        "id": 24,
        "topic": "Cloud Storage",
        "question": "You want to ensure that objects in a GCS bucket cannot be deleted or overwritten for 1 year for compliance reasons. What feature do you use?",
        "options": [
            "Object Versioning",
            "Bucket Lock / Retention Policy",
            "IAM Roles",
            "Coldline Storage"
        ],
        "answer": "Bucket Lock / Retention Policy",
        "explanation": "A Retention Policy (Bucket Lock) enforces a minimum retention period where objects cannot be deleted or overwritten. Once locked, the policy cannot be reduced.",
        "companies": [
            "Google"
        ],
        "frequency_score": 6
    },
    {
        "id": 25,
        "topic": "Machine Learning",
        "question": "You have a large dataset in BigQuery and want to build a regression model to predict sales. You have no Python experience. What tool can you use?",
        "options": [
            "Vertex AI Workbench",
            "BigQuery ML",
            "TensorFlow",
            "Dataflow"
        ],
        "answer": "BigQuery ML",
        "explanation": "BigQuery ML allows you to create and execute machine learning models in BigQuery using standard SQL queries.",
        "companies": [
            "Google"
        ],
        "frequency_score": 5
    },
    {
        "id": 26,
        "topic": "Cloud Spanner",
        "question": "What is 'Interleaved Tables' in Cloud Spanner?",
        "options": [
            "Tables that are joined virtually",
            "A parent-child table hierarchy where child rows are physically stored with their parent rows",
            "Tables duplicated across regions",
            "Temporary tables"
        ],
        "answer": "A parent-child table hierarchy where child rows are physically stored with their parent rows",
        "explanation": "Interleaving physically co-locates child rows (e.g., OrderItems) with their parent row (e.g., Order). This optimizes joins and access patterns for hierarchical data.",
        "companies": [
            "Google"
        ],
        "frequency_score": 8
    },
    {
        "id": 27,
        "topic": "Pub/Sub",
        "question": "What happens if a subscriber fails to acknowledge a message in Pub/Sub before the 'ackDeadline' expires?",
        "options": [
            "The message is deleted",
            "The message is placed in a Dead Letter Queue immediately",
            "Pub/Sub redelivers the message",
            "The subscription is paused"
        ],
        "answer": "Pub/Sub redelivers the message",
        "explanation": "If an ack is not received within the deadline, Pub/Sub considers the message delivery failed and will attempt to redeliver it (potentially to a different subscriber).",
        "companies": [
            "Google"
        ],
        "frequency_score": 7
    },
    {
        "id": 28,
        "topic": "Operations",
        "question": "You want to monitor the freshness of data in a BigQuery table and alert if no new data has arrived in 24 hours. Which approach is best?",
        "options": [
            "Write a Cloud Function to run a 'SELECT MAX(timestamp)' query and send metrics to Cloud Monitoring",
            "Check the BigQuery UI manually",
            "Use Cloud Logging",
            "It's not possible"
        ],
        "answer": "Write a Cloud Function to run a 'SELECT MAX(timestamp)' query and send metrics to Cloud Monitoring",
        "explanation": "You need a custom metric for 'data freshness'. A scheduled simple query (via Cloud Scheduler + Function or Airflow) can verify the latest timestamp and push a metric to Cloud Monitoring for alerting.",
        "companies": [
            "Google"
        ],
        "frequency_score": 5
    },
    {
        "id": 29,
        "topic": "Dataflow",
        "question": "When does a 'GroupByKey' operation output a result in a streaming pipeline?",
        "options": [
            "Immediately as data arrives",
            "When the Window closes (Watermark passes end of window)",
            "Once every minute",
            "When the buffer is full"
        ],
        "answer": "When the Window closes (Watermark passes end of window)",
        "explanation": "In streaming, GroupByKey aggregates data for a window. It can only emit a 'complete' result when the system believes it has seen all data for that window (Watermark passes window end), unless speculative triggers are used.",
        "companies": [
            "Google"
        ],
        "frequency_score": 9
    },
    {
        "id": 30,
        "topic": "BigQuery",
        "question": "You have a large JSON dataset in GCS that has a schema that changes slightly over time (new fields added). You want to query it in BigQuery. What is the best approach?",
        "options": [
            "Define a rigid schema and drop rows that don't match",
            "Use automatic schema detection (autodetect=True) or query as external table with schema evolution support",
            "Convert to CSV first",
            "Use Datastore"
        ],
        "answer": "Use automatic schema detection (autodetect=True) or query as external table with schema evolution support",
        "explanation": "BigQuery supports schema evolution (adding columns) for JSON loads, or you can query JSON directly using JSON data type for flexibility.",
        "companies": [
            "Google"
        ],
        "frequency_score": 10
    },
    {
        "id": 31,
        "topic": "Dataflow",
        "companies": [
            "Google",
            "Spotify",
            "New York Times"
        ],
        "question": "You are building a streaming pipeline to process user clickstreams. You need to handle periods of user activity separated by gaps. What windowing strategy is appropriate?",
        "options": [
            "Fixed Windows",
            "Sliding Windows",
            "Session Windows",
            "Global Windows"
        ],
        "answer": "Session Windows",
        "explanation": "Session windows gap-fill based on activity. Sliding windows overlap (e.g. every 5 min show last 1 hour). Fixed windows are tumbling.",
        "frequency_score": 9
    },
    {
        "id": 32,
        "topic": "Apache Kafka",
        "companies": [
            "Google",
            "LinkedIn"
        ],
        "question": "What happens if a Kafka Consumer Group has more consumers than partitions in the topic?",
        "options": [
            "Some consumers will be idle",
            "Throughput increases linearly",
            "Kafka automatically creates more partitions",
            "The extra consumers duplicate the data"
        ],
        "answer": "Some consumers will be idle",
        "explanation": "A partition can be consumed by only one consumer within a group at a time. Extra consumers stay idle.",
        "frequency_score": 6
    },
    {
        "id": 33,
        "topic": "Cloud Spanner",
        "companies": [
            "Google",
            "Uber",
            "Pokemon GO"
        ],
        "question": "You are designing a global banking ledger. You require strong consistency and 99.999% availability. Which database service should you choose?",
        "options": [
            "Cloud Spanner",
            "Cloud SQL",
            "Bigtable",
            "Firestore"
        ],
        "answer": "Cloud Spanner",
        "explanation": "Cloud Spanner is the only service providing global strong consistency and horizontal scalability with relational semantics (SQL).",
        "frequency_score": 8
    },
    {
        "id": 34,
        "topic": "Apache Spark",
        "companies": [
            "Google",
            "Databricks",
            "Facebook",
            "Netflix"
        ],
        "question": "You are optimizing a Spark job that is suffering from data skew. One task takes 10x longer than others during a wide transformation. Which technique is most effective?",
        "options": [
            "Salting the key",
            "Increasing the number of executors",
            "Using a larger instance type",
            "Broadcasting the large table"
        ],
        "answer": "Salting the key",
        "explanation": "Salting adds a random prefix to the skewed key to distribute it. Broadcasting is best for Skewed Joins where one table is small.",
        "frequency_score": 6
    },
    {
        "id": 35,
        "topic": "Pub/Sub",
        "companies": [
            "Google",
            "Uber"
        ],
        "question": "Your application publishes high throughput messages to Pub/Sub. You observe increased end-to-end latency and growing backlog. What is the most likely cause?",
        "options": [
            "Subscribers are too slow (backlog)",
            "Publisher quota exceeded",
            "Message size too large",
            "Ordering keys are causing hotspots"
        ],
        "answer": "Subscribers are too slow (backlog)",
        "explanation": "If using ordering keys, high throughput on a single key can limit scalability (1MB/s limit per key). Slow subscribers cause increased backlog.",
        "frequency_score": 7
    },
    {
        "id": 36,
        "topic": "Apache Kafka",
        "companies": [
            "Google",
            "LinkedIn"
        ],
        "question": "What happens if a Kafka Consumer Group has more consumers than partitions in the topic? ",
        "options": [
            "Some consumers will be idle",
            "Throughput increases linearly",
            "Kafka automatically creates more partitions",
            "The extra consumers duplicate the data"
        ],
        "answer": "Some consumers will be idle",
        "explanation": "A partition can be consumed by only one consumer within a group at a time. Extra consumers stay idle.",
        "frequency_score": 6
    },
    {
        "id": 37,
        "topic": "IAM",
        "companies": [
            "Google"
        ],
        "question": "A developer needs to view BigQuery datasets in a production project. Following the principle of least privilege, which role should you grant?",
        "options": [
            "Viewer",
            "Editor",
            "Owner",
            "BigQuery Data Viewer"
        ],
        "answer": "BigQuery Data Viewer",
        "explanation": "Always prefer predefined specific roles (like BigQuery Data Viewer, Storage Object Admin) over basic roles (Viewer/Editor/Owner) to ensure least privilege.",
        "frequency_score": 9
    },
    {
        "id": 38,
        "topic": "Data Structures",
        "companies": [
            "Google",
            "Amazon",
            "Microsoft",
            "Facebook"
        ],
        "question": "You need to implement a look-up service that checks if a user ID exists in a set of 1 billion users with O(1) average time complexity. Which data structure is best?",
        "options": [
            "Hash Table / HashSet",
            "Binary Search Tree",
            "Linked List",
            "Array"
        ],
        "answer": "Hash Table / HashSet",
        "explanation": "Hash Tables provide O(1) average case lookup. BST is O(log n).",
        "frequency_score": 8
    },
    {
        "id": 39,
        "topic": "Algorithms",
        "companies": [
            "Google",
            "Amazon",
            "Microsoft"
        ],
        "question": "What is the time complexity of a Bubble Sort algorithm in the worst case?",
        "options": [
            "O(n log n)",
            "O(n^2)",
            "O(n)",
            "O(log n)"
        ],
        "answer": "O(n^2)",
        "explanation": "Merge Sort is O(n log n). Quick Sort is O(n^2) in worst case (though avg O(n log n)). Bubble Sort is O(n^2).",
        "frequency_score": 8
    },
    {
        "id": 40,
        "topic": "Bigtable",
        "companies": [
            "Google",
            "Spotify"
        ],
        "question": "You are designing a Bigtable schema for social media posts. Queries will primarily be retrieve latest events for a specific entity. Which row key design is optimal?",
        "options": [
            "SensorID#Timestamp",
            "Timestamp#SensorID",
            "ReverseTimestamp#SensorID",
            "Random#SensorID"
        ],
        "answer": "SensorID#Timestamp",
        "explanation": "Avoid starting with timestamp to prevent hotspots. Use EntityID first for entity-lookup queries. Use ReverseTimestamp for 'latest items' queries globally.",
        "frequency_score": 7
    },
    {
        "id": 41,
        "topic": "Data Structures",
        "companies": [
            "Google",
            "Amazon",
            "Microsoft",
            "Facebook"
        ],
        "question": "You need to implement a look-up service that checks if a user ID exists in a set of 1 billion users with O(1) average time complexity. Which data structure is best? ",
        "options": [
            "Hash Table / HashSet",
            "Binary Search Tree",
            "Linked List",
            "Array"
        ],
        "answer": "Hash Table / HashSet",
        "explanation": "Hash Tables provide O(1) average case lookup. BST is O(log n).",
        "frequency_score": 8
    },
    {
        "id": 42,
        "topic": "Bigtable",
        "companies": [
            "Google",
            "Spotify"
        ],
        "question": "You are designing a Bigtable schema for financial transactions. Queries will primarily be retrieve most recent events globally. Which row key design is optimal?",
        "options": [
            "SensorID#Timestamp",
            "Timestamp#SensorID",
            "ReverseTimestamp#SensorID",
            "Random#SensorID"
        ],
        "answer": "ReverseTimestamp#SensorID",
        "explanation": "Avoid starting with timestamp to prevent hotspots. Use EntityID first for entity-lookup queries. Use ReverseTimestamp for 'latest items' queries globally.",
        "frequency_score": 7
    },
    {
        "id": 43,
        "topic": "Cloud Storage",
        "companies": [
            "Google",
            "Snapchat"
        ],
        "question": "You are designing a storage solution for disaster recovery backups. The requirement is access once a quarter. What storage class should you use?",
        "options": [
            "Standard",
            "Nearline",
            "Coldline",
            "Archive"
        ],
        "answer": "Coldline",
        "explanation": "Standard for hot data. Nearline < 1/month. Coldline < 1/quarter. Archive < 1/year.",
        "frequency_score": 6
    },
    {
        "id": 44,
        "topic": "Cloud Storage",
        "companies": [
            "Google",
            "Snapchat"
        ],
        "question": "You are designing a storage solution for disaster recovery backups. The requirement is access once a month. What storage class should you use?",
        "options": [
            "Standard",
            "Nearline",
            "Coldline",
            "Archive"
        ],
        "answer": "Nearline",
        "explanation": "Standard for hot data. Nearline < 1/month. Coldline < 1/quarter. Archive < 1/year.",
        "frequency_score": 6
    },
    {
        "id": 45,
        "topic": "Dataflow",
        "companies": [
            "Google",
            "Spotify",
            "New York Times"
        ],
        "question": "You are building a streaming pipeline to process user clickstreams. You need to handle hourly reporting. What windowing strategy is appropriate?",
        "options": [
            "Fixed Windows",
            "Sliding Windows",
            "Session Windows",
            "Global Windows"
        ],
        "answer": "Fixed Windows",
        "explanation": "Session windows gap-fill based on activity. Sliding windows overlap (e.g. every 5 min show last 1 hour). Fixed windows are tumbling.",
        "frequency_score": 9
    },
    {
        "id": 46,
        "topic": "IAM",
        "companies": [
            "Google"
        ],
        "question": "A developer needs to upload files to a bucket in a production project. Following the principle of least privilege, which role should you grant?",
        "options": [
            "Viewer",
            "Editor",
            "Owner",
            "BigQuery Data Viewer"
        ],
        "answer": "BigQuery Data Viewer",
        "explanation": "Always prefer predefined specific roles (like BigQuery Data Viewer, Storage Object Admin) over basic roles (Viewer/Editor/Owner) to ensure least privilege.",
        "frequency_score": 9
    },
    {
        "id": 47,
        "topic": "Algorithms",
        "companies": [
            "Google",
            "Amazon",
            "Microsoft"
        ],
        "question": "What is the time complexity of a Merge Sort algorithm in the worst case?",
        "options": [
            "O(n log n)",
            "O(n^2)",
            "O(n)",
            "O(log n)"
        ],
        "answer": "O(n log n)",
        "explanation": "Merge Sort is O(n log n). Quick Sort is O(n^2) in worst case (though avg O(n log n)). Bubble Sort is O(n^2).",
        "frequency_score": 8
    },
    {
        "id": 48,
        "topic": "Cloud Spanner",
        "companies": [
            "Google",
            "Uber",
            "Pokemon GO"
        ],
        "question": "You are designing a global banking ledger. You require strong consistency and horizontal scalability. Which database service should you choose?",
        "options": [
            "Cloud Spanner",
            "Cloud SQL",
            "Bigtable",
            "Firestore"
        ],
        "answer": "Cloud Spanner",
        "explanation": "Cloud Spanner is the only service providing global strong consistency and horizontal scalability with relational semantics (SQL).",
        "frequency_score": 8
    },
    {
        "id": 49,
        "topic": "IAM",
        "companies": [
            "Google"
        ],
        "question": "A developer needs to deploy Cloud Functions in a production project. Following the principle of least privilege, which role should you grant?",
        "options": [
            "Viewer",
            "Editor",
            "Owner",
            "BigQuery Data Viewer"
        ],
        "answer": "BigQuery Data Viewer",
        "explanation": "Always prefer predefined specific roles (like BigQuery Data Viewer, Storage Object Admin) over basic roles (Viewer/Editor/Owner) to ensure least privilege.",
        "frequency_score": 9
    },
    {
        "id": 50,
        "topic": "IAM",
        "companies": [
            "Google"
        ],
        "question": "A developer needs to upload files to a bucket in a production project. Following the principle of least privilege, which role should you grant? ",
        "options": [
            "Viewer",
            "Editor",
            "Owner",
            "Cloud Functions Developer"
        ],
        "answer": "Cloud Functions Developer",
        "explanation": "Always prefer predefined specific roles (like BigQuery Data Viewer, Storage Object Admin) over basic roles (Viewer/Editor/Owner) to ensure least privilege.",
        "frequency_score": 9
    },
    {
        "id": 51,
        "topic": "Apache Spark",
        "companies": [
            "Google",
            "Databricks",
            "Amazon"
        ],
        "question": "In Spark, what is the difference between a Transformation and an Action?",
        "options": [
            "Transformations are lazy, Actions match strict execution",
            "Actions are lazy, Transformations trigger execution",
            "They are the same",
            "Transformations save to disk, Actions read from disk"
        ],
        "answer": "Transformations are lazy, Actions match strict execution",
        "explanation": "Transformations (like map, filter) build the DAG but do not execute. Actions (like count, collect, save) trigger the actual computation.",
        "frequency_score": 6
    },
    {
        "id": 52,
        "topic": "BigQuery",
        "companies": [
            "Google",
            "Spotify",
            "Twitter"
        ],
        "question": "You need to store 500 TB of sensor metrics data in BigQuery. The data is accessed continuously. Which storage class fits best to minimize costs?",
        "options": [
            "Active Storage",
            "Long-term Storage",
            "Nearline Storage",
            "Coldline Storage"
        ],
        "answer": "Active Storage",
        "explanation": "BigQuery Long-term storage applies automatically after 90 days of no modification, reducing price by ~50%.",
        "frequency_score": 10
    },
    {
        "id": 53,
        "topic": "Dataflow",
        "companies": [
            "Google",
            "Spotify",
            "New York Times"
        ],
        "question": "You are building a streaming pipeline to process IoT temperature sensors. You need to handle hourly reporting. What windowing strategy is appropriate?",
        "options": [
            "Fixed Windows",
            "Sliding Windows",
            "Session Windows",
            "Global Windows"
        ],
        "answer": "Fixed Windows",
        "explanation": "Session windows gap-fill based on activity. Sliding windows overlap (e.g. every 5 min show last 1 hour). Fixed windows are tumbling.",
        "frequency_score": 9
    },
    {
        "id": 54,
        "topic": "Apache Kafka",
        "companies": [
            "Google",
            "LinkedIn"
        ],
        "question": "What happens if a Kafka Consumer Group has more consumers than partitions in the topic? ",
        "options": [
            "Some consumers will be idle",
            "Throughput increases linearly",
            "Kafka automatically creates more partitions",
            "The extra consumers duplicate the data"
        ],
        "answer": "Some consumers will be idle",
        "explanation": "A partition can be consumed by only one consumer within a group at a time. Extra consumers stay idle.",
        "frequency_score": 6
    },
    {
        "id": 55,
        "topic": "Data Structures",
        "companies": [
            "Google",
            "Amazon",
            "Microsoft",
            "Facebook"
        ],
        "question": "You need to implement a look-up service that checks if a user ID exists in a set of 1 billion users with O(log n) average time complexity. Which data structure is best?",
        "options": [
            "Hash Table / HashSet",
            "Binary Search Tree",
            "Linked List",
            "Array"
        ],
        "answer": "Binary Search Tree",
        "explanation": "Hash Tables provide O(1) average case lookup. BST is O(log n).",
        "frequency_score": 8
    },
    {
        "id": 56,
        "topic": "Cloud Storage",
        "companies": [
            "Google",
            "Snapchat"
        ],
        "question": "You are designing a storage solution for regulatory archives. The requirement is high frequency access. What storage class should you use?",
        "options": [
            "Standard",
            "Nearline",
            "Coldline",
            "Archive"
        ],
        "answer": "Standard",
        "explanation": "Standard for hot data. Nearline < 1/month. Coldline < 1/quarter. Archive < 1/year.",
        "frequency_score": 6
    },
    {
        "id": 57,
        "topic": "IAM",
        "companies": [
            "Google"
        ],
        "question": "A developer needs to deploy Cloud Functions in a production project. Following the principle of least privilege, which role should you grant? ",
        "options": [
            "Viewer",
            "Editor",
            "Owner",
            "Cloud Functions Developer"
        ],
        "answer": "Cloud Functions Developer",
        "explanation": "Always prefer predefined specific roles (like BigQuery Data Viewer, Storage Object Admin) over basic roles (Viewer/Editor/Owner) to ensure least privilege.",
        "frequency_score": 9
    },
    {
        "id": 58,
        "topic": "Apache Spark",
        "companies": [
            "Google",
            "Databricks",
            "Facebook",
            "Netflix"
        ],
        "question": "You are optimizing a Spark job that is suffering from data skew. One task takes 10x longer than others during a wide transformation. Which technique is most effective? ",
        "options": [
            "Salting the key",
            "Increasing the number of executors",
            "Using a larger instance type",
            "Broadcasting the large table"
        ],
        "answer": "Salting the key",
        "explanation": "Salting adds a random prefix to the skewed key to distribute it. Broadcasting is best for Skewed Joins where one table is small.",
        "frequency_score": 6
    },
    {
        "id": 59,
        "topic": "Pub/Sub",
        "companies": [
            "Google",
            "Uber"
        ],
        "question": "Your application publishes 1 million/sec messages to Pub/Sub. You observe throughput limits on specific keys. What is the most likely cause?",
        "options": [
            "Subscribers are too slow (backlog)",
            "Publisher quota exceeded",
            "Message size too large",
            "Ordering keys are causing hotspots"
        ],
        "answer": "Ordering keys are causing hotspots",
        "explanation": "If using ordering keys, high throughput on a single key can limit scalability (1MB/s limit per key). Slow subscribers cause increased backlog.",
        "frequency_score": 7
    },
    {
        "id": 60,
        "topic": "Cloud Storage",
        "companies": [
            "Google",
            "Snapchat"
        ],
        "question": "You are designing a storage solution for profile pictures. The requirement is high frequency access. What storage class should you use?",
        "options": [
            "Standard",
            "Nearline",
            "Coldline",
            "Archive"
        ],
        "answer": "Standard",
        "explanation": "Standard for hot data. Nearline < 1/month. Coldline < 1/quarter. Archive < 1/year.",
        "frequency_score": 6
    },
    {
        "id": 61,
        "topic": "IAM",
        "companies": [
            "Google"
        ],
        "question": "A developer needs to deploy Cloud Functions in a production project. Following the principle of least privilege, which role should you grant? ",
        "options": [
            "Viewer",
            "Editor",
            "Owner",
            "Cloud Functions Developer"
        ],
        "answer": "Cloud Functions Developer",
        "explanation": "Always prefer predefined specific roles (like BigQuery Data Viewer, Storage Object Admin) over basic roles (Viewer/Editor/Owner) to ensure least privilege.",
        "frequency_score": 9
    },
    {
        "id": 62,
        "topic": "Apache Kafka",
        "companies": [
            "Google",
            "LinkedIn"
        ],
        "question": "What happens if a Kafka Consumer Group has more consumers than partitions in the topic? ",
        "options": [
            "Some consumers will be idle",
            "Throughput increases linearly",
            "Kafka automatically creates more partitions",
            "The extra consumers duplicate the data"
        ],
        "answer": "Some consumers will be idle",
        "explanation": "A partition can be consumed by only one consumer within a group at a time. Extra consumers stay idle.",
        "frequency_score": 6
    },
    {
        "id": 63,
        "topic": "Pub/Sub",
        "companies": [
            "Google",
            "Uber"
        ],
        "question": "Your application publishes high throughput messages to Pub/Sub. You observe increased end-to-end latency and growing backlog. What is the most likely cause? ",
        "options": [
            "Subscribers are too slow (backlog)",
            "Publisher quota exceeded",
            "Message size too large",
            "Ordering keys are causing hotspots"
        ],
        "answer": "Subscribers are too slow (backlog)",
        "explanation": "If using ordering keys, high throughput on a single key can limit scalability (1MB/s limit per key). Slow subscribers cause increased backlog.",
        "frequency_score": 7
    },
    {
        "id": 64,
        "topic": "Cloud Storage",
        "companies": [
            "Google",
            "Snapchat"
        ],
        "question": "You are designing a storage solution for daily analytics content. The requirement is access once a year. What storage class should you use?",
        "options": [
            "Standard",
            "Nearline",
            "Coldline",
            "Archive"
        ],
        "answer": "Archive",
        "explanation": "Standard for hot data. Nearline < 1/month. Coldline < 1/quarter. Archive < 1/year.",
        "frequency_score": 6
    },
    {
        "id": 65,
        "topic": "Bigtable",
        "companies": [
            "Google",
            "Spotify"
        ],
        "question": "You are designing a Bigtable schema for social media posts. Queries will primarily be retrieve most recent events globally. Which row key design is optimal?",
        "options": [
            "DeviceID#Date",
            "Date#DeviceID",
            "ReverseTimestamp#DeviceID",
            "Random#DeviceID"
        ],
        "answer": "ReverseTimestamp#DeviceID",
        "explanation": "Avoid starting with timestamp to prevent hotspots. Use EntityID first for entity-lookup queries. Use ReverseTimestamp for 'latest items' queries globally.",
        "frequency_score": 7
    },
    {
        "id": 66,
        "topic": "Algorithms",
        "companies": [
            "Google",
            "Amazon",
            "Microsoft"
        ],
        "question": "What is the time complexity of a Bubble Sort algorithm in the worst case? ",
        "options": [
            "O(n log n)",
            "O(n^2)",
            "O(n)",
            "O(log n)"
        ],
        "answer": "O(n^2)",
        "explanation": "Merge Sort is O(n log n). Quick Sort is O(n^2) in worst case (though avg O(n log n)). Bubble Sort is O(n^2).",
        "frequency_score": 8
    },
    {
        "id": 67,
        "topic": "Dataflow",
        "companies": [
            "Google",
            "Spotify",
            "New York Times"
        ],
        "question": "You are building a streaming pipeline to process server logs. You need to handle rolling averages every minute for the last hour. What windowing strategy is appropriate?",
        "options": [
            "Fixed Windows",
            "Sliding Windows",
            "Session Windows",
            "Global Windows"
        ],
        "answer": "Sliding Windows",
        "explanation": "Session windows gap-fill based on activity. Sliding windows overlap (e.g. every 5 min show last 1 hour). Fixed windows are tumbling.",
        "frequency_score": 9
    },
    {
        "id": 68,
        "topic": "Apache Kafka",
        "companies": [
            "Google",
            "LinkedIn",
            "Uber",
            "Netflix"
        ],
        "question": "You need to ensure strict ordering of messages in Kafka for a specific Device ID. How should you configure the producer?",
        "options": [
            "Use the Device ID as the partition key",
            "Use a single partition for the entire topic",
            "Enable idempotent producer",
            "Increase replication factor"
        ],
        "answer": "Use the Device ID as the partition key",
        "explanation": "Kafka guarantees ordering WITHIN a partition. Using the Entity ID as the key ensures all messages for that entity go to the same partition.",
        "frequency_score": 6
    },
    {
        "id": 69,
        "topic": "Apache Spark",
        "companies": [
            "Google",
            "Databricks",
            "Facebook",
            "Netflix"
        ],
        "question": "You are optimizing a Spark job that is suffering from data skew. You are joining a large skewed table with a small reference table. Which technique is most effective?",
        "options": [
            "Salting the key",
            "Increasing the number of executors",
            "Using a larger instance type",
            "Broadcasting the large table"
        ],
        "answer": "Salting the key",
        "explanation": "Salting adds a random prefix to the skewed key to distribute it. Broadcasting is best for Skewed Joins where one table is small.",
        "frequency_score": 6
    },
    {
        "id": 70,
        "topic": "Apache Spark",
        "companies": [
            "Google",
            "Databricks",
            "Amazon"
        ],
        "question": "In Spark, what is the difference between a Transformation and an Action? ",
        "options": [
            "Transformations are lazy, Actions match strict execution",
            "Actions are lazy, Transformations trigger execution",
            "They are the same",
            "Transformations save to disk, Actions read from disk"
        ],
        "answer": "Transformations are lazy, Actions match strict execution",
        "explanation": "Transformations (like map, filter) build the DAG but do not execute. Actions (like count, collect, save) trigger the actual computation.",
        "frequency_score": 6
    },
    {
        "id": 71,
        "topic": "Pub/Sub",
        "companies": [
            "Google",
            "Uber"
        ],
        "question": "Your application publishes high throughput messages to Pub/Sub. You observe throughput limits on specific keys. What is the most likely cause?",
        "options": [
            "Subscribers are too slow (backlog)",
            "Publisher quota exceeded",
            "Message size too large",
            "Ordering keys are causing hotspots"
        ],
        "answer": "Ordering keys are causing hotspots",
        "explanation": "If using ordering keys, high throughput on a single key can limit scalability (1MB/s limit per key). Slow subscribers cause increased backlog.",
        "frequency_score": 7
    },
    {
        "id": 72,
        "topic": "Apache Spark",
        "companies": [
            "Google",
            "Databricks",
            "Amazon"
        ],
        "question": "In Spark, what is the difference between a Transformation and an Action? ",
        "options": [
            "Transformations are lazy, Actions match strict execution",
            "Actions are lazy, Transformations trigger execution",
            "They are the same",
            "Transformations save to disk, Actions read from disk"
        ],
        "answer": "Transformations are lazy, Actions match strict execution",
        "explanation": "Transformations (like map, filter) build the DAG but do not execute. Actions (like count, collect, save) trigger the actual computation.",
        "frequency_score": 6
    },
    {
        "id": 73,
        "topic": "Bigtable",
        "companies": [
            "Google",
            "Spotify"
        ],
        "question": "You are designing a Bigtable schema for IoT events. Queries will primarily be retrieve most recent events globally. Which row key design is optimal?",
        "options": [
            "SensorID#Date",
            "Date#SensorID",
            "ReverseTimestamp#SensorID",
            "Random#SensorID"
        ],
        "answer": "ReverseTimestamp#SensorID",
        "explanation": "Avoid starting with timestamp to prevent hotspots. Use EntityID first for entity-lookup queries. Use ReverseTimestamp for 'latest items' queries globally.",
        "frequency_score": 7
    },
    {
        "id": 74,
        "topic": "IAM",
        "companies": [
            "Google"
        ],
        "question": "A developer needs to view BigQuery datasets in a production project. Following the principle of least privilege, which role should you grant? ",
        "options": [
            "Viewer",
            "Editor",
            "Owner",
            "BigQuery Data Viewer"
        ],
        "answer": "BigQuery Data Viewer",
        "explanation": "Always prefer predefined specific roles (like BigQuery Data Viewer, Storage Object Admin) over basic roles (Viewer/Editor/Owner) to ensure least privilege.",
        "frequency_score": 9
    },
    {
        "id": 75,
        "topic": "BigQuery",
        "companies": [
            "Google",
            "Spotify",
            "Twitter"
        ],
        "question": "You need to store 1 PB of audit logs data in BigQuery. The data is accessed once a quarter. Which storage class fits best to minimize costs?",
        "options": [
            "Active Storage",
            "Long-term Storage",
            "Nearline Storage",
            "Coldline Storage"
        ],
        "answer": "Active Storage",
        "explanation": "BigQuery Long-term storage applies automatically after 90 days of no modification, reducing price by ~50%.",
        "frequency_score": 10
    },
    {
        "id": 76,
        "topic": "Apache Kafka",
        "companies": [
            "Google",
            "LinkedIn"
        ],
        "question": "What happens if a Kafka Consumer Group has more consumers than partitions in the topic? ",
        "options": [
            "Some consumers will be idle",
            "Throughput increases linearly",
            "Kafka automatically creates more partitions",
            "The extra consumers duplicate the data"
        ],
        "answer": "Some consumers will be idle",
        "explanation": "A partition can be consumed by only one consumer within a group at a time. Extra consumers stay idle.",
        "frequency_score": 6
    },
    {
        "id": 77,
        "topic": "Apache Kafka",
        "companies": [
            "Google",
            "LinkedIn"
        ],
        "question": "What happens if a Kafka Consumer Group has more consumers than partitions in the topic? ",
        "options": [
            "Some consumers will be idle",
            "Throughput increases linearly",
            "Kafka automatically creates more partitions",
            "The extra consumers duplicate the data"
        ],
        "answer": "Some consumers will be idle",
        "explanation": "A partition can be consumed by only one consumer within a group at a time. Extra consumers stay idle.",
        "frequency_score": 6
    },
    {
        "id": 78,
        "topic": "Algorithms",
        "companies": [
            "Google",
            "Amazon",
            "Microsoft"
        ],
        "question": "What is the time complexity of a Merge Sort algorithm in the worst case? ",
        "options": [
            "O(n log n)",
            "O(n^2)",
            "O(n)",
            "O(log n)"
        ],
        "answer": "O(n log n)",
        "explanation": "Merge Sort is O(n log n). Quick Sort is O(n^2) in worst case (though avg O(n log n)). Bubble Sort is O(n^2).",
        "frequency_score": 8
    },
    {
        "id": 79,
        "topic": "Dataflow",
        "companies": [
            "Google",
            "Spotify",
            "New York Times"
        ],
        "question": "You are building a streaming pipeline to process user clickstreams. You need to handle rolling averages every minute for the last hour. What windowing strategy is appropriate?",
        "options": [
            "Fixed Windows",
            "Sliding Windows",
            "Session Windows",
            "Global Windows"
        ],
        "answer": "Sliding Windows",
        "explanation": "Session windows gap-fill based on activity. Sliding windows overlap (e.g. every 5 min show last 1 hour). Fixed windows are tumbling.",
        "frequency_score": 9
    },
    {
        "id": 80,
        "topic": "Bigtable",
        "companies": [
            "Google",
            "Spotify"
        ],
        "question": "You are designing a Bigtable schema for financial transactions. Queries will primarily be retrieve latest events for a specific entity. Which row key design is optimal?",
        "options": [
            "UserID#Timestamp",
            "Timestamp#UserID",
            "ReverseTimestamp#UserID",
            "Random#UserID"
        ],
        "answer": "UserID#Timestamp",
        "explanation": "Avoid starting with timestamp to prevent hotspots. Use EntityID first for entity-lookup queries. Use ReverseTimestamp for 'latest items' queries globally.",
        "frequency_score": 7
    },
    {
        "id": 81,
        "topic": "Pub/Sub",
        "companies": [
            "Google",
            "Uber"
        ],
        "question": "Your application publishes high throughput messages to Pub/Sub. You observe throughput limits on specific keys. What is the most likely cause? ",
        "options": [
            "Subscribers are too slow (backlog)",
            "Publisher quota exceeded",
            "Message size too large",
            "Ordering keys are causing hotspots"
        ],
        "answer": "Ordering keys are causing hotspots",
        "explanation": "If using ordering keys, high throughput on a single key can limit scalability (1MB/s limit per key). Slow subscribers cause increased backlog.",
        "frequency_score": 7
    },
    {
        "id": 82,
        "topic": "Bigtable",
        "companies": [
            "Google",
            "Spotify"
        ],
        "question": "You are designing a Bigtable schema for IoT events. Queries will primarily be retrieve latest events for a specific entity. Which row key design is optimal?",
        "options": [
            "UserID#Timestamp",
            "Timestamp#UserID",
            "ReverseTimestamp#UserID",
            "Random#UserID"
        ],
        "answer": "UserID#Timestamp",
        "explanation": "Avoid starting with timestamp to prevent hotspots. Use EntityID first for entity-lookup queries. Use ReverseTimestamp for 'latest items' queries globally.",
        "frequency_score": 7
    },
    {
        "id": 83,
        "topic": "Apache Kafka",
        "companies": [
            "Google",
            "LinkedIn"
        ],
        "question": "What happens if a Kafka Consumer Group has more consumers than partitions in the topic? ",
        "options": [
            "Some consumers will be idle",
            "Throughput increases linearly",
            "Kafka automatically creates more partitions",
            "The extra consumers duplicate the data"
        ],
        "answer": "Some consumers will be idle",
        "explanation": "A partition can be consumed by only one consumer within a group at a time. Extra consumers stay idle.",
        "frequency_score": 6
    },
    {
        "id": 84,
        "topic": "Algorithms",
        "companies": [
            "Google",
            "Amazon",
            "Microsoft"
        ],
        "question": "What is the time complexity of a Quick Sort algorithm in the worst case?",
        "options": [
            "O(n log n)",
            "O(n^2)",
            "O(n)",
            "O(log n)"
        ],
        "answer": "O(n^2)",
        "explanation": "Merge Sort is O(n log n). Quick Sort is O(n^2) in worst case (though avg O(n log n)). Bubble Sort is O(n^2).",
        "frequency_score": 8
    },
    {
        "id": 85,
        "topic": "Apache Kafka",
        "companies": [
            "Google",
            "LinkedIn",
            "Uber",
            "Netflix"
        ],
        "question": "You need to ensure strict ordering of messages in Kafka for a specific Device ID. How should you configure the producer? ",
        "options": [
            "Use the Device ID as the partition key",
            "Use a single partition for the entire topic",
            "Enable idempotent producer",
            "Increase replication factor"
        ],
        "answer": "Use the Device ID as the partition key",
        "explanation": "Kafka guarantees ordering WITHIN a partition. Using the Entity ID as the key ensures all messages for that entity go to the same partition.",
        "frequency_score": 6
    },
    {
        "id": 86,
        "topic": "Apache Spark",
        "companies": [
            "Google",
            "Databricks",
            "Amazon"
        ],
        "question": "In Spark, what is the difference between a Transformation and an Action? ",
        "options": [
            "Transformations are lazy, Actions match strict execution",
            "Actions are lazy, Transformations trigger execution",
            "They are the same",
            "Transformations save to disk, Actions read from disk"
        ],
        "answer": "Transformations are lazy, Actions match strict execution",
        "explanation": "Transformations (like map, filter) build the DAG but do not execute. Actions (like count, collect, save) trigger the actual computation.",
        "frequency_score": 6
    },
    {
        "id": 87,
        "topic": "Apache Kafka",
        "companies": [
            "Google",
            "LinkedIn"
        ],
        "question": "What happens if a Kafka Consumer Group has more consumers than partitions in the topic? ",
        "options": [
            "Some consumers will be idle",
            "Throughput increases linearly",
            "Kafka automatically creates more partitions",
            "The extra consumers duplicate the data"
        ],
        "answer": "Some consumers will be idle",
        "explanation": "A partition can be consumed by only one consumer within a group at a time. Extra consumers stay idle.",
        "frequency_score": 6
    },
    {
        "id": 88,
        "topic": "IAM",
        "companies": [
            "Google"
        ],
        "question": "A developer needs to view BigQuery datasets in a production project. Following the principle of least privilege, which role should you grant? ",
        "options": [
            "Viewer",
            "Editor",
            "Owner",
            "Storage Object Creator"
        ],
        "answer": "Storage Object Creator",
        "explanation": "Always prefer predefined specific roles (like BigQuery Data Viewer, Storage Object Admin) over basic roles (Viewer/Editor/Owner) to ensure least privilege.",
        "frequency_score": 9
    },
    {
        "id": 89,
        "topic": "BigQuery",
        "companies": [
            "Google",
            "Spotify",
            "Twitter"
        ],
        "question": "You need to store 500 TB of clickstream data data in BigQuery. The data is accessed continuously. Which storage class fits best to minimize costs?",
        "options": [
            "Active Storage",
            "Long-term Storage",
            "Nearline Storage",
            "Coldline Storage"
        ],
        "answer": "Active Storage",
        "explanation": "BigQuery Long-term storage applies automatically after 90 days of no modification, reducing price by ~50%.",
        "frequency_score": 10
    },
    {
        "id": 90,
        "topic": "Cloud Storage",
        "companies": [
            "Google",
            "Snapchat"
        ],
        "question": "You are designing a storage solution for daily analytics content. The requirement is access once a year. What storage class should you use? ",
        "options": [
            "Standard",
            "Nearline",
            "Coldline",
            "Archive"
        ],
        "answer": "Archive",
        "explanation": "Standard for hot data. Nearline < 1/month. Coldline < 1/quarter. Archive < 1/year.",
        "frequency_score": 6
    },
    {
        "id": 91,
        "topic": "Dataflow",
        "companies": [
            "Google",
            "Spotify",
            "New York Times"
        ],
        "question": "You are building a streaming pipeline to process server logs. You need to handle periods of user activity separated by gaps. What windowing strategy is appropriate?",
        "options": [
            "Fixed Windows",
            "Sliding Windows",
            "Session Windows",
            "Global Windows"
        ],
        "answer": "Session Windows",
        "explanation": "Session windows gap-fill based on activity. Sliding windows overlap (e.g. every 5 min show last 1 hour). Fixed windows are tumbling.",
        "frequency_score": 9
    },
    {
        "id": 92,
        "topic": "Algorithms",
        "companies": [
            "Google",
            "Amazon",
            "Microsoft"
        ],
        "question": "What is the time complexity of a Bubble Sort algorithm in the worst case? ",
        "options": [
            "O(n log n)",
            "O(n^2)",
            "O(n)",
            "O(log n)"
        ],
        "answer": "O(n^2)",
        "explanation": "Merge Sort is O(n log n). Quick Sort is O(n^2) in worst case (though avg O(n log n)). Bubble Sort is O(n^2).",
        "frequency_score": 8
    },
    {
        "id": 93,
        "topic": "Data Structures",
        "companies": [
            "Google",
            "Amazon",
            "Microsoft",
            "Facebook"
        ],
        "question": "You need to implement a look-up service that checks if a user ID exists in a set of 1 billion users with O(log n) average time complexity. Which data structure is best? ",
        "options": [
            "Hash Table / HashSet",
            "Binary Search Tree",
            "Linked List",
            "Array"
        ],
        "answer": "Binary Search Tree",
        "explanation": "Hash Tables provide O(1) average case lookup. BST is O(log n).",
        "frequency_score": 8
    },
    {
        "id": 94,
        "topic": "Apache Kafka",
        "companies": [
            "Google",
            "LinkedIn",
            "Uber",
            "Netflix"
        ],
        "question": "You need to ensure strict ordering of messages in Kafka for a specific Device ID. How should you configure the producer? ",
        "options": [
            "Use the Device ID as the partition key",
            "Use a single partition for the entire topic",
            "Enable idempotent producer",
            "Increase replication factor"
        ],
        "answer": "Use the Device ID as the partition key",
        "explanation": "Kafka guarantees ordering WITHIN a partition. Using the Entity ID as the key ensures all messages for that entity go to the same partition.",
        "frequency_score": 6
    },
    {
        "id": 95,
        "topic": "Data Structures",
        "companies": [
            "Google",
            "Amazon",
            "Microsoft",
            "Facebook"
        ],
        "question": "You need to implement a look-up service that checks if a user ID exists in a set of 1 billion users with O(1) average time complexity. Which data structure is best? ",
        "options": [
            "Hash Table / HashSet",
            "Binary Search Tree",
            "Linked List",
            "Array"
        ],
        "answer": "Hash Table / HashSet",
        "explanation": "Hash Tables provide O(1) average case lookup. BST is O(log n).",
        "frequency_score": 8
    },
    {
        "id": 96,
        "topic": "Cloud Storage",
        "companies": [
            "Google",
            "Snapchat"
        ],
        "question": "You are designing a storage solution for daily analytics content. The requirement is access once a month. What storage class should you use?",
        "options": [
            "Standard",
            "Nearline",
            "Coldline",
            "Archive"
        ],
        "answer": "Nearline",
        "explanation": "Standard for hot data. Nearline < 1/month. Coldline < 1/quarter. Archive < 1/year.",
        "frequency_score": 6
    },
    {
        "id": 97,
        "topic": "Apache Spark",
        "companies": [
            "Google",
            "Databricks",
            "Amazon"
        ],
        "question": "In Spark, what is the difference between a Transformation and an Action? ",
        "options": [
            "Transformations are lazy, Actions match strict execution",
            "Actions are lazy, Transformations trigger execution",
            "They are the same",
            "Transformations save to disk, Actions read from disk"
        ],
        "answer": "Transformations are lazy, Actions match strict execution",
        "explanation": "Transformations (like map, filter) build the DAG but do not execute. Actions (like count, collect, save) trigger the actual computation.",
        "frequency_score": 6
    },
    {
        "id": 98,
        "topic": "BigQuery",
        "companies": [
            "Google",
            "Spotify",
            "Twitter"
        ],
        "question": "You need to store 1 PB of sensor metrics data in BigQuery. The data is accessed daily. Which storage class fits best to minimize costs?",
        "options": [
            "Active Storage",
            "Long-term Storage",
            "Nearline Storage",
            "Coldline Storage"
        ],
        "answer": "Active Storage",
        "explanation": "BigQuery Long-term storage applies automatically after 90 days of no modification, reducing price by ~50%.",
        "frequency_score": 10
    },
    {
        "id": 99,
        "topic": "Apache Kafka",
        "companies": [
            "Google",
            "LinkedIn",
            "Uber",
            "Netflix"
        ],
        "question": "You need to ensure strict ordering of messages in Kafka for a specific Device ID. How should you configure the producer? ",
        "options": [
            "Use the Device ID as the partition key",
            "Use a single partition for the entire topic",
            "Enable idempotent producer",
            "Increase replication factor"
        ],
        "answer": "Use the Device ID as the partition key",
        "explanation": "Kafka guarantees ordering WITHIN a partition. Using the Entity ID as the key ensures all messages for that entity go to the same partition.",
        "frequency_score": 6
    },
    {
        "id": 100,
        "topic": "Apache Kafka",
        "companies": [
            "Google",
            "LinkedIn"
        ],
        "question": "What happens if a Kafka Consumer Group has more consumers than partitions in the topic? ",
        "options": [
            "Some consumers will be idle",
            "Throughput increases linearly",
            "Kafka automatically creates more partitions",
            "The extra consumers duplicate the data"
        ],
        "answer": "Some consumers will be idle",
        "explanation": "A partition can be consumed by only one consumer within a group at a time. Extra consumers stay idle.",
        "frequency_score": 6
    },
    {
        "id": 101,
        "topic": "Cloud Spanner",
        "companies": [
            "Google",
            "Uber",
            "Pokemon GO"
        ],
        "question": "You are designing a global banking ledger. You require strong consistency and 99.999% availability. Which database service should you choose? ",
        "options": [
            "Cloud Spanner",
            "Cloud SQL",
            "Bigtable",
            "Firestore"
        ],
        "answer": "Cloud Spanner",
        "explanation": "Cloud Spanner is the only service providing global strong consistency and horizontal scalability with relational semantics (SQL).",
        "frequency_score": 8
    },
    {
        "id": 102,
        "topic": "Cloud Spanner",
        "companies": [
            "Google",
            "Uber",
            "Pokemon GO"
        ],
        "question": "You are designing a global banking ledger. You require strong consistency and horizontal scalability. Which database service should you choose? ",
        "options": [
            "Cloud Spanner",
            "Cloud SQL",
            "Bigtable",
            "Firestore"
        ],
        "answer": "Cloud Spanner",
        "explanation": "Cloud Spanner is the only service providing global strong consistency and horizontal scalability with relational semantics (SQL).",
        "frequency_score": 8
    },
    {
        "id": 103,
        "topic": "Apache Kafka",
        "companies": [
            "Google",
            "LinkedIn"
        ],
        "question": "What happens if a Kafka Consumer Group has more consumers than partitions in the topic? ",
        "options": [
            "Some consumers will be idle",
            "Throughput increases linearly",
            "Kafka automatically creates more partitions",
            "The extra consumers duplicate the data"
        ],
        "answer": "Some consumers will be idle",
        "explanation": "A partition can be consumed by only one consumer within a group at a time. Extra consumers stay idle.",
        "frequency_score": 6
    },
    {
        "id": 104,
        "topic": "Apache Kafka",
        "companies": [
            "Google",
            "LinkedIn",
            "Uber",
            "Netflix"
        ],
        "question": "You need to ensure strict ordering of messages in Kafka for a specific Device ID. How should you configure the producer? ",
        "options": [
            "Use the Device ID as the partition key",
            "Use a single partition for the entire topic",
            "Enable idempotent producer",
            "Increase replication factor"
        ],
        "answer": "Use the Device ID as the partition key",
        "explanation": "Kafka guarantees ordering WITHIN a partition. Using the Entity ID as the key ensures all messages for that entity go to the same partition.",
        "frequency_score": 6
    },
    {
        "id": 105,
        "topic": "Apache Spark",
        "companies": [
            "Google",
            "Databricks",
            "Amazon"
        ],
        "question": "In Spark, what is the difference between a Transformation and an Action? ",
        "options": [
            "Transformations are lazy, Actions match strict execution",
            "Actions are lazy, Transformations trigger execution",
            "They are the same",
            "Transformations save to disk, Actions read from disk"
        ],
        "answer": "Transformations are lazy, Actions match strict execution",
        "explanation": "Transformations (like map, filter) build the DAG but do not execute. Actions (like count, collect, save) trigger the actual computation.",
        "frequency_score": 6
    },
    {
        "id": 106,
        "topic": "Pub/Sub",
        "companies": [
            "Google",
            "Uber"
        ],
        "question": "Your application publishes high throughput messages to Pub/Sub. You observe throughput limits on specific keys. What is the most likely cause? ",
        "options": [
            "Subscribers are too slow (backlog)",
            "Publisher quota exceeded",
            "Message size too large",
            "Ordering keys are causing hotspots"
        ],
        "answer": "Ordering keys are causing hotspots",
        "explanation": "If using ordering keys, high throughput on a single key can limit scalability (1MB/s limit per key). Slow subscribers cause increased backlog.",
        "frequency_score": 7
    },
    {
        "id": 107,
        "topic": "Dataflow",
        "companies": [
            "Google",
            "Spotify",
            "New York Times"
        ],
        "question": "You are building a streaming pipeline to process IoT temperature sensors. You need to handle rolling averages every minute for the last hour. What windowing strategy is appropriate?",
        "options": [
            "Fixed Windows",
            "Sliding Windows",
            "Session Windows",
            "Global Windows"
        ],
        "answer": "Sliding Windows",
        "explanation": "Session windows gap-fill based on activity. Sliding windows overlap (e.g. every 5 min show last 1 hour). Fixed windows are tumbling.",
        "frequency_score": 9
    },
    {
        "id": 108,
        "topic": "Data Structures",
        "companies": [
            "Google",
            "Amazon",
            "Microsoft",
            "Facebook"
        ],
        "question": "You need to implement a look-up service that checks if a user ID exists in a set of 1 billion users with O(1) average time complexity. Which data structure is best? ",
        "options": [
            "Hash Table / HashSet",
            "Binary Search Tree",
            "Linked List",
            "Array"
        ],
        "answer": "Hash Table / HashSet",
        "explanation": "Hash Tables provide O(1) average case lookup. BST is O(log n).",
        "frequency_score": 8
    },
    {
        "id": 109,
        "topic": "Apache Kafka",
        "companies": [
            "Google",
            "LinkedIn",
            "Uber",
            "Netflix"
        ],
        "question": "You need to ensure strict ordering of messages in Kafka for a specific Device ID. How should you configure the producer? ",
        "options": [
            "Use the Device ID as the partition key",
            "Use a single partition for the entire topic",
            "Enable idempotent producer",
            "Increase replication factor"
        ],
        "answer": "Use the Device ID as the partition key",
        "explanation": "Kafka guarantees ordering WITHIN a partition. Using the Entity ID as the key ensures all messages for that entity go to the same partition.",
        "frequency_score": 6
    },
    {
        "id": 110,
        "topic": "Dataflow",
        "companies": [
            "Google",
            "Spotify",
            "New York Times"
        ],
        "question": "You are building a streaming pipeline to process IoT temperature sensors. You need to handle rolling averages every minute for the last hour. What windowing strategy is appropriate? ",
        "options": [
            "Fixed Windows",
            "Sliding Windows",
            "Session Windows",
            "Global Windows"
        ],
        "answer": "Sliding Windows",
        "explanation": "Session windows gap-fill based on activity. Sliding windows overlap (e.g. every 5 min show last 1 hour). Fixed windows are tumbling.",
        "frequency_score": 9
    },
    {
        "id": 111,
        "topic": "BigQuery",
        "companies": [
            "Google",
            "Spotify",
            "Twitter"
        ],
        "question": "You need to store 500 TB of transaction records data in BigQuery. The data is accessed once a quarter. Which storage class fits best to minimize costs?",
        "options": [
            "Active Storage",
            "Long-term Storage",
            "Nearline Storage",
            "Coldline Storage"
        ],
        "answer": "Active Storage",
        "explanation": "BigQuery Long-term storage applies automatically after 90 days of no modification, reducing price by ~50%.",
        "frequency_score": 10
    },
    {
        "id": 112,
        "topic": "BigQuery",
        "companies": [
            "Google",
            "Spotify",
            "Twitter"
        ],
        "question": "You need to store 500 TB of audit logs data in BigQuery. The data is accessed once a quarter. Which storage class fits best to minimize costs?",
        "options": [
            "Active Storage",
            "Long-term Storage",
            "Nearline Storage",
            "Coldline Storage"
        ],
        "answer": "Active Storage",
        "explanation": "BigQuery Long-term storage applies automatically after 90 days of no modification, reducing price by ~50%.",
        "frequency_score": 10
    },
    {
        "id": 113,
        "topic": "Apache Kafka",
        "companies": [
            "Google",
            "LinkedIn"
        ],
        "question": "What happens if a Kafka Consumer Group has more consumers than partitions in the topic? ",
        "options": [
            "Some consumers will be idle",
            "Throughput increases linearly",
            "Kafka automatically creates more partitions",
            "The extra consumers duplicate the data"
        ],
        "answer": "Some consumers will be idle",
        "explanation": "A partition can be consumed by only one consumer within a group at a time. Extra consumers stay idle.",
        "frequency_score": 6
    },
    {
        "id": 114,
        "topic": "Cloud Spanner",
        "companies": [
            "Google",
            "Uber",
            "Pokemon GO"
        ],
        "question": "You are designing a global banking ledger. You require strong consistency and horizontal scalability. Which database service should you choose? ",
        "options": [
            "Cloud Spanner",
            "Cloud SQL",
            "Bigtable",
            "Firestore"
        ],
        "answer": "Cloud Spanner",
        "explanation": "Cloud Spanner is the only service providing global strong consistency and horizontal scalability with relational semantics (SQL).",
        "frequency_score": 8
    },
    {
        "id": 115,
        "topic": "Data Structures",
        "companies": [
            "Google",
            "Amazon",
            "Microsoft",
            "Facebook"
        ],
        "question": "You need to implement a look-up service that checks if a user ID exists in a set of 1 billion users with O(log n) average time complexity. Which data structure is best? ",
        "options": [
            "Hash Table / HashSet",
            "Binary Search Tree",
            "Linked List",
            "Array"
        ],
        "answer": "Binary Search Tree",
        "explanation": "Hash Tables provide O(1) average case lookup. BST is O(log n).",
        "frequency_score": 8
    },
    {
        "id": 116,
        "topic": "Cloud Spanner",
        "companies": [
            "Google",
            "Uber",
            "Pokemon GO"
        ],
        "question": "You are designing a global banking ledger. You require strong consistency and 99.999% availability. Which database service should you choose? ",
        "options": [
            "Cloud Spanner",
            "Cloud SQL",
            "Bigtable",
            "Firestore"
        ],
        "answer": "Cloud Spanner",
        "explanation": "Cloud Spanner is the only service providing global strong consistency and horizontal scalability with relational semantics (SQL).",
        "frequency_score": 8
    },
    {
        "id": 117,
        "topic": "Apache Spark",
        "companies": [
            "Google",
            "Databricks",
            "Amazon"
        ],
        "question": "In Spark, what is the difference between a Transformation and an Action? ",
        "options": [
            "Transformations are lazy, Actions match strict execution",
            "Actions are lazy, Transformations trigger execution",
            "They are the same",
            "Transformations save to disk, Actions read from disk"
        ],
        "answer": "Transformations are lazy, Actions match strict execution",
        "explanation": "Transformations (like map, filter) build the DAG but do not execute. Actions (like count, collect, save) trigger the actual computation.",
        "frequency_score": 6
    },
    {
        "id": 118,
        "topic": "Pub/Sub",
        "companies": [
            "Google",
            "Uber"
        ],
        "question": "Your application publishes 1 million/sec messages to Pub/Sub. You observe throughput limits on specific keys. What is the most likely cause? ",
        "options": [
            "Subscribers are too slow (backlog)",
            "Publisher quota exceeded",
            "Message size too large",
            "Ordering keys are causing hotspots"
        ],
        "answer": "Ordering keys are causing hotspots",
        "explanation": "If using ordering keys, high throughput on a single key can limit scalability (1MB/s limit per key). Slow subscribers cause increased backlog.",
        "frequency_score": 7
    },
    {
        "id": 119,
        "topic": "Cloud Storage",
        "companies": [
            "Google",
            "Snapchat"
        ],
        "question": "You are designing a storage solution for daily analytics content. The requirement is access once a quarter. What storage class should you use?",
        "options": [
            "Standard",
            "Nearline",
            "Coldline",
            "Archive"
        ],
        "answer": "Coldline",
        "explanation": "Standard for hot data. Nearline < 1/month. Coldline < 1/quarter. Archive < 1/year.",
        "frequency_score": 6
    },
    {
        "id": 120,
        "topic": "Algorithms",
        "companies": [
            "Google",
            "Amazon",
            "Microsoft"
        ],
        "question": "What is the time complexity of a Quick Sort algorithm in the worst case? ",
        "options": [
            "O(n log n)",
            "O(n^2)",
            "O(n)",
            "O(log n)"
        ],
        "answer": "O(n^2)",
        "explanation": "Merge Sort is O(n log n). Quick Sort is O(n^2) in worst case (though avg O(n log n)). Bubble Sort is O(n^2).",
        "frequency_score": 8
    },
    {
        "id": 121,
        "topic": "Dataflow",
        "companies": [
            "Google",
            "Spotify",
            "New York Times"
        ],
        "question": "You are building a streaming pipeline to process server logs. You need to handle hourly reporting. What windowing strategy is appropriate?",
        "options": [
            "Fixed Windows",
            "Sliding Windows",
            "Session Windows",
            "Global Windows"
        ],
        "answer": "Fixed Windows",
        "explanation": "Session windows gap-fill based on activity. Sliding windows overlap (e.g. every 5 min show last 1 hour). Fixed windows are tumbling.",
        "frequency_score": 9
    },
    {
        "id": 122,
        "topic": "Cloud Storage",
        "companies": [
            "Google",
            "Snapchat"
        ],
        "question": "You are designing a storage solution for profile pictures. The requirement is access once a month. What storage class should you use?",
        "options": [
            "Standard",
            "Nearline",
            "Coldline",
            "Archive"
        ],
        "answer": "Nearline",
        "explanation": "Standard for hot data. Nearline < 1/month. Coldline < 1/quarter. Archive < 1/year.",
        "frequency_score": 6
    },
    {
        "id": 123,
        "topic": "IAM",
        "companies": [
            "Google"
        ],
        "question": "A developer needs to view BigQuery datasets in a production project. Following the principle of least privilege, which role should you grant? ",
        "options": [
            "Viewer",
            "Editor",
            "Owner",
            "Storage Object Creator"
        ],
        "answer": "Storage Object Creator",
        "explanation": "Always prefer predefined specific roles (like BigQuery Data Viewer, Storage Object Admin) over basic roles (Viewer/Editor/Owner) to ensure least privilege.",
        "frequency_score": 9
    },
    {
        "id": 124,
        "topic": "Cloud Storage",
        "companies": [
            "Google",
            "Snapchat"
        ],
        "question": "You are designing a storage solution for daily analytics content. The requirement is access once a month. What storage class should you use? ",
        "options": [
            "Standard",
            "Nearline",
            "Coldline",
            "Archive"
        ],
        "answer": "Nearline",
        "explanation": "Standard for hot data. Nearline < 1/month. Coldline < 1/quarter. Archive < 1/year.",
        "frequency_score": 6
    },
    {
        "id": 125,
        "topic": "Cloud Spanner",
        "companies": [
            "Google",
            "Uber",
            "Pokemon GO"
        ],
        "question": "You are designing a global banking ledger. You require strong consistency and 99.999% availability. Which database service should you choose? ",
        "options": [
            "Cloud Spanner",
            "Cloud SQL",
            "Bigtable",
            "Firestore"
        ],
        "answer": "Cloud Spanner",
        "explanation": "Cloud Spanner is the only service providing global strong consistency and horizontal scalability with relational semantics (SQL).",
        "frequency_score": 8
    },
    {
        "id": 126,
        "topic": "IAM",
        "companies": [
            "Google"
        ],
        "question": "A developer needs to deploy Cloud Functions in a production project. Following the principle of least privilege, which role should you grant? ",
        "options": [
            "Viewer",
            "Editor",
            "Owner",
            "BigQuery Data Viewer"
        ],
        "answer": "BigQuery Data Viewer",
        "explanation": "Always prefer predefined specific roles (like BigQuery Data Viewer, Storage Object Admin) over basic roles (Viewer/Editor/Owner) to ensure least privilege.",
        "frequency_score": 9
    },
    {
        "id": 127,
        "topic": "Cloud Spanner",
        "companies": [
            "Google",
            "Uber",
            "Pokemon GO"
        ],
        "question": "You are designing a global banking ledger. You require strong consistency and 99.999% availability. Which database service should you choose? ",
        "options": [
            "Cloud Spanner",
            "Cloud SQL",
            "Bigtable",
            "Firestore"
        ],
        "answer": "Cloud Spanner",
        "explanation": "Cloud Spanner is the only service providing global strong consistency and horizontal scalability with relational semantics (SQL).",
        "frequency_score": 8
    },
    {
        "id": 128,
        "topic": "Algorithms",
        "companies": [
            "Google",
            "Amazon",
            "Microsoft"
        ],
        "question": "What is the time complexity of a Merge Sort algorithm in the worst case? ",
        "options": [
            "O(n log n)",
            "O(n^2)",
            "O(n)",
            "O(log n)"
        ],
        "answer": "O(n log n)",
        "explanation": "Merge Sort is O(n log n). Quick Sort is O(n^2) in worst case (though avg O(n log n)). Bubble Sort is O(n^2).",
        "frequency_score": 8
    },
    {
        "id": 129,
        "topic": "Data Structures",
        "companies": [
            "Google",
            "Amazon",
            "Microsoft",
            "Facebook"
        ],
        "question": "You need to implement a look-up service that checks if a user ID exists in a set of 1 billion users with O(1) average time complexity. Which data structure is best? ",
        "options": [
            "Hash Table / HashSet",
            "Binary Search Tree",
            "Linked List",
            "Array"
        ],
        "answer": "Hash Table / HashSet",
        "explanation": "Hash Tables provide O(1) average case lookup. BST is O(log n).",
        "frequency_score": 8
    },
    {
        "id": 130,
        "topic": "Algorithms",
        "companies": [
            "Google",
            "Amazon",
            "Microsoft"
        ],
        "question": "What is the time complexity of a Quick Sort algorithm in the worst case? ",
        "options": [
            "O(n log n)",
            "O(n^2)",
            "O(n)",
            "O(log n)"
        ],
        "answer": "O(n^2)",
        "explanation": "Merge Sort is O(n log n). Quick Sort is O(n^2) in worst case (though avg O(n log n)). Bubble Sort is O(n^2).",
        "frequency_score": 8
    },
    {
        "id": 131,
        "topic": "IAM",
        "companies": [
            "Google"
        ],
        "question": "A developer needs to upload files to a bucket in a production project. Following the principle of least privilege, which role should you grant? ",
        "options": [
            "Viewer",
            "Editor",
            "Owner",
            "Cloud Functions Developer"
        ],
        "answer": "Cloud Functions Developer",
        "explanation": "Always prefer predefined specific roles (like BigQuery Data Viewer, Storage Object Admin) over basic roles (Viewer/Editor/Owner) to ensure least privilege.",
        "frequency_score": 9
    },
    {
        "id": 132,
        "topic": "Apache Spark",
        "companies": [
            "Google",
            "Databricks",
            "Amazon"
        ],
        "question": "In Spark, what is the difference between a Transformation and an Action? ",
        "options": [
            "Transformations are lazy, Actions match strict execution",
            "Actions are lazy, Transformations trigger execution",
            "They are the same",
            "Transformations save to disk, Actions read from disk"
        ],
        "answer": "Transformations are lazy, Actions match strict execution",
        "explanation": "Transformations (like map, filter) build the DAG but do not execute. Actions (like count, collect, save) trigger the actual computation.",
        "frequency_score": 6
    },
    {
        "id": 133,
        "topic": "Pub/Sub",
        "companies": [
            "Google",
            "Uber"
        ],
        "question": "Your application publishes high throughput messages to Pub/Sub. You observe throughput limits on specific keys. What is the most likely cause? ",
        "options": [
            "Subscribers are too slow (backlog)",
            "Publisher quota exceeded",
            "Message size too large",
            "Ordering keys are causing hotspots"
        ],
        "answer": "Ordering keys are causing hotspots",
        "explanation": "If using ordering keys, high throughput on a single key can limit scalability (1MB/s limit per key). Slow subscribers cause increased backlog.",
        "frequency_score": 7
    },
    {
        "id": 134,
        "topic": "Cloud Spanner",
        "companies": [
            "Google",
            "Uber",
            "Pokemon GO"
        ],
        "question": "You are designing a global banking ledger. You require strong consistency and 99.999% availability. Which database service should you choose? ",
        "options": [
            "Cloud Spanner",
            "Cloud SQL",
            "Bigtable",
            "Firestore"
        ],
        "answer": "Cloud Spanner",
        "explanation": "Cloud Spanner is the only service providing global strong consistency and horizontal scalability with relational semantics (SQL).",
        "frequency_score": 8
    },
    {
        "id": 135,
        "topic": "Data Structures",
        "companies": [
            "Google",
            "Amazon",
            "Microsoft",
            "Facebook"
        ],
        "question": "You need to implement a look-up service that checks if a user ID exists in a set of 1 billion users with O(1) average time complexity. Which data structure is best? ",
        "options": [
            "Hash Table / HashSet",
            "Binary Search Tree",
            "Linked List",
            "Array"
        ],
        "answer": "Hash Table / HashSet",
        "explanation": "Hash Tables provide O(1) average case lookup. BST is O(log n).",
        "frequency_score": 8
    },
    {
        "id": 136,
        "topic": "Apache Kafka",
        "companies": [
            "Google",
            "LinkedIn"
        ],
        "question": "What happens if a Kafka Consumer Group has more consumers than partitions in the topic? ",
        "options": [
            "Some consumers will be idle",
            "Throughput increases linearly",
            "Kafka automatically creates more partitions",
            "The extra consumers duplicate the data"
        ],
        "answer": "Some consumers will be idle",
        "explanation": "A partition can be consumed by only one consumer within a group at a time. Extra consumers stay idle.",
        "frequency_score": 6
    },
    {
        "id": 137,
        "topic": "Pub/Sub",
        "companies": [
            "Google",
            "Uber"
        ],
        "question": "Your application publishes 1 million/sec messages to Pub/Sub. You observe increased end-to-end latency and growing backlog. What is the most likely cause?",
        "options": [
            "Subscribers are too slow (backlog)",
            "Publisher quota exceeded",
            "Message size too large",
            "Ordering keys are causing hotspots"
        ],
        "answer": "Subscribers are too slow (backlog)",
        "explanation": "If using ordering keys, high throughput on a single key can limit scalability (1MB/s limit per key). Slow subscribers cause increased backlog.",
        "frequency_score": 7
    },
    {
        "id": 138,
        "topic": "Apache Kafka",
        "companies": [
            "Google",
            "LinkedIn"
        ],
        "question": "What happens if a Kafka Consumer Group has more consumers than partitions in the topic? ",
        "options": [
            "Some consumers will be idle",
            "Throughput increases linearly",
            "Kafka automatically creates more partitions",
            "The extra consumers duplicate the data"
        ],
        "answer": "Some consumers will be idle",
        "explanation": "A partition can be consumed by only one consumer within a group at a time. Extra consumers stay idle.",
        "frequency_score": 6
    },
    {
        "id": 139,
        "topic": "Algorithms",
        "companies": [
            "Google",
            "Amazon",
            "Microsoft"
        ],
        "question": "What is the time complexity of a Bubble Sort algorithm in the worst case? ",
        "options": [
            "O(n log n)",
            "O(n^2)",
            "O(n)",
            "O(log n)"
        ],
        "answer": "O(n^2)",
        "explanation": "Merge Sort is O(n log n). Quick Sort is O(n^2) in worst case (though avg O(n log n)). Bubble Sort is O(n^2).",
        "frequency_score": 8
    },
    {
        "id": 140,
        "topic": "Apache Kafka",
        "companies": [
            "Google",
            "LinkedIn"
        ],
        "question": "What happens if a Kafka Consumer Group has more consumers than partitions in the topic? ",
        "options": [
            "Some consumers will be idle",
            "Throughput increases linearly",
            "Kafka automatically creates more partitions",
            "The extra consumers duplicate the data"
        ],
        "answer": "Some consumers will be idle",
        "explanation": "A partition can be consumed by only one consumer within a group at a time. Extra consumers stay idle.",
        "frequency_score": 6
    },
    {
        "id": 141,
        "topic": "Apache Kafka",
        "companies": [
            "Google",
            "LinkedIn",
            "Uber",
            "Netflix"
        ],
        "question": "You need to ensure strict ordering of messages in Kafka for a specific Transaction ID. How should you configure the producer?",
        "options": [
            "Use the Transaction ID as the partition key",
            "Use a single partition for the entire topic",
            "Enable idempotent producer",
            "Increase replication factor"
        ],
        "answer": "Use the Transaction ID as the partition key",
        "explanation": "Kafka guarantees ordering WITHIN a partition. Using the Entity ID as the key ensures all messages for that entity go to the same partition.",
        "frequency_score": 6
    },
    {
        "id": 142,
        "topic": "Algorithms",
        "companies": [
            "Google",
            "Amazon",
            "Microsoft"
        ],
        "question": "What is the time complexity of a Merge Sort algorithm in the worst case? ",
        "options": [
            "O(n log n)",
            "O(n^2)",
            "O(n)",
            "O(log n)"
        ],
        "answer": "O(n log n)",
        "explanation": "Merge Sort is O(n log n). Quick Sort is O(n^2) in worst case (though avg O(n log n)). Bubble Sort is O(n^2).",
        "frequency_score": 8
    },
    {
        "id": 143,
        "topic": "Cloud Spanner",
        "companies": [
            "Google",
            "Uber",
            "Pokemon GO"
        ],
        "question": "You are designing a global banking ledger. You require strong consistency and horizontal scalability. Which database service should you choose? ",
        "options": [
            "Cloud Spanner",
            "Cloud SQL",
            "Bigtable",
            "Firestore"
        ],
        "answer": "Cloud Spanner",
        "explanation": "Cloud Spanner is the only service providing global strong consistency and horizontal scalability with relational semantics (SQL).",
        "frequency_score": 8
    },
    {
        "id": 144,
        "topic": "Apache Spark",
        "companies": [
            "Google",
            "Databricks",
            "Amazon"
        ],
        "question": "In Spark, what is the difference between a Transformation and an Action? ",
        "options": [
            "Transformations are lazy, Actions match strict execution",
            "Actions are lazy, Transformations trigger execution",
            "They are the same",
            "Transformations save to disk, Actions read from disk"
        ],
        "answer": "Transformations are lazy, Actions match strict execution",
        "explanation": "Transformations (like map, filter) build the DAG but do not execute. Actions (like count, collect, save) trigger the actual computation.",
        "frequency_score": 6
    },
    {
        "id": 145,
        "topic": "Apache Spark",
        "companies": [
            "Google",
            "Databricks",
            "Facebook",
            "Netflix"
        ],
        "question": "You are optimizing a Spark job that is suffering from data skew. One task takes 10x longer than others during a wide transformation. Which technique is most effective? ",
        "options": [
            "Salting the key",
            "Increasing the number of executors",
            "Using a larger instance type",
            "Broadcasting the large table"
        ],
        "answer": "Salting the key",
        "explanation": "Salting adds a random prefix to the skewed key to distribute it. Broadcasting is best for Skewed Joins where one table is small.",
        "frequency_score": 6
    },
    {
        "id": 146,
        "topic": "Dataflow",
        "companies": [
            "Google",
            "Spotify",
            "New York Times"
        ],
        "question": "You are building a streaming pipeline to process server logs. You need to handle rolling averages every minute for the last hour. What windowing strategy is appropriate? ",
        "options": [
            "Fixed Windows",
            "Sliding Windows",
            "Session Windows",
            "Global Windows"
        ],
        "answer": "Sliding Windows",
        "explanation": "Session windows gap-fill based on activity. Sliding windows overlap (e.g. every 5 min show last 1 hour). Fixed windows are tumbling.",
        "frequency_score": 9
    },
    {
        "id": 147,
        "topic": "Algorithms",
        "companies": [
            "Google",
            "Amazon",
            "Microsoft"
        ],
        "question": "What is the time complexity of a Merge Sort algorithm in the worst case? ",
        "options": [
            "O(n log n)",
            "O(n^2)",
            "O(n)",
            "O(log n)"
        ],
        "answer": "O(n log n)",
        "explanation": "Merge Sort is O(n log n). Quick Sort is O(n^2) in worst case (though avg O(n log n)). Bubble Sort is O(n^2).",
        "frequency_score": 8
    },
    {
        "id": 148,
        "topic": "BigQuery",
        "companies": [
            "Google",
            "Spotify",
            "Twitter"
        ],
        "question": "You need to store 2 PB of transaction records data in BigQuery. The data is accessed rarely (every 6 months). Which storage class fits best to minimize costs?",
        "options": [
            "Active Storage",
            "Long-term Storage",
            "Nearline Storage",
            "Coldline Storage"
        ],
        "answer": "Long-term Storage",
        "explanation": "BigQuery Long-term storage applies automatically after 90 days of no modification, reducing price by ~50%.",
        "frequency_score": 10
    },
    {
        "id": 149,
        "topic": "Cloud Storage",
        "companies": [
            "Google",
            "Snapchat"
        ],
        "question": "You are designing a storage solution for regulatory archives. The requirement is access once a month. What storage class should you use?",
        "options": [
            "Standard",
            "Nearline",
            "Coldline",
            "Archive"
        ],
        "answer": "Nearline",
        "explanation": "Standard for hot data. Nearline < 1/month. Coldline < 1/quarter. Archive < 1/year.",
        "frequency_score": 6
    },
    {
        "id": 150,
        "topic": "BigQuery",
        "companies": [
            "Google",
            "Spotify",
            "Twitter"
        ],
        "question": "You need to store 1 PB of transaction records data in BigQuery. The data is accessed daily. Which storage class fits best to minimize costs?",
        "options": [
            "Active Storage",
            "Long-term Storage",
            "Nearline Storage",
            "Coldline Storage"
        ],
        "answer": "Active Storage",
        "explanation": "BigQuery Long-term storage applies automatically after 90 days of no modification, reducing price by ~50%.",
        "frequency_score": 10
    },
    {
        "id": 151,
        "topic": "Apache Spark",
        "companies": [
            "Google",
            "Databricks",
            "Facebook",
            "Netflix"
        ],
        "question": "You are optimizing a Spark job that is suffering from data skew. You are joining a large skewed table with a small reference table. Which technique is most effective? ",
        "options": [
            "Salting the key",
            "Increasing the number of executors",
            "Using a larger instance type",
            "Broadcasting the large table"
        ],
        "answer": "Salting the key",
        "explanation": "Salting adds a random prefix to the skewed key to distribute it. Broadcasting is best for Skewed Joins where one table is small.",
        "frequency_score": 6
    },
    {
        "id": 152,
        "topic": "Data Structures",
        "companies": [
            "Google",
            "Amazon",
            "Microsoft",
            "Facebook"
        ],
        "question": "You need to implement a look-up service that checks if a user ID exists in a set of 1 billion users with O(1) average time complexity. Which data structure is best? ",
        "options": [
            "Hash Table / HashSet",
            "Binary Search Tree",
            "Linked List",
            "Array"
        ],
        "answer": "Hash Table / HashSet",
        "explanation": "Hash Tables provide O(1) average case lookup. BST is O(log n).",
        "frequency_score": 8
    },
    {
        "id": 153,
        "topic": "Cloud Spanner",
        "companies": [
            "Google",
            "Uber",
            "Pokemon GO"
        ],
        "question": "You are designing a global banking ledger. You require strong consistency and horizontal scalability. Which database service should you choose? ",
        "options": [
            "Cloud Spanner",
            "Cloud SQL",
            "Bigtable",
            "Firestore"
        ],
        "answer": "Cloud Spanner",
        "explanation": "Cloud Spanner is the only service providing global strong consistency and horizontal scalability with relational semantics (SQL).",
        "frequency_score": 8
    },
    {
        "id": 154,
        "topic": "IAM",
        "companies": [
            "Google"
        ],
        "question": "A developer needs to upload files to a bucket in a production project. Following the principle of least privilege, which role should you grant? ",
        "options": [
            "Viewer",
            "Editor",
            "Owner",
            "Storage Object Creator"
        ],
        "answer": "Storage Object Creator",
        "explanation": "Always prefer predefined specific roles (like BigQuery Data Viewer, Storage Object Admin) over basic roles (Viewer/Editor/Owner) to ensure least privilege.",
        "frequency_score": 9
    },
    {
        "id": 155,
        "topic": "Bigtable",
        "companies": [
            "Google",
            "Spotify"
        ],
        "question": "You are designing a Bigtable schema for social media posts. Queries will primarily be retrieve latest events for a specific entity. Which row key design is optimal? ",
        "options": [
            "UserID#Date",
            "Date#UserID",
            "ReverseTimestamp#UserID",
            "Random#UserID"
        ],
        "answer": "UserID#Date",
        "explanation": "Avoid starting with timestamp to prevent hotspots. Use EntityID first for entity-lookup queries. Use ReverseTimestamp for 'latest items' queries globally.",
        "frequency_score": 7
    },
    {
        "id": 156,
        "topic": "IAM",
        "companies": [
            "Google"
        ],
        "question": "A developer needs to view BigQuery datasets in a production project. Following the principle of least privilege, which role should you grant? ",
        "options": [
            "Viewer",
            "Editor",
            "Owner",
            "Cloud Functions Developer"
        ],
        "answer": "Cloud Functions Developer",
        "explanation": "Always prefer predefined specific roles (like BigQuery Data Viewer, Storage Object Admin) over basic roles (Viewer/Editor/Owner) to ensure least privilege.",
        "frequency_score": 9
    },
    {
        "id": 157,
        "topic": "Cloud Storage",
        "companies": [
            "Google",
            "Snapchat"
        ],
        "question": "You are designing a storage solution for disaster recovery backups. The requirement is access once a quarter. What storage class should you use? ",
        "options": [
            "Standard",
            "Nearline",
            "Coldline",
            "Archive"
        ],
        "answer": "Coldline",
        "explanation": "Standard for hot data. Nearline < 1/month. Coldline < 1/quarter. Archive < 1/year.",
        "frequency_score": 6
    },
    {
        "id": 158,
        "topic": "Dataflow",
        "companies": [
            "Google",
            "Spotify",
            "New York Times"
        ],
        "question": "You are building a streaming pipeline to process user clickstreams. You need to handle periods of user activity separated by gaps. What windowing strategy is appropriate? ",
        "options": [
            "Fixed Windows",
            "Sliding Windows",
            "Session Windows",
            "Global Windows"
        ],
        "answer": "Session Windows",
        "explanation": "Session windows gap-fill based on activity. Sliding windows overlap (e.g. every 5 min show last 1 hour). Fixed windows are tumbling.",
        "frequency_score": 9
    },
    {
        "id": 159,
        "topic": "Apache Spark",
        "companies": [
            "Google",
            "Databricks",
            "Amazon"
        ],
        "question": "In Spark, what is the difference between a Transformation and an Action? ",
        "options": [
            "Transformations are lazy, Actions match strict execution",
            "Actions are lazy, Transformations trigger execution",
            "They are the same",
            "Transformations save to disk, Actions read from disk"
        ],
        "answer": "Transformations are lazy, Actions match strict execution",
        "explanation": "Transformations (like map, filter) build the DAG but do not execute. Actions (like count, collect, save) trigger the actual computation.",
        "frequency_score": 6
    },
    {
        "id": 160,
        "topic": "Dataflow",
        "companies": [
            "Google",
            "Spotify",
            "New York Times"
        ],
        "question": "You are building a streaming pipeline to process user clickstreams. You need to handle hourly reporting. What windowing strategy is appropriate? ",
        "options": [
            "Fixed Windows",
            "Sliding Windows",
            "Session Windows",
            "Global Windows"
        ],
        "answer": "Fixed Windows",
        "explanation": "Session windows gap-fill based on activity. Sliding windows overlap (e.g. every 5 min show last 1 hour). Fixed windows are tumbling.",
        "frequency_score": 9
    },
    {
        "id": 161,
        "topic": "Apache Kafka",
        "companies": [
            "Google",
            "LinkedIn",
            "Uber",
            "Netflix"
        ],
        "question": "You need to ensure strict ordering of messages in Kafka for a specific User ID. How should you configure the producer?",
        "options": [
            "Use the User ID as the partition key",
            "Use a single partition for the entire topic",
            "Enable idempotent producer",
            "Increase replication factor"
        ],
        "answer": "Use the User ID as the partition key",
        "explanation": "Kafka guarantees ordering WITHIN a partition. Using the Entity ID as the key ensures all messages for that entity go to the same partition.",
        "frequency_score": 6
    },
    {
        "id": 162,
        "topic": "Bigtable",
        "companies": [
            "Google",
            "Spotify"
        ],
        "question": "You are designing a Bigtable schema for social media posts. Queries will primarily be retrieve latest events for a specific entity. Which row key design is optimal? ",
        "options": [
            "SensorID#Timestamp",
            "Timestamp#SensorID",
            "ReverseTimestamp#SensorID",
            "Random#SensorID"
        ],
        "answer": "SensorID#Timestamp",
        "explanation": "Avoid starting with timestamp to prevent hotspots. Use EntityID first for entity-lookup queries. Use ReverseTimestamp for 'latest items' queries globally.",
        "frequency_score": 7
    },
    {
        "id": 163,
        "topic": "Apache Kafka",
        "companies": [
            "Google",
            "LinkedIn"
        ],
        "question": "What happens if a Kafka Consumer Group has more consumers than partitions in the topic? ",
        "options": [
            "Some consumers will be idle",
            "Throughput increases linearly",
            "Kafka automatically creates more partitions",
            "The extra consumers duplicate the data"
        ],
        "answer": "Some consumers will be idle",
        "explanation": "A partition can be consumed by only one consumer within a group at a time. Extra consumers stay idle.",
        "frequency_score": 6
    },
    {
        "id": 164,
        "topic": "Apache Spark",
        "companies": [
            "Google",
            "Databricks",
            "Facebook",
            "Netflix"
        ],
        "question": "You are optimizing a Spark job that is suffering from data skew. You are joining a large skewed table with a small reference table. Which technique is most effective? ",
        "options": [
            "Salting the key",
            "Increasing the number of executors",
            "Using a larger instance type",
            "Broadcasting the large table"
        ],
        "answer": "Salting the key",
        "explanation": "Salting adds a random prefix to the skewed key to distribute it. Broadcasting is best for Skewed Joins where one table is small.",
        "frequency_score": 6
    },
    {
        "id": 165,
        "topic": "Pub/Sub",
        "companies": [
            "Google",
            "Uber"
        ],
        "question": "Your application publishes 1 million/sec messages to Pub/Sub. You observe throughput limits on specific keys. What is the most likely cause? ",
        "options": [
            "Subscribers are too slow (backlog)",
            "Publisher quota exceeded",
            "Message size too large",
            "Ordering keys are causing hotspots"
        ],
        "answer": "Ordering keys are causing hotspots",
        "explanation": "If using ordering keys, high throughput on a single key can limit scalability (1MB/s limit per key). Slow subscribers cause increased backlog.",
        "frequency_score": 7
    },
    {
        "id": 166,
        "topic": "IAM",
        "companies": [
            "Google"
        ],
        "question": "A developer needs to view BigQuery datasets in a production project. Following the principle of least privilege, which role should you grant? ",
        "options": [
            "Viewer",
            "Editor",
            "Owner",
            "BigQuery Data Viewer"
        ],
        "answer": "BigQuery Data Viewer",
        "explanation": "Always prefer predefined specific roles (like BigQuery Data Viewer, Storage Object Admin) over basic roles (Viewer/Editor/Owner) to ensure least privilege.",
        "frequency_score": 9
    },
    {
        "id": 167,
        "topic": "Apache Kafka",
        "companies": [
            "Google",
            "LinkedIn",
            "Uber",
            "Netflix"
        ],
        "question": "You need to ensure strict ordering of messages in Kafka for a specific Device ID. How should you configure the producer? ",
        "options": [
            "Use the Device ID as the partition key",
            "Use a single partition for the entire topic",
            "Enable idempotent producer",
            "Increase replication factor"
        ],
        "answer": "Use the Device ID as the partition key",
        "explanation": "Kafka guarantees ordering WITHIN a partition. Using the Entity ID as the key ensures all messages for that entity go to the same partition.",
        "frequency_score": 6
    },
    {
        "id": 168,
        "topic": "Apache Kafka",
        "companies": [
            "Google",
            "LinkedIn"
        ],
        "question": "What happens if a Kafka Consumer Group has more consumers than partitions in the topic? ",
        "options": [
            "Some consumers will be idle",
            "Throughput increases linearly",
            "Kafka automatically creates more partitions",
            "The extra consumers duplicate the data"
        ],
        "answer": "Some consumers will be idle",
        "explanation": "A partition can be consumed by only one consumer within a group at a time. Extra consumers stay idle.",
        "frequency_score": 6
    },
    {
        "id": 169,
        "topic": "Pub/Sub",
        "companies": [
            "Google",
            "Uber"
        ],
        "question": "Your application publishes 1 million/sec messages to Pub/Sub. You observe throughput limits on specific keys. What is the most likely cause? ",
        "options": [
            "Subscribers are too slow (backlog)",
            "Publisher quota exceeded",
            "Message size too large",
            "Ordering keys are causing hotspots"
        ],
        "answer": "Ordering keys are causing hotspots",
        "explanation": "If using ordering keys, high throughput on a single key can limit scalability (1MB/s limit per key). Slow subscribers cause increased backlog.",
        "frequency_score": 7
    },
    {
        "id": 170,
        "topic": "Apache Spark",
        "companies": [
            "Google",
            "Databricks",
            "Facebook",
            "Netflix"
        ],
        "question": "You are optimizing a Spark job that is suffering from data skew. One task takes 10x longer than others during a wide transformation. Which technique is most effective? ",
        "options": [
            "Salting the key",
            "Increasing the number of executors",
            "Using a larger instance type",
            "Broadcasting the large table"
        ],
        "answer": "Salting the key",
        "explanation": "Salting adds a random prefix to the skewed key to distribute it. Broadcasting is best for Skewed Joins where one table is small.",
        "frequency_score": 6
    },
    {
        "id": 171,
        "topic": "Apache Spark",
        "companies": [
            "Google",
            "Databricks",
            "Facebook",
            "Netflix"
        ],
        "question": "You are optimizing a Spark job that is suffering from data skew. One task takes 10x longer than others during a wide transformation. Which technique is most effective? ",
        "options": [
            "Salting the key",
            "Increasing the number of executors",
            "Using a larger instance type",
            "Broadcasting the large table"
        ],
        "answer": "Salting the key",
        "explanation": "Salting adds a random prefix to the skewed key to distribute it. Broadcasting is best for Skewed Joins where one table is small.",
        "frequency_score": 6
    },
    {
        "id": 172,
        "topic": "Dataflow",
        "companies": [
            "Google",
            "Spotify",
            "New York Times"
        ],
        "question": "You are building a streaming pipeline to process user clickstreams. You need to handle periods of user activity separated by gaps. What windowing strategy is appropriate? ",
        "options": [
            "Fixed Windows",
            "Sliding Windows",
            "Session Windows",
            "Global Windows"
        ],
        "answer": "Session Windows",
        "explanation": "Session windows gap-fill based on activity. Sliding windows overlap (e.g. every 5 min show last 1 hour). Fixed windows are tumbling.",
        "frequency_score": 9
    },
    {
        "id": 173,
        "topic": "Dataflow",
        "companies": [
            "Google",
            "Spotify",
            "New York Times"
        ],
        "question": "You are building a streaming pipeline to process server logs. You need to handle hourly reporting. What windowing strategy is appropriate? ",
        "options": [
            "Fixed Windows",
            "Sliding Windows",
            "Session Windows",
            "Global Windows"
        ],
        "answer": "Fixed Windows",
        "explanation": "Session windows gap-fill based on activity. Sliding windows overlap (e.g. every 5 min show last 1 hour). Fixed windows are tumbling.",
        "frequency_score": 9
    },
    {
        "id": 174,
        "topic": "Data Structures",
        "companies": [
            "Google",
            "Amazon",
            "Microsoft",
            "Facebook"
        ],
        "question": "You need to implement a look-up service that checks if a user ID exists in a set of 1 billion users with O(1) average time complexity. Which data structure is best? ",
        "options": [
            "Hash Table / HashSet",
            "Binary Search Tree",
            "Linked List",
            "Array"
        ],
        "answer": "Hash Table / HashSet",
        "explanation": "Hash Tables provide O(1) average case lookup. BST is O(log n).",
        "frequency_score": 8
    },
    {
        "id": 175,
        "topic": "Apache Kafka",
        "companies": [
            "Google",
            "LinkedIn",
            "Uber",
            "Netflix"
        ],
        "question": "You need to ensure strict ordering of messages in Kafka for a specific Transaction ID. How should you configure the producer? ",
        "options": [
            "Use the Transaction ID as the partition key",
            "Use a single partition for the entire topic",
            "Enable idempotent producer",
            "Increase replication factor"
        ],
        "answer": "Use the Transaction ID as the partition key",
        "explanation": "Kafka guarantees ordering WITHIN a partition. Using the Entity ID as the key ensures all messages for that entity go to the same partition.",
        "frequency_score": 6
    },
    {
        "id": 176,
        "topic": "Bigtable",
        "companies": [
            "Google",
            "Spotify"
        ],
        "question": "You are designing a Bigtable schema for financial transactions. Queries will primarily be retrieve most recent events globally. Which row key design is optimal? ",
        "options": [
            "DeviceID#Date",
            "Date#DeviceID",
            "ReverseTimestamp#DeviceID",
            "Random#DeviceID"
        ],
        "answer": "ReverseTimestamp#DeviceID",
        "explanation": "Avoid starting with timestamp to prevent hotspots. Use EntityID first for entity-lookup queries. Use ReverseTimestamp for 'latest items' queries globally.",
        "frequency_score": 7
    },
    {
        "id": 177,
        "topic": "Cloud Storage",
        "companies": [
            "Google",
            "Snapchat"
        ],
        "question": "You are designing a storage solution for regulatory archives. The requirement is access once a year. What storage class should you use?",
        "options": [
            "Standard",
            "Nearline",
            "Coldline",
            "Archive"
        ],
        "answer": "Archive",
        "explanation": "Standard for hot data. Nearline < 1/month. Coldline < 1/quarter. Archive < 1/year.",
        "frequency_score": 6
    },
    {
        "id": 178,
        "topic": "Pub/Sub",
        "companies": [
            "Google",
            "Uber"
        ],
        "question": "Your application publishes 1 million/sec messages to Pub/Sub. You observe increased end-to-end latency and growing backlog. What is the most likely cause? ",
        "options": [
            "Subscribers are too slow (backlog)",
            "Publisher quota exceeded",
            "Message size too large",
            "Ordering keys are causing hotspots"
        ],
        "answer": "Subscribers are too slow (backlog)",
        "explanation": "If using ordering keys, high throughput on a single key can limit scalability (1MB/s limit per key). Slow subscribers cause increased backlog.",
        "frequency_score": 7
    },
    {
        "id": 179,
        "topic": "Dataflow",
        "companies": [
            "Google",
            "Spotify",
            "New York Times"
        ],
        "question": "You are building a streaming pipeline to process server logs. You need to handle periods of user activity separated by gaps. What windowing strategy is appropriate? ",
        "options": [
            "Fixed Windows",
            "Sliding Windows",
            "Session Windows",
            "Global Windows"
        ],
        "answer": "Session Windows",
        "explanation": "Session windows gap-fill based on activity. Sliding windows overlap (e.g. every 5 min show last 1 hour). Fixed windows are tumbling.",
        "frequency_score": 9
    },
    {
        "id": 180,
        "topic": "Apache Spark",
        "companies": [
            "Google",
            "Databricks",
            "Amazon"
        ],
        "question": "In Spark, what is the difference between a Transformation and an Action? ",
        "options": [
            "Transformations are lazy, Actions match strict execution",
            "Actions are lazy, Transformations trigger execution",
            "They are the same",
            "Transformations save to disk, Actions read from disk"
        ],
        "answer": "Transformations are lazy, Actions match strict execution",
        "explanation": "Transformations (like map, filter) build the DAG but do not execute. Actions (like count, collect, save) trigger the actual computation.",
        "frequency_score": 6
    },
    {
        "id": 181,
        "topic": "Bigtable",
        "companies": [
            "Google",
            "Spotify"
        ],
        "question": "You are designing a Bigtable schema for IoT events. Queries will primarily be retrieve latest events for a specific entity. Which row key design is optimal? ",
        "options": [
            "DeviceID#Date",
            "Date#DeviceID",
            "ReverseTimestamp#DeviceID",
            "Random#DeviceID"
        ],
        "answer": "DeviceID#Date",
        "explanation": "Avoid starting with timestamp to prevent hotspots. Use EntityID first for entity-lookup queries. Use ReverseTimestamp for 'latest items' queries globally.",
        "frequency_score": 7
    },
    {
        "id": 182,
        "topic": "Algorithms",
        "companies": [
            "Google",
            "Amazon",
            "Microsoft"
        ],
        "question": "What is the time complexity of a Merge Sort algorithm in the worst case? ",
        "options": [
            "O(n log n)",
            "O(n^2)",
            "O(n)",
            "O(log n)"
        ],
        "answer": "O(n log n)",
        "explanation": "Merge Sort is O(n log n). Quick Sort is O(n^2) in worst case (though avg O(n log n)). Bubble Sort is O(n^2).",
        "frequency_score": 8
    },
    {
        "id": 183,
        "topic": "Cloud Storage",
        "companies": [
            "Google",
            "Snapchat"
        ],
        "question": "You are designing a storage solution for daily analytics content. The requirement is access once a quarter. What storage class should you use? ",
        "options": [
            "Standard",
            "Nearline",
            "Coldline",
            "Archive"
        ],
        "answer": "Coldline",
        "explanation": "Standard for hot data. Nearline < 1/month. Coldline < 1/quarter. Archive < 1/year.",
        "frequency_score": 6
    },
    {
        "id": 184,
        "topic": "Cloud Spanner",
        "companies": [
            "Google",
            "Uber",
            "Pokemon GO"
        ],
        "question": "You are designing a global banking ledger. You require strong consistency and 99.999% availability. Which database service should you choose? ",
        "options": [
            "Cloud Spanner",
            "Cloud SQL",
            "Bigtable",
            "Firestore"
        ],
        "answer": "Cloud Spanner",
        "explanation": "Cloud Spanner is the only service providing global strong consistency and horizontal scalability with relational semantics (SQL).",
        "frequency_score": 8
    },
    {
        "id": 185,
        "topic": "Algorithms",
        "companies": [
            "Google",
            "Amazon",
            "Microsoft"
        ],
        "question": "What is the time complexity of a Bubble Sort algorithm in the worst case? ",
        "options": [
            "O(n log n)",
            "O(n^2)",
            "O(n)",
            "O(log n)"
        ],
        "answer": "O(n^2)",
        "explanation": "Merge Sort is O(n log n). Quick Sort is O(n^2) in worst case (though avg O(n log n)). Bubble Sort is O(n^2).",
        "frequency_score": 8
    },
    {
        "id": 186,
        "topic": "Bigtable",
        "companies": [
            "Google",
            "Spotify"
        ],
        "question": "You are designing a Bigtable schema for social media posts. Queries will primarily be retrieve most recent events globally. Which row key design is optimal? ",
        "options": [
            "SensorID#Date",
            "Date#SensorID",
            "ReverseTimestamp#SensorID",
            "Random#SensorID"
        ],
        "answer": "ReverseTimestamp#SensorID",
        "explanation": "Avoid starting with timestamp to prevent hotspots. Use EntityID first for entity-lookup queries. Use ReverseTimestamp for 'latest items' queries globally.",
        "frequency_score": 7
    },
    {
        "id": 187,
        "topic": "Dataflow",
        "companies": [
            "Google",
            "Spotify",
            "New York Times"
        ],
        "question": "You are building a streaming pipeline to process IoT temperature sensors. You need to handle hourly reporting. What windowing strategy is appropriate? ",
        "options": [
            "Fixed Windows",
            "Sliding Windows",
            "Session Windows",
            "Global Windows"
        ],
        "answer": "Fixed Windows",
        "explanation": "Session windows gap-fill based on activity. Sliding windows overlap (e.g. every 5 min show last 1 hour). Fixed windows are tumbling.",
        "frequency_score": 9
    },
    {
        "id": 188,
        "topic": "Cloud Spanner",
        "companies": [
            "Google",
            "Uber",
            "Pokemon GO"
        ],
        "question": "You are designing a global banking ledger. You require strong consistency and 99.999% availability. Which database service should you choose? ",
        "options": [
            "Cloud Spanner",
            "Cloud SQL",
            "Bigtable",
            "Firestore"
        ],
        "answer": "Cloud Spanner",
        "explanation": "Cloud Spanner is the only service providing global strong consistency and horizontal scalability with relational semantics (SQL).",
        "frequency_score": 8
    },
    {
        "id": 189,
        "topic": "BigQuery",
        "companies": [
            "Google",
            "Spotify",
            "Twitter"
        ],
        "question": "You need to store 1 PB of clickstream data data in BigQuery. The data is accessed continuously. Which storage class fits best to minimize costs?",
        "options": [
            "Active Storage",
            "Long-term Storage",
            "Nearline Storage",
            "Coldline Storage"
        ],
        "answer": "Active Storage",
        "explanation": "BigQuery Long-term storage applies automatically after 90 days of no modification, reducing price by ~50%.",
        "frequency_score": 10
    },
    {
        "id": 190,
        "topic": "Pub/Sub",
        "companies": [
            "Google",
            "Uber"
        ],
        "question": "Your application publishes high throughput messages to Pub/Sub. You observe increased end-to-end latency and growing backlog. What is the most likely cause? ",
        "options": [
            "Subscribers are too slow (backlog)",
            "Publisher quota exceeded",
            "Message size too large",
            "Ordering keys are causing hotspots"
        ],
        "answer": "Subscribers are too slow (backlog)",
        "explanation": "If using ordering keys, high throughput on a single key can limit scalability (1MB/s limit per key). Slow subscribers cause increased backlog.",
        "frequency_score": 7
    },
    {
        "id": 191,
        "topic": "Apache Kafka",
        "companies": [
            "Google",
            "LinkedIn",
            "Uber",
            "Netflix"
        ],
        "question": "You need to ensure strict ordering of messages in Kafka for a specific User ID. How should you configure the producer? ",
        "options": [
            "Use the User ID as the partition key",
            "Use a single partition for the entire topic",
            "Enable idempotent producer",
            "Increase replication factor"
        ],
        "answer": "Use the User ID as the partition key",
        "explanation": "Kafka guarantees ordering WITHIN a partition. Using the Entity ID as the key ensures all messages for that entity go to the same partition.",
        "frequency_score": 6
    },
    {
        "id": 192,
        "topic": "Apache Spark",
        "companies": [
            "Google",
            "Databricks",
            "Amazon"
        ],
        "question": "In Spark, what is the difference between a Transformation and an Action? ",
        "options": [
            "Transformations are lazy, Actions match strict execution",
            "Actions are lazy, Transformations trigger execution",
            "They are the same",
            "Transformations save to disk, Actions read from disk"
        ],
        "answer": "Transformations are lazy, Actions match strict execution",
        "explanation": "Transformations (like map, filter) build the DAG but do not execute. Actions (like count, collect, save) trigger the actual computation.",
        "frequency_score": 6
    },
    {
        "id": 193,
        "topic": "Dataflow",
        "companies": [
            "Google",
            "Spotify",
            "New York Times"
        ],
        "question": "You are building a streaming pipeline to process server logs. You need to handle rolling averages every minute for the last hour. What windowing strategy is appropriate? ",
        "options": [
            "Fixed Windows",
            "Sliding Windows",
            "Session Windows",
            "Global Windows"
        ],
        "answer": "Sliding Windows",
        "explanation": "Session windows gap-fill based on activity. Sliding windows overlap (e.g. every 5 min show last 1 hour). Fixed windows are tumbling.",
        "frequency_score": 9
    },
    {
        "id": 194,
        "topic": "Apache Kafka",
        "companies": [
            "Google",
            "LinkedIn"
        ],
        "question": "What happens if a Kafka Consumer Group has more consumers than partitions in the topic? ",
        "options": [
            "Some consumers will be idle",
            "Throughput increases linearly",
            "Kafka automatically creates more partitions",
            "The extra consumers duplicate the data"
        ],
        "answer": "Some consumers will be idle",
        "explanation": "A partition can be consumed by only one consumer within a group at a time. Extra consumers stay idle.",
        "frequency_score": 6
    },
    {
        "id": 195,
        "topic": "Algorithms",
        "companies": [
            "Google",
            "Amazon",
            "Microsoft"
        ],
        "question": "What is the time complexity of a Bubble Sort algorithm in the worst case? ",
        "options": [
            "O(n log n)",
            "O(n^2)",
            "O(n)",
            "O(log n)"
        ],
        "answer": "O(n^2)",
        "explanation": "Merge Sort is O(n log n). Quick Sort is O(n^2) in worst case (though avg O(n log n)). Bubble Sort is O(n^2).",
        "frequency_score": 8
    },
    {
        "id": 196,
        "topic": "Apache Kafka",
        "companies": [
            "Google",
            "LinkedIn"
        ],
        "question": "What happens if a Kafka Consumer Group has more consumers than partitions in the topic? ",
        "options": [
            "Some consumers will be idle",
            "Throughput increases linearly",
            "Kafka automatically creates more partitions",
            "The extra consumers duplicate the data"
        ],
        "answer": "Some consumers will be idle",
        "explanation": "A partition can be consumed by only one consumer within a group at a time. Extra consumers stay idle.",
        "frequency_score": 6
    },
    {
        "id": 197,
        "topic": "Cloud Storage",
        "companies": [
            "Google",
            "Snapchat"
        ],
        "question": "You are designing a storage solution for daily analytics content. The requirement is access once a year. What storage class should you use? ",
        "options": [
            "Standard",
            "Nearline",
            "Coldline",
            "Archive"
        ],
        "answer": "Archive",
        "explanation": "Standard for hot data. Nearline < 1/month. Coldline < 1/quarter. Archive < 1/year.",
        "frequency_score": 6
    },
    {
        "id": 198,
        "topic": "Algorithms",
        "companies": [
            "Google",
            "Amazon",
            "Microsoft"
        ],
        "question": "What is the time complexity of a Merge Sort algorithm in the worst case? ",
        "options": [
            "O(n log n)",
            "O(n^2)",
            "O(n)",
            "O(log n)"
        ],
        "answer": "O(n log n)",
        "explanation": "Merge Sort is O(n log n). Quick Sort is O(n^2) in worst case (though avg O(n log n)). Bubble Sort is O(n^2).",
        "frequency_score": 8
    },
    {
        "id": 199,
        "topic": "Cloud Spanner",
        "companies": [
            "Google",
            "Uber",
            "Pokemon GO"
        ],
        "question": "You are designing a global banking ledger. You require strong consistency and horizontal scalability. Which database service should you choose? ",
        "options": [
            "Cloud Spanner",
            "Cloud SQL",
            "Bigtable",
            "Firestore"
        ],
        "answer": "Cloud Spanner",
        "explanation": "Cloud Spanner is the only service providing global strong consistency and horizontal scalability with relational semantics (SQL).",
        "frequency_score": 8
    },
    {
        "id": 200,
        "topic": "Pub/Sub",
        "companies": [
            "Google",
            "Uber"
        ],
        "question": "Your application publishes 1 million/sec messages to Pub/Sub. You observe increased end-to-end latency and growing backlog. What is the most likely cause? ",
        "options": [
            "Subscribers are too slow (backlog)",
            "Publisher quota exceeded",
            "Message size too large",
            "Ordering keys are causing hotspots"
        ],
        "answer": "Subscribers are too slow (backlog)",
        "explanation": "If using ordering keys, high throughput on a single key can limit scalability (1MB/s limit per key). Slow subscribers cause increased backlog.",
        "frequency_score": 7
    },
    {
        "id": 201,
        "topic": "Pub/Sub",
        "companies": [
            "Google",
            "Uber"
        ],
        "question": "Your application publishes high throughput messages to Pub/Sub. You observe throughput limits on specific keys. What is the most likely cause? ",
        "options": [
            "Subscribers are too slow (backlog)",
            "Publisher quota exceeded",
            "Message size too large",
            "Ordering keys are causing hotspots"
        ],
        "answer": "Ordering keys are causing hotspots",
        "explanation": "If using ordering keys, high throughput on a single key can limit scalability (1MB/s limit per key). Slow subscribers cause increased backlog.",
        "frequency_score": 7
    },
    {
        "id": 202,
        "topic": "Dataflow",
        "companies": [
            "Google",
            "Spotify",
            "New York Times"
        ],
        "question": "You are building a streaming pipeline to process IoT temperature sensors. You need to handle hourly reporting. What windowing strategy is appropriate? ",
        "options": [
            "Fixed Windows",
            "Sliding Windows",
            "Session Windows",
            "Global Windows"
        ],
        "answer": "Fixed Windows",
        "explanation": "Session windows gap-fill based on activity. Sliding windows overlap (e.g. every 5 min show last 1 hour). Fixed windows are tumbling.",
        "frequency_score": 9
    },
    {
        "id": 203,
        "topic": "Pub/Sub",
        "companies": [
            "Google",
            "Uber"
        ],
        "question": "Your application publishes high throughput messages to Pub/Sub. You observe throughput limits on specific keys. What is the most likely cause? ",
        "options": [
            "Subscribers are too slow (backlog)",
            "Publisher quota exceeded",
            "Message size too large",
            "Ordering keys are causing hotspots"
        ],
        "answer": "Ordering keys are causing hotspots",
        "explanation": "If using ordering keys, high throughput on a single key can limit scalability (1MB/s limit per key). Slow subscribers cause increased backlog.",
        "frequency_score": 7
    },
    {
        "id": 204,
        "topic": "Apache Spark",
        "companies": [
            "Google",
            "Databricks",
            "Amazon"
        ],
        "question": "In Spark, what is the difference between a Transformation and an Action? ",
        "options": [
            "Transformations are lazy, Actions match strict execution",
            "Actions are lazy, Transformations trigger execution",
            "They are the same",
            "Transformations save to disk, Actions read from disk"
        ],
        "answer": "Transformations are lazy, Actions match strict execution",
        "explanation": "Transformations (like map, filter) build the DAG but do not execute. Actions (like count, collect, save) trigger the actual computation.",
        "frequency_score": 6
    },
    {
        "id": 205,
        "topic": "Dataflow",
        "companies": [
            "Google",
            "Spotify",
            "New York Times"
        ],
        "question": "You are building a streaming pipeline to process IoT temperature sensors. You need to handle hourly reporting. What windowing strategy is appropriate? ",
        "options": [
            "Fixed Windows",
            "Sliding Windows",
            "Session Windows",
            "Global Windows"
        ],
        "answer": "Fixed Windows",
        "explanation": "Session windows gap-fill based on activity. Sliding windows overlap (e.g. every 5 min show last 1 hour). Fixed windows are tumbling.",
        "frequency_score": 9
    },
    {
        "id": 206,
        "topic": "Cloud Spanner",
        "companies": [
            "Google",
            "Uber",
            "Pokemon GO"
        ],
        "question": "You are designing a global banking ledger. You require strong consistency and 99.999% availability. Which database service should you choose? ",
        "options": [
            "Cloud Spanner",
            "Cloud SQL",
            "Bigtable",
            "Firestore"
        ],
        "answer": "Cloud Spanner",
        "explanation": "Cloud Spanner is the only service providing global strong consistency and horizontal scalability with relational semantics (SQL).",
        "frequency_score": 8
    },
    {
        "id": 207,
        "topic": "Dataflow",
        "companies": [
            "Google",
            "Spotify",
            "New York Times"
        ],
        "question": "You are building a streaming pipeline to process IoT temperature sensors. You need to handle rolling averages every minute for the last hour. What windowing strategy is appropriate? ",
        "options": [
            "Fixed Windows",
            "Sliding Windows",
            "Session Windows",
            "Global Windows"
        ],
        "answer": "Sliding Windows",
        "explanation": "Session windows gap-fill based on activity. Sliding windows overlap (e.g. every 5 min show last 1 hour). Fixed windows are tumbling.",
        "frequency_score": 9
    },
    {
        "id": 208,
        "topic": "BigQuery",
        "companies": [
            "Google",
            "Spotify",
            "Twitter"
        ],
        "question": "You need to store 2 PB of sensor metrics data in BigQuery. The data is accessed rarely (every 6 months). Which storage class fits best to minimize costs?",
        "options": [
            "Active Storage",
            "Long-term Storage",
            "Nearline Storage",
            "Coldline Storage"
        ],
        "answer": "Long-term Storage",
        "explanation": "BigQuery Long-term storage applies automatically after 90 days of no modification, reducing price by ~50%.",
        "frequency_score": 10
    },
    {
        "id": 209,
        "topic": "Cloud Spanner",
        "companies": [
            "Google",
            "Uber",
            "Pokemon GO"
        ],
        "question": "You are designing a global banking ledger. You require strong consistency and horizontal scalability. Which database service should you choose? ",
        "options": [
            "Cloud Spanner",
            "Cloud SQL",
            "Bigtable",
            "Firestore"
        ],
        "answer": "Cloud Spanner",
        "explanation": "Cloud Spanner is the only service providing global strong consistency and horizontal scalability with relational semantics (SQL).",
        "frequency_score": 8
    },
    {
        "id": 210,
        "topic": "BigQuery",
        "companies": [
            "Google",
            "Spotify",
            "Twitter"
        ],
        "question": "You need to store 50 TB of sensor metrics data in BigQuery. The data is accessed continuously. Which storage class fits best to minimize costs?",
        "options": [
            "Active Storage",
            "Long-term Storage",
            "Nearline Storage",
            "Coldline Storage"
        ],
        "answer": "Active Storage",
        "explanation": "BigQuery Long-term storage applies automatically after 90 days of no modification, reducing price by ~50%.",
        "frequency_score": 10
    },
    {
        "id": 211,
        "topic": "Pub/Sub",
        "companies": [
            "Google",
            "Uber"
        ],
        "question": "Your application publishes high throughput messages to Pub/Sub. You observe throughput limits on specific keys. What is the most likely cause? ",
        "options": [
            "Subscribers are too slow (backlog)",
            "Publisher quota exceeded",
            "Message size too large",
            "Ordering keys are causing hotspots"
        ],
        "answer": "Ordering keys are causing hotspots",
        "explanation": "If using ordering keys, high throughput on a single key can limit scalability (1MB/s limit per key). Slow subscribers cause increased backlog.",
        "frequency_score": 7
    },
    {
        "id": 212,
        "topic": "Apache Spark",
        "companies": [
            "Google",
            "Databricks",
            "Facebook",
            "Netflix"
        ],
        "question": "You are optimizing a Spark job that is suffering from data skew. You are joining a large skewed table with a small reference table. Which technique is most effective? ",
        "options": [
            "Salting the key",
            "Increasing the number of executors",
            "Using a larger instance type",
            "Broadcasting the large table"
        ],
        "answer": "Salting the key",
        "explanation": "Salting adds a random prefix to the skewed key to distribute it. Broadcasting is best for Skewed Joins where one table is small.",
        "frequency_score": 6
    },
    {
        "id": 213,
        "topic": "Bigtable",
        "companies": [
            "Google",
            "Spotify"
        ],
        "question": "You are designing a Bigtable schema for social media posts. Queries will primarily be retrieve latest events for a specific entity. Which row key design is optimal? ",
        "options": [
            "SensorID#Date",
            "Date#SensorID",
            "ReverseTimestamp#SensorID",
            "Random#SensorID"
        ],
        "answer": "SensorID#Date",
        "explanation": "Avoid starting with timestamp to prevent hotspots. Use EntityID first for entity-lookup queries. Use ReverseTimestamp for 'latest items' queries globally.",
        "frequency_score": 7
    },
    {
        "id": 214,
        "topic": "Apache Kafka",
        "companies": [
            "Google",
            "LinkedIn"
        ],
        "question": "What happens if a Kafka Consumer Group has more consumers than partitions in the topic? ",
        "options": [
            "Some consumers will be idle",
            "Throughput increases linearly",
            "Kafka automatically creates more partitions",
            "The extra consumers duplicate the data"
        ],
        "answer": "Some consumers will be idle",
        "explanation": "A partition can be consumed by only one consumer within a group at a time. Extra consumers stay idle.",
        "frequency_score": 6
    },
    {
        "id": 215,
        "topic": "Apache Kafka",
        "companies": [
            "Google",
            "LinkedIn",
            "Uber",
            "Netflix"
        ],
        "question": "You need to ensure strict ordering of messages in Kafka for a specific Transaction ID. How should you configure the producer? ",
        "options": [
            "Use the Transaction ID as the partition key",
            "Use a single partition for the entire topic",
            "Enable idempotent producer",
            "Increase replication factor"
        ],
        "answer": "Use the Transaction ID as the partition key",
        "explanation": "Kafka guarantees ordering WITHIN a partition. Using the Entity ID as the key ensures all messages for that entity go to the same partition.",
        "frequency_score": 6
    },
    {
        "id": 216,
        "topic": "Apache Spark",
        "companies": [
            "Google",
            "Databricks",
            "Amazon"
        ],
        "question": "In Spark, what is the difference between a Transformation and an Action? ",
        "options": [
            "Transformations are lazy, Actions match strict execution",
            "Actions are lazy, Transformations trigger execution",
            "They are the same",
            "Transformations save to disk, Actions read from disk"
        ],
        "answer": "Transformations are lazy, Actions match strict execution",
        "explanation": "Transformations (like map, filter) build the DAG but do not execute. Actions (like count, collect, save) trigger the actual computation.",
        "frequency_score": 6
    },
    {
        "id": 217,
        "topic": "Cloud Storage",
        "companies": [
            "Google",
            "Snapchat"
        ],
        "question": "You are designing a storage solution for regulatory archives. The requirement is access once a month. What storage class should you use? ",
        "options": [
            "Standard",
            "Nearline",
            "Coldline",
            "Archive"
        ],
        "answer": "Nearline",
        "explanation": "Standard for hot data. Nearline < 1/month. Coldline < 1/quarter. Archive < 1/year.",
        "frequency_score": 6
    },
    {
        "id": 218,
        "topic": "Dataflow",
        "companies": [
            "Google",
            "Spotify",
            "New York Times"
        ],
        "question": "You are building a streaming pipeline to process user clickstreams. You need to handle hourly reporting. What windowing strategy is appropriate? ",
        "options": [
            "Fixed Windows",
            "Sliding Windows",
            "Session Windows",
            "Global Windows"
        ],
        "answer": "Fixed Windows",
        "explanation": "Session windows gap-fill based on activity. Sliding windows overlap (e.g. every 5 min show last 1 hour). Fixed windows are tumbling.",
        "frequency_score": 9
    },
    {
        "id": 219,
        "topic": "Pub/Sub",
        "companies": [
            "Google",
            "Uber"
        ],
        "question": "Your application publishes high throughput messages to Pub/Sub. You observe throughput limits on specific keys. What is the most likely cause? ",
        "options": [
            "Subscribers are too slow (backlog)",
            "Publisher quota exceeded",
            "Message size too large",
            "Ordering keys are causing hotspots"
        ],
        "answer": "Ordering keys are causing hotspots",
        "explanation": "If using ordering keys, high throughput on a single key can limit scalability (1MB/s limit per key). Slow subscribers cause increased backlog.",
        "frequency_score": 7
    },
    {
        "id": 220,
        "topic": "Apache Kafka",
        "companies": [
            "Google",
            "LinkedIn",
            "Uber",
            "Netflix"
        ],
        "question": "You need to ensure strict ordering of messages in Kafka for a specific Device ID. How should you configure the producer? ",
        "options": [
            "Use the Device ID as the partition key",
            "Use a single partition for the entire topic",
            "Enable idempotent producer",
            "Increase replication factor"
        ],
        "answer": "Use the Device ID as the partition key",
        "explanation": "Kafka guarantees ordering WITHIN a partition. Using the Entity ID as the key ensures all messages for that entity go to the same partition.",
        "frequency_score": 6
    },
    {
        "id": 221,
        "topic": "Bigtable",
        "companies": [
            "Google",
            "Spotify"
        ],
        "question": "You are designing a Bigtable schema for financial transactions. Queries will primarily be retrieve latest events for a specific entity. Which row key design is optimal? ",
        "options": [
            "UserID#Timestamp",
            "Timestamp#UserID",
            "ReverseTimestamp#UserID",
            "Random#UserID"
        ],
        "answer": "UserID#Timestamp",
        "explanation": "Avoid starting with timestamp to prevent hotspots. Use EntityID first for entity-lookup queries. Use ReverseTimestamp for 'latest items' queries globally.",
        "frequency_score": 7
    },
    {
        "id": 222,
        "topic": "Pub/Sub",
        "companies": [
            "Google",
            "Uber"
        ],
        "question": "Your application publishes high throughput messages to Pub/Sub. You observe throughput limits on specific keys. What is the most likely cause? ",
        "options": [
            "Subscribers are too slow (backlog)",
            "Publisher quota exceeded",
            "Message size too large",
            "Ordering keys are causing hotspots"
        ],
        "answer": "Ordering keys are causing hotspots",
        "explanation": "If using ordering keys, high throughput on a single key can limit scalability (1MB/s limit per key). Slow subscribers cause increased backlog.",
        "frequency_score": 7
    },
    {
        "id": 223,
        "topic": "Apache Spark",
        "companies": [
            "Google",
            "Databricks",
            "Amazon"
        ],
        "question": "In Spark, what is the difference between a Transformation and an Action? ",
        "options": [
            "Transformations are lazy, Actions match strict execution",
            "Actions are lazy, Transformations trigger execution",
            "They are the same",
            "Transformations save to disk, Actions read from disk"
        ],
        "answer": "Transformations are lazy, Actions match strict execution",
        "explanation": "Transformations (like map, filter) build the DAG but do not execute. Actions (like count, collect, save) trigger the actual computation.",
        "frequency_score": 6
    },
    {
        "id": 224,
        "topic": "Apache Kafka",
        "companies": [
            "Google",
            "LinkedIn"
        ],
        "question": "What happens if a Kafka Consumer Group has more consumers than partitions in the topic? ",
        "options": [
            "Some consumers will be idle",
            "Throughput increases linearly",
            "Kafka automatically creates more partitions",
            "The extra consumers duplicate the data"
        ],
        "answer": "Some consumers will be idle",
        "explanation": "A partition can be consumed by only one consumer within a group at a time. Extra consumers stay idle.",
        "frequency_score": 6
    },
    {
        "id": 225,
        "topic": "Cloud Storage",
        "companies": [
            "Google",
            "Snapchat"
        ],
        "question": "You are designing a storage solution for regulatory archives. The requirement is high frequency access. What storage class should you use? ",
        "options": [
            "Standard",
            "Nearline",
            "Coldline",
            "Archive"
        ],
        "answer": "Standard",
        "explanation": "Standard for hot data. Nearline < 1/month. Coldline < 1/quarter. Archive < 1/year.",
        "frequency_score": 6
    },
    {
        "id": 226,
        "topic": "Bigtable",
        "companies": [
            "Google",
            "Spotify"
        ],
        "question": "You are designing a Bigtable schema for social media posts. Queries will primarily be retrieve most recent events globally. Which row key design is optimal? ",
        "options": [
            "UserID#Timestamp",
            "Timestamp#UserID",
            "ReverseTimestamp#UserID",
            "Random#UserID"
        ],
        "answer": "ReverseTimestamp#UserID",
        "explanation": "Avoid starting with timestamp to prevent hotspots. Use EntityID first for entity-lookup queries. Use ReverseTimestamp for 'latest items' queries globally.",
        "frequency_score": 7
    },
    {
        "id": 227,
        "topic": "Data Structures",
        "companies": [
            "Google",
            "Amazon",
            "Microsoft",
            "Facebook"
        ],
        "question": "You need to implement a look-up service that checks if a user ID exists in a set of 1 billion users with O(1) average time complexity. Which data structure is best? ",
        "options": [
            "Hash Table / HashSet",
            "Binary Search Tree",
            "Linked List",
            "Array"
        ],
        "answer": "Hash Table / HashSet",
        "explanation": "Hash Tables provide O(1) average case lookup. BST is O(log n).",
        "frequency_score": 8
    },
    {
        "id": 228,
        "topic": "Apache Kafka",
        "companies": [
            "Google",
            "LinkedIn"
        ],
        "question": "What happens if a Kafka Consumer Group has more consumers than partitions in the topic? ",
        "options": [
            "Some consumers will be idle",
            "Throughput increases linearly",
            "Kafka automatically creates more partitions",
            "The extra consumers duplicate the data"
        ],
        "answer": "Some consumers will be idle",
        "explanation": "A partition can be consumed by only one consumer within a group at a time. Extra consumers stay idle.",
        "frequency_score": 6
    },
    {
        "id": 229,
        "topic": "Apache Kafka",
        "companies": [
            "Google",
            "LinkedIn",
            "Uber",
            "Netflix"
        ],
        "question": "You need to ensure strict ordering of messages in Kafka for a specific Transaction ID. How should you configure the producer? ",
        "options": [
            "Use the Transaction ID as the partition key",
            "Use a single partition for the entire topic",
            "Enable idempotent producer",
            "Increase replication factor"
        ],
        "answer": "Use the Transaction ID as the partition key",
        "explanation": "Kafka guarantees ordering WITHIN a partition. Using the Entity ID as the key ensures all messages for that entity go to the same partition.",
        "frequency_score": 6
    },
    {
        "id": 230,
        "topic": "Apache Spark",
        "companies": [
            "Google",
            "Databricks",
            "Amazon"
        ],
        "question": "In Spark, what is the difference between a Transformation and an Action? ",
        "options": [
            "Transformations are lazy, Actions match strict execution",
            "Actions are lazy, Transformations trigger execution",
            "They are the same",
            "Transformations save to disk, Actions read from disk"
        ],
        "answer": "Transformations are lazy, Actions match strict execution",
        "explanation": "Transformations (like map, filter) build the DAG but do not execute. Actions (like count, collect, save) trigger the actual computation.",
        "frequency_score": 6
    },
    {
        "id": 231,
        "topic": "Cloud Storage",
        "companies": [
            "Google",
            "Snapchat"
        ],
        "question": "You are designing a storage solution for profile pictures. The requirement is access once a month. What storage class should you use? ",
        "options": [
            "Standard",
            "Nearline",
            "Coldline",
            "Archive"
        ],
        "answer": "Nearline",
        "explanation": "Standard for hot data. Nearline < 1/month. Coldline < 1/quarter. Archive < 1/year.",
        "frequency_score": 6
    },
    {
        "id": 232,
        "topic": "Pub/Sub",
        "companies": [
            "Google",
            "Uber"
        ],
        "question": "Your application publishes 1 million/sec messages to Pub/Sub. You observe increased end-to-end latency and growing backlog. What is the most likely cause? ",
        "options": [
            "Subscribers are too slow (backlog)",
            "Publisher quota exceeded",
            "Message size too large",
            "Ordering keys are causing hotspots"
        ],
        "answer": "Subscribers are too slow (backlog)",
        "explanation": "If using ordering keys, high throughput on a single key can limit scalability (1MB/s limit per key). Slow subscribers cause increased backlog.",
        "frequency_score": 7
    },
    {
        "id": 233,
        "topic": "IAM",
        "companies": [
            "Google"
        ],
        "question": "A developer needs to upload files to a bucket in a production project. Following the principle of least privilege, which role should you grant? ",
        "options": [
            "Viewer",
            "Editor",
            "Owner",
            "Cloud Functions Developer"
        ],
        "answer": "Cloud Functions Developer",
        "explanation": "Always prefer predefined specific roles (like BigQuery Data Viewer, Storage Object Admin) over basic roles (Viewer/Editor/Owner) to ensure least privilege.",
        "frequency_score": 9
    },
    {
        "id": 234,
        "topic": "Pub/Sub",
        "companies": [
            "Google",
            "Uber"
        ],
        "question": "Your application publishes 1 million/sec messages to Pub/Sub. You observe increased end-to-end latency and growing backlog. What is the most likely cause? ",
        "options": [
            "Subscribers are too slow (backlog)",
            "Publisher quota exceeded",
            "Message size too large",
            "Ordering keys are causing hotspots"
        ],
        "answer": "Subscribers are too slow (backlog)",
        "explanation": "If using ordering keys, high throughput on a single key can limit scalability (1MB/s limit per key). Slow subscribers cause increased backlog.",
        "frequency_score": 7
    },
    {
        "id": 235,
        "topic": "Apache Kafka",
        "companies": [
            "Google",
            "LinkedIn",
            "Uber",
            "Netflix"
        ],
        "question": "You need to ensure strict ordering of messages in Kafka for a specific Transaction ID. How should you configure the producer? ",
        "options": [
            "Use the Transaction ID as the partition key",
            "Use a single partition for the entire topic",
            "Enable idempotent producer",
            "Increase replication factor"
        ],
        "answer": "Use the Transaction ID as the partition key",
        "explanation": "Kafka guarantees ordering WITHIN a partition. Using the Entity ID as the key ensures all messages for that entity go to the same partition.",
        "frequency_score": 6
    },
    {
        "id": 236,
        "topic": "Apache Kafka",
        "companies": [
            "Google",
            "LinkedIn"
        ],
        "question": "What happens if a Kafka Consumer Group has more consumers than partitions in the topic? ",
        "options": [
            "Some consumers will be idle",
            "Throughput increases linearly",
            "Kafka automatically creates more partitions",
            "The extra consumers duplicate the data"
        ],
        "answer": "Some consumers will be idle",
        "explanation": "A partition can be consumed by only one consumer within a group at a time. Extra consumers stay idle.",
        "frequency_score": 6
    },
    {
        "id": 237,
        "topic": "Dataflow",
        "companies": [
            "Google",
            "Spotify",
            "New York Times"
        ],
        "question": "You are building a streaming pipeline to process user clickstreams. You need to handle rolling averages every minute for the last hour. What windowing strategy is appropriate? ",
        "options": [
            "Fixed Windows",
            "Sliding Windows",
            "Session Windows",
            "Global Windows"
        ],
        "answer": "Sliding Windows",
        "explanation": "Session windows gap-fill based on activity. Sliding windows overlap (e.g. every 5 min show last 1 hour). Fixed windows are tumbling.",
        "frequency_score": 9
    },
    {
        "id": 238,
        "topic": "Data Structures",
        "companies": [
            "Google",
            "Amazon",
            "Microsoft",
            "Facebook"
        ],
        "question": "You need to implement a look-up service that checks if a user ID exists in a set of 1 billion users with O(1) average time complexity. Which data structure is best? ",
        "options": [
            "Hash Table / HashSet",
            "Binary Search Tree",
            "Linked List",
            "Array"
        ],
        "answer": "Hash Table / HashSet",
        "explanation": "Hash Tables provide O(1) average case lookup. BST is O(log n).",
        "frequency_score": 8
    },
    {
        "id": 239,
        "topic": "Dataflow",
        "companies": [
            "Google",
            "Spotify",
            "New York Times"
        ],
        "question": "You are building a streaming pipeline to process server logs. You need to handle periods of user activity separated by gaps. What windowing strategy is appropriate? ",
        "options": [
            "Fixed Windows",
            "Sliding Windows",
            "Session Windows",
            "Global Windows"
        ],
        "answer": "Session Windows",
        "explanation": "Session windows gap-fill based on activity. Sliding windows overlap (e.g. every 5 min show last 1 hour). Fixed windows are tumbling.",
        "frequency_score": 9
    },
    {
        "id": 240,
        "topic": "IAM",
        "companies": [
            "Google"
        ],
        "question": "A developer needs to deploy Cloud Functions in a production project. Following the principle of least privilege, which role should you grant? ",
        "options": [
            "Viewer",
            "Editor",
            "Owner",
            "BigQuery Data Viewer"
        ],
        "answer": "BigQuery Data Viewer",
        "explanation": "Always prefer predefined specific roles (like BigQuery Data Viewer, Storage Object Admin) over basic roles (Viewer/Editor/Owner) to ensure least privilege.",
        "frequency_score": 9
    },
    {
        "id": 241,
        "topic": "Apache Spark",
        "companies": [
            "Google",
            "Databricks",
            "Amazon"
        ],
        "question": "In Spark, what is the difference between a Transformation and an Action? ",
        "options": [
            "Transformations are lazy, Actions match strict execution",
            "Actions are lazy, Transformations trigger execution",
            "They are the same",
            "Transformations save to disk, Actions read from disk"
        ],
        "answer": "Transformations are lazy, Actions match strict execution",
        "explanation": "Transformations (like map, filter) build the DAG but do not execute. Actions (like count, collect, save) trigger the actual computation.",
        "frequency_score": 6
    },
    {
        "id": 242,
        "topic": "IAM",
        "companies": [
            "Google"
        ],
        "question": "A developer needs to deploy Cloud Functions in a production project. Following the principle of least privilege, which role should you grant? ",
        "options": [
            "Viewer",
            "Editor",
            "Owner",
            "Storage Object Creator"
        ],
        "answer": "Storage Object Creator",
        "explanation": "Always prefer predefined specific roles (like BigQuery Data Viewer, Storage Object Admin) over basic roles (Viewer/Editor/Owner) to ensure least privilege.",
        "frequency_score": 9
    },
    {
        "id": 243,
        "topic": "Cloud Spanner",
        "companies": [
            "Google",
            "Uber",
            "Pokemon GO"
        ],
        "question": "You are designing a global banking ledger. You require strong consistency and 99.999% availability. Which database service should you choose? ",
        "options": [
            "Cloud Spanner",
            "Cloud SQL",
            "Bigtable",
            "Firestore"
        ],
        "answer": "Cloud Spanner",
        "explanation": "Cloud Spanner is the only service providing global strong consistency and horizontal scalability with relational semantics (SQL).",
        "frequency_score": 8
    },
    {
        "id": 244,
        "topic": "Apache Kafka",
        "companies": [
            "Google",
            "LinkedIn"
        ],
        "question": "What happens if a Kafka Consumer Group has more consumers than partitions in the topic? ",
        "options": [
            "Some consumers will be idle",
            "Throughput increases linearly",
            "Kafka automatically creates more partitions",
            "The extra consumers duplicate the data"
        ],
        "answer": "Some consumers will be idle",
        "explanation": "A partition can be consumed by only one consumer within a group at a time. Extra consumers stay idle.",
        "frequency_score": 6
    },
    {
        "id": 245,
        "topic": "Apache Spark",
        "companies": [
            "Google",
            "Databricks",
            "Facebook",
            "Netflix"
        ],
        "question": "You are optimizing a Spark job that is suffering from data skew. One task takes 10x longer than others during a wide transformation. Which technique is most effective? ",
        "options": [
            "Salting the key",
            "Increasing the number of executors",
            "Using a larger instance type",
            "Broadcasting the large table"
        ],
        "answer": "Salting the key",
        "explanation": "Salting adds a random prefix to the skewed key to distribute it. Broadcasting is best for Skewed Joins where one table is small.",
        "frequency_score": 6
    },
    {
        "id": 246,
        "topic": "Data Structures",
        "companies": [
            "Google",
            "Amazon",
            "Microsoft",
            "Facebook"
        ],
        "question": "You need to implement a look-up service that checks if a user ID exists in a set of 1 billion users with O(1) average time complexity. Which data structure is best? ",
        "options": [
            "Hash Table / HashSet",
            "Binary Search Tree",
            "Linked List",
            "Array"
        ],
        "answer": "Hash Table / HashSet",
        "explanation": "Hash Tables provide O(1) average case lookup. BST is O(log n).",
        "frequency_score": 8
    },
    {
        "id": 247,
        "topic": "Cloud Spanner",
        "companies": [
            "Google",
            "Uber",
            "Pokemon GO"
        ],
        "question": "You are designing a global banking ledger. You require strong consistency and 99.999% availability. Which database service should you choose? ",
        "options": [
            "Cloud Spanner",
            "Cloud SQL",
            "Bigtable",
            "Firestore"
        ],
        "answer": "Cloud Spanner",
        "explanation": "Cloud Spanner is the only service providing global strong consistency and horizontal scalability with relational semantics (SQL).",
        "frequency_score": 8
    },
    {
        "id": 248,
        "topic": "Pub/Sub",
        "companies": [
            "Google",
            "Uber"
        ],
        "question": "Your application publishes high throughput messages to Pub/Sub. You observe increased end-to-end latency and growing backlog. What is the most likely cause? ",
        "options": [
            "Subscribers are too slow (backlog)",
            "Publisher quota exceeded",
            "Message size too large",
            "Ordering keys are causing hotspots"
        ],
        "answer": "Subscribers are too slow (backlog)",
        "explanation": "If using ordering keys, high throughput on a single key can limit scalability (1MB/s limit per key). Slow subscribers cause increased backlog.",
        "frequency_score": 7
    },
    {
        "id": 249,
        "topic": "Apache Kafka",
        "companies": [
            "Google",
            "LinkedIn"
        ],
        "question": "What happens if a Kafka Consumer Group has more consumers than partitions in the topic? ",
        "options": [
            "Some consumers will be idle",
            "Throughput increases linearly",
            "Kafka automatically creates more partitions",
            "The extra consumers duplicate the data"
        ],
        "answer": "Some consumers will be idle",
        "explanation": "A partition can be consumed by only one consumer within a group at a time. Extra consumers stay idle.",
        "frequency_score": 6
    },
    {
        "id": 250,
        "topic": "Cloud Spanner",
        "companies": [
            "Google",
            "Uber",
            "Pokemon GO"
        ],
        "question": "You are designing a global banking ledger. You require strong consistency and horizontal scalability. Which database service should you choose? ",
        "options": [
            "Cloud Spanner",
            "Cloud SQL",
            "Bigtable",
            "Firestore"
        ],
        "answer": "Cloud Spanner",
        "explanation": "Cloud Spanner is the only service providing global strong consistency and horizontal scalability with relational semantics (SQL).",
        "frequency_score": 8
    },
    {
        "id": 251,
        "topic": "IAM",
        "companies": [
            "Google"
        ],
        "question": "A developer needs to deploy Cloud Functions in a production project. Following the principle of least privilege, which role should you grant? ",
        "options": [
            "Viewer",
            "Editor",
            "Owner",
            "Cloud Functions Developer"
        ],
        "answer": "Cloud Functions Developer",
        "explanation": "Always prefer predefined specific roles (like BigQuery Data Viewer, Storage Object Admin) over basic roles (Viewer/Editor/Owner) to ensure least privilege.",
        "frequency_score": 9
    },
    {
        "id": 252,
        "topic": "Apache Spark",
        "companies": [
            "Google",
            "Databricks",
            "Facebook",
            "Netflix"
        ],
        "question": "You are optimizing a Spark job that is suffering from data skew. You are joining a large skewed table with a small reference table. Which technique is most effective? ",
        "options": [
            "Salting the key",
            "Increasing the number of executors",
            "Using a larger instance type",
            "Broadcasting the large table"
        ],
        "answer": "Salting the key",
        "explanation": "Salting adds a random prefix to the skewed key to distribute it. Broadcasting is best for Skewed Joins where one table is small.",
        "frequency_score": 6
    },
    {
        "id": 253,
        "topic": "Cloud Storage",
        "companies": [
            "Google",
            "Snapchat"
        ],
        "question": "You are designing a storage solution for daily analytics content. The requirement is access once a quarter. What storage class should you use? ",
        "options": [
            "Standard",
            "Nearline",
            "Coldline",
            "Archive"
        ],
        "answer": "Coldline",
        "explanation": "Standard for hot data. Nearline < 1/month. Coldline < 1/quarter. Archive < 1/year.",
        "frequency_score": 6
    },
    {
        "id": 254,
        "topic": "BigQuery",
        "companies": [
            "Google",
            "Spotify",
            "Twitter"
        ],
        "question": "You need to store 1 PB of audit logs data in BigQuery. The data is accessed once a quarter. Which storage class fits best to minimize costs? ",
        "options": [
            "Active Storage",
            "Long-term Storage",
            "Nearline Storage",
            "Coldline Storage"
        ],
        "answer": "Active Storage",
        "explanation": "BigQuery Long-term storage applies automatically after 90 days of no modification, reducing price by ~50%.",
        "frequency_score": 10
    },
    {
        "id": 255,
        "topic": "Apache Kafka",
        "companies": [
            "Google",
            "LinkedIn"
        ],
        "question": "What happens if a Kafka Consumer Group has more consumers than partitions in the topic? ",
        "options": [
            "Some consumers will be idle",
            "Throughput increases linearly",
            "Kafka automatically creates more partitions",
            "The extra consumers duplicate the data"
        ],
        "answer": "Some consumers will be idle",
        "explanation": "A partition can be consumed by only one consumer within a group at a time. Extra consumers stay idle.",
        "frequency_score": 6
    },
    {
        "id": 256,
        "topic": "Cloud Spanner",
        "companies": [
            "Google",
            "Uber",
            "Pokemon GO"
        ],
        "question": "You are designing a global banking ledger. You require strong consistency and horizontal scalability. Which database service should you choose? ",
        "options": [
            "Cloud Spanner",
            "Cloud SQL",
            "Bigtable",
            "Firestore"
        ],
        "answer": "Cloud Spanner",
        "explanation": "Cloud Spanner is the only service providing global strong consistency and horizontal scalability with relational semantics (SQL).",
        "frequency_score": 8
    },
    {
        "id": 257,
        "topic": "IAM",
        "companies": [
            "Google"
        ],
        "question": "A developer needs to upload files to a bucket in a production project. Following the principle of least privilege, which role should you grant? ",
        "options": [
            "Viewer",
            "Editor",
            "Owner",
            "Storage Object Creator"
        ],
        "answer": "Storage Object Creator",
        "explanation": "Always prefer predefined specific roles (like BigQuery Data Viewer, Storage Object Admin) over basic roles (Viewer/Editor/Owner) to ensure least privilege.",
        "frequency_score": 9
    },
    {
        "id": 258,
        "topic": "Cloud Spanner",
        "companies": [
            "Google",
            "Uber",
            "Pokemon GO"
        ],
        "question": "You are designing a global banking ledger. You require strong consistency and horizontal scalability. Which database service should you choose? ",
        "options": [
            "Cloud Spanner",
            "Cloud SQL",
            "Bigtable",
            "Firestore"
        ],
        "answer": "Cloud Spanner",
        "explanation": "Cloud Spanner is the only service providing global strong consistency and horizontal scalability with relational semantics (SQL).",
        "frequency_score": 8
    },
    {
        "id": 259,
        "topic": "Data Structures",
        "companies": [
            "Google",
            "Amazon",
            "Microsoft",
            "Facebook"
        ],
        "question": "You need to implement a look-up service that checks if a user ID exists in a set of 1 billion users with O(1) average time complexity. Which data structure is best? ",
        "options": [
            "Hash Table / HashSet",
            "Binary Search Tree",
            "Linked List",
            "Array"
        ],
        "answer": "Hash Table / HashSet",
        "explanation": "Hash Tables provide O(1) average case lookup. BST is O(log n).",
        "frequency_score": 8
    },
    {
        "id": 260,
        "topic": "Apache Spark",
        "companies": [
            "Google",
            "Databricks",
            "Amazon"
        ],
        "question": "In Spark, what is the difference between a Transformation and an Action? ",
        "options": [
            "Transformations are lazy, Actions match strict execution",
            "Actions are lazy, Transformations trigger execution",
            "They are the same",
            "Transformations save to disk, Actions read from disk"
        ],
        "answer": "Transformations are lazy, Actions match strict execution",
        "explanation": "Transformations (like map, filter) build the DAG but do not execute. Actions (like count, collect, save) trigger the actual computation.",
        "frequency_score": 6
    },
    {
        "id": 261,
        "topic": "Bigtable",
        "companies": [
            "Google",
            "Spotify"
        ],
        "question": "You are designing a Bigtable schema for social media posts. Queries will primarily be retrieve latest events for a specific entity. Which row key design is optimal? ",
        "options": [
            "DeviceID#Date",
            "Date#DeviceID",
            "ReverseTimestamp#DeviceID",
            "Random#DeviceID"
        ],
        "answer": "DeviceID#Date",
        "explanation": "Avoid starting with timestamp to prevent hotspots. Use EntityID first for entity-lookup queries. Use ReverseTimestamp for 'latest items' queries globally.",
        "frequency_score": 7
    },
    {
        "id": 262,
        "topic": "IAM",
        "companies": [
            "Google"
        ],
        "question": "A developer needs to view BigQuery datasets in a production project. Following the principle of least privilege, which role should you grant? ",
        "options": [
            "Viewer",
            "Editor",
            "Owner",
            "Cloud Functions Developer"
        ],
        "answer": "Cloud Functions Developer",
        "explanation": "Always prefer predefined specific roles (like BigQuery Data Viewer, Storage Object Admin) over basic roles (Viewer/Editor/Owner) to ensure least privilege.",
        "frequency_score": 9
    },
    {
        "id": 263,
        "topic": "Algorithms",
        "companies": [
            "Google",
            "Amazon",
            "Microsoft"
        ],
        "question": "What is the time complexity of a Merge Sort algorithm in the worst case? ",
        "options": [
            "O(n log n)",
            "O(n^2)",
            "O(n)",
            "O(log n)"
        ],
        "answer": "O(n log n)",
        "explanation": "Merge Sort is O(n log n). Quick Sort is O(n^2) in worst case (though avg O(n log n)). Bubble Sort is O(n^2).",
        "frequency_score": 8
    },
    {
        "id": 264,
        "topic": "Pub/Sub",
        "companies": [
            "Google",
            "Uber"
        ],
        "question": "Your application publishes 1 million/sec messages to Pub/Sub. You observe increased end-to-end latency and growing backlog. What is the most likely cause? ",
        "options": [
            "Subscribers are too slow (backlog)",
            "Publisher quota exceeded",
            "Message size too large",
            "Ordering keys are causing hotspots"
        ],
        "answer": "Subscribers are too slow (backlog)",
        "explanation": "If using ordering keys, high throughput on a single key can limit scalability (1MB/s limit per key). Slow subscribers cause increased backlog.",
        "frequency_score": 7
    },
    {
        "id": 265,
        "topic": "IAM",
        "companies": [
            "Google"
        ],
        "question": "A developer needs to upload files to a bucket in a production project. Following the principle of least privilege, which role should you grant? ",
        "options": [
            "Viewer",
            "Editor",
            "Owner",
            "Cloud Functions Developer"
        ],
        "answer": "Cloud Functions Developer",
        "explanation": "Always prefer predefined specific roles (like BigQuery Data Viewer, Storage Object Admin) over basic roles (Viewer/Editor/Owner) to ensure least privilege.",
        "frequency_score": 9
    },
    {
        "id": 266,
        "topic": "Pub/Sub",
        "companies": [
            "Google",
            "Uber"
        ],
        "question": "Your application publishes 1 million/sec messages to Pub/Sub. You observe throughput limits on specific keys. What is the most likely cause? ",
        "options": [
            "Subscribers are too slow (backlog)",
            "Publisher quota exceeded",
            "Message size too large",
            "Ordering keys are causing hotspots"
        ],
        "answer": "Ordering keys are causing hotspots",
        "explanation": "If using ordering keys, high throughput on a single key can limit scalability (1MB/s limit per key). Slow subscribers cause increased backlog.",
        "frequency_score": 7
    },
    {
        "id": 267,
        "topic": "BigQuery",
        "companies": [
            "Google",
            "Spotify",
            "Twitter"
        ],
        "question": "You need to store 500 TB of transaction records data in BigQuery. The data is accessed rarely (every 6 months). Which storage class fits best to minimize costs?",
        "options": [
            "Active Storage",
            "Long-term Storage",
            "Nearline Storage",
            "Coldline Storage"
        ],
        "answer": "Long-term Storage",
        "explanation": "BigQuery Long-term storage applies automatically after 90 days of no modification, reducing price by ~50%.",
        "frequency_score": 10
    },
    {
        "id": 268,
        "topic": "Data Structures",
        "companies": [
            "Google",
            "Amazon",
            "Microsoft",
            "Facebook"
        ],
        "question": "You need to implement a look-up service that checks if a user ID exists in a set of 1 billion users with O(1) average time complexity. Which data structure is best? ",
        "options": [
            "Hash Table / HashSet",
            "Binary Search Tree",
            "Linked List",
            "Array"
        ],
        "answer": "Hash Table / HashSet",
        "explanation": "Hash Tables provide O(1) average case lookup. BST is O(log n).",
        "frequency_score": 8
    },
    {
        "id": 269,
        "topic": "Apache Spark",
        "companies": [
            "Google",
            "Databricks",
            "Amazon"
        ],
        "question": "In Spark, what is the difference between a Transformation and an Action? ",
        "options": [
            "Transformations are lazy, Actions match strict execution",
            "Actions are lazy, Transformations trigger execution",
            "They are the same",
            "Transformations save to disk, Actions read from disk"
        ],
        "answer": "Transformations are lazy, Actions match strict execution",
        "explanation": "Transformations (like map, filter) build the DAG but do not execute. Actions (like count, collect, save) trigger the actual computation.",
        "frequency_score": 6
    },
    {
        "id": 270,
        "topic": "Apache Kafka",
        "companies": [
            "Google",
            "LinkedIn",
            "Uber",
            "Netflix"
        ],
        "question": "You need to ensure strict ordering of messages in Kafka for a specific User ID. How should you configure the producer? ",
        "options": [
            "Use the User ID as the partition key",
            "Use a single partition for the entire topic",
            "Enable idempotent producer",
            "Increase replication factor"
        ],
        "answer": "Use the User ID as the partition key",
        "explanation": "Kafka guarantees ordering WITHIN a partition. Using the Entity ID as the key ensures all messages for that entity go to the same partition.",
        "frequency_score": 6
    },
    {
        "id": 271,
        "topic": "Data Structures",
        "companies": [
            "Google",
            "Amazon",
            "Microsoft",
            "Facebook"
        ],
        "question": "You need to implement a look-up service that checks if a user ID exists in a set of 1 billion users with O(1) average time complexity. Which data structure is best? ",
        "options": [
            "Hash Table / HashSet",
            "Binary Search Tree",
            "Linked List",
            "Array"
        ],
        "answer": "Hash Table / HashSet",
        "explanation": "Hash Tables provide O(1) average case lookup. BST is O(log n).",
        "frequency_score": 8
    },
    {
        "id": 272,
        "topic": "Data Structures",
        "companies": [
            "Google",
            "Amazon",
            "Microsoft",
            "Facebook"
        ],
        "question": "You need to implement a look-up service that checks if a user ID exists in a set of 1 billion users with O(log n) average time complexity. Which data structure is best? ",
        "options": [
            "Hash Table / HashSet",
            "Binary Search Tree",
            "Linked List",
            "Array"
        ],
        "answer": "Binary Search Tree",
        "explanation": "Hash Tables provide O(1) average case lookup. BST is O(log n).",
        "frequency_score": 8
    },
    {
        "id": 273,
        "topic": "Cloud Storage",
        "companies": [
            "Google",
            "Snapchat"
        ],
        "question": "You are designing a storage solution for disaster recovery backups. The requirement is access once a year. What storage class should you use?",
        "options": [
            "Standard",
            "Nearline",
            "Coldline",
            "Archive"
        ],
        "answer": "Archive",
        "explanation": "Standard for hot data. Nearline < 1/month. Coldline < 1/quarter. Archive < 1/year.",
        "frequency_score": 6
    },
    {
        "id": 274,
        "topic": "Bigtable",
        "companies": [
            "Google",
            "Spotify"
        ],
        "question": "You are designing a Bigtable schema for IoT events. Queries will primarily be retrieve most recent events globally. Which row key design is optimal? ",
        "options": [
            "DeviceID#Date",
            "Date#DeviceID",
            "ReverseTimestamp#DeviceID",
            "Random#DeviceID"
        ],
        "answer": "ReverseTimestamp#DeviceID",
        "explanation": "Avoid starting with timestamp to prevent hotspots. Use EntityID first for entity-lookup queries. Use ReverseTimestamp for 'latest items' queries globally.",
        "frequency_score": 7
    },
    {
        "id": 275,
        "topic": "Cloud Spanner",
        "companies": [
            "Google",
            "Uber",
            "Pokemon GO"
        ],
        "question": "You are designing a global banking ledger. You require strong consistency and 99.999% availability. Which database service should you choose? ",
        "options": [
            "Cloud Spanner",
            "Cloud SQL",
            "Bigtable",
            "Firestore"
        ],
        "answer": "Cloud Spanner",
        "explanation": "Cloud Spanner is the only service providing global strong consistency and horizontal scalability with relational semantics (SQL).",
        "frequency_score": 8
    },
    {
        "id": 276,
        "topic": "Data Structures",
        "companies": [
            "Google",
            "Amazon",
            "Microsoft",
            "Facebook"
        ],
        "question": "You need to implement a look-up service that checks if a user ID exists in a set of 1 billion users with O(1) average time complexity. Which data structure is best? ",
        "options": [
            "Hash Table / HashSet",
            "Binary Search Tree",
            "Linked List",
            "Array"
        ],
        "answer": "Hash Table / HashSet",
        "explanation": "Hash Tables provide O(1) average case lookup. BST is O(log n).",
        "frequency_score": 8
    },
    {
        "id": 277,
        "topic": "Apache Spark",
        "companies": [
            "Google",
            "Databricks",
            "Amazon"
        ],
        "question": "In Spark, what is the difference between a Transformation and an Action? ",
        "options": [
            "Transformations are lazy, Actions match strict execution",
            "Actions are lazy, Transformations trigger execution",
            "They are the same",
            "Transformations save to disk, Actions read from disk"
        ],
        "answer": "Transformations are lazy, Actions match strict execution",
        "explanation": "Transformations (like map, filter) build the DAG but do not execute. Actions (like count, collect, save) trigger the actual computation.",
        "frequency_score": 6
    },
    {
        "id": 278,
        "topic": "Dataflow",
        "companies": [
            "Google",
            "Spotify",
            "New York Times"
        ],
        "question": "You are building a streaming pipeline to process IoT temperature sensors. You need to handle rolling averages every minute for the last hour. What windowing strategy is appropriate? ",
        "options": [
            "Fixed Windows",
            "Sliding Windows",
            "Session Windows",
            "Global Windows"
        ],
        "answer": "Sliding Windows",
        "explanation": "Session windows gap-fill based on activity. Sliding windows overlap (e.g. every 5 min show last 1 hour). Fixed windows are tumbling.",
        "frequency_score": 9
    },
    {
        "id": 279,
        "topic": "Apache Kafka",
        "companies": [
            "Google",
            "LinkedIn",
            "Uber",
            "Netflix"
        ],
        "question": "You need to ensure strict ordering of messages in Kafka for a specific User ID. How should you configure the producer? ",
        "options": [
            "Use the User ID as the partition key",
            "Use a single partition for the entire topic",
            "Enable idempotent producer",
            "Increase replication factor"
        ],
        "answer": "Use the User ID as the partition key",
        "explanation": "Kafka guarantees ordering WITHIN a partition. Using the Entity ID as the key ensures all messages for that entity go to the same partition.",
        "frequency_score": 6
    },
    {
        "id": 280,
        "topic": "Pub/Sub",
        "companies": [
            "Google",
            "Uber"
        ],
        "question": "Your application publishes high throughput messages to Pub/Sub. You observe throughput limits on specific keys. What is the most likely cause? ",
        "options": [
            "Subscribers are too slow (backlog)",
            "Publisher quota exceeded",
            "Message size too large",
            "Ordering keys are causing hotspots"
        ],
        "answer": "Ordering keys are causing hotspots",
        "explanation": "If using ordering keys, high throughput on a single key can limit scalability (1MB/s limit per key). Slow subscribers cause increased backlog.",
        "frequency_score": 7
    },
    {
        "id": 281,
        "topic": "Apache Spark",
        "companies": [
            "Google",
            "Databricks",
            "Amazon"
        ],
        "question": "In Spark, what is the difference between a Transformation and an Action? ",
        "options": [
            "Transformations are lazy, Actions match strict execution",
            "Actions are lazy, Transformations trigger execution",
            "They are the same",
            "Transformations save to disk, Actions read from disk"
        ],
        "answer": "Transformations are lazy, Actions match strict execution",
        "explanation": "Transformations (like map, filter) build the DAG but do not execute. Actions (like count, collect, save) trigger the actual computation.",
        "frequency_score": 6
    },
    {
        "id": 282,
        "topic": "Data Structures",
        "companies": [
            "Google",
            "Amazon",
            "Microsoft",
            "Facebook"
        ],
        "question": "You need to implement a look-up service that checks if a user ID exists in a set of 1 billion users with O(log n) average time complexity. Which data structure is best? ",
        "options": [
            "Hash Table / HashSet",
            "Binary Search Tree",
            "Linked List",
            "Array"
        ],
        "answer": "Binary Search Tree",
        "explanation": "Hash Tables provide O(1) average case lookup. BST is O(log n).",
        "frequency_score": 8
    },
    {
        "id": 283,
        "topic": "Bigtable",
        "companies": [
            "Google",
            "Spotify"
        ],
        "question": "You are designing a Bigtable schema for social media posts. Queries will primarily be retrieve latest events for a specific entity. Which row key design is optimal? ",
        "options": [
            "UserID#Timestamp",
            "Timestamp#UserID",
            "ReverseTimestamp#UserID",
            "Random#UserID"
        ],
        "answer": "UserID#Timestamp",
        "explanation": "Avoid starting with timestamp to prevent hotspots. Use EntityID first for entity-lookup queries. Use ReverseTimestamp for 'latest items' queries globally.",
        "frequency_score": 7
    },
    {
        "id": 284,
        "topic": "Data Structures",
        "companies": [
            "Google",
            "Amazon",
            "Microsoft",
            "Facebook"
        ],
        "question": "You need to implement a look-up service that checks if a user ID exists in a set of 1 billion users with O(log n) average time complexity. Which data structure is best? ",
        "options": [
            "Hash Table / HashSet",
            "Binary Search Tree",
            "Linked List",
            "Array"
        ],
        "answer": "Binary Search Tree",
        "explanation": "Hash Tables provide O(1) average case lookup. BST is O(log n).",
        "frequency_score": 8
    },
    {
        "id": 285,
        "topic": "Cloud Spanner",
        "companies": [
            "Google",
            "Uber",
            "Pokemon GO"
        ],
        "question": "You are designing a global banking ledger. You require strong consistency and horizontal scalability. Which database service should you choose? ",
        "options": [
            "Cloud Spanner",
            "Cloud SQL",
            "Bigtable",
            "Firestore"
        ],
        "answer": "Cloud Spanner",
        "explanation": "Cloud Spanner is the only service providing global strong consistency and horizontal scalability with relational semantics (SQL).",
        "frequency_score": 8
    },
    {
        "id": 286,
        "topic": "IAM",
        "companies": [
            "Google"
        ],
        "question": "A developer needs to upload files to a bucket in a production project. Following the principle of least privilege, which role should you grant? ",
        "options": [
            "Viewer",
            "Editor",
            "Owner",
            "BigQuery Data Viewer"
        ],
        "answer": "BigQuery Data Viewer",
        "explanation": "Always prefer predefined specific roles (like BigQuery Data Viewer, Storage Object Admin) over basic roles (Viewer/Editor/Owner) to ensure least privilege.",
        "frequency_score": 9
    },
    {
        "id": 287,
        "topic": "Algorithms",
        "companies": [
            "Google",
            "Amazon",
            "Microsoft"
        ],
        "question": "What is the time complexity of a Merge Sort algorithm in the worst case? ",
        "options": [
            "O(n log n)",
            "O(n^2)",
            "O(n)",
            "O(log n)"
        ],
        "answer": "O(n log n)",
        "explanation": "Merge Sort is O(n log n). Quick Sort is O(n^2) in worst case (though avg O(n log n)). Bubble Sort is O(n^2).",
        "frequency_score": 8
    },
    {
        "id": 288,
        "topic": "IAM",
        "companies": [
            "Google"
        ],
        "question": "A developer needs to deploy Cloud Functions in a production project. Following the principle of least privilege, which role should you grant? ",
        "options": [
            "Viewer",
            "Editor",
            "Owner",
            "Cloud Functions Developer"
        ],
        "answer": "Cloud Functions Developer",
        "explanation": "Always prefer predefined specific roles (like BigQuery Data Viewer, Storage Object Admin) over basic roles (Viewer/Editor/Owner) to ensure least privilege.",
        "frequency_score": 9
    },
    {
        "id": 289,
        "topic": "Bigtable",
        "companies": [
            "Google",
            "Spotify"
        ],
        "question": "You are designing a Bigtable schema for IoT events. Queries will primarily be retrieve latest events for a specific entity. Which row key design is optimal? ",
        "options": [
            "DeviceID#Date",
            "Date#DeviceID",
            "ReverseTimestamp#DeviceID",
            "Random#DeviceID"
        ],
        "answer": "DeviceID#Date",
        "explanation": "Avoid starting with timestamp to prevent hotspots. Use EntityID first for entity-lookup queries. Use ReverseTimestamp for 'latest items' queries globally.",
        "frequency_score": 7
    },
    {
        "id": 290,
        "topic": "Dataflow",
        "companies": [
            "Google",
            "Spotify",
            "New York Times"
        ],
        "question": "You are building a streaming pipeline to process IoT temperature sensors. You need to handle periods of user activity separated by gaps. What windowing strategy is appropriate?",
        "options": [
            "Fixed Windows",
            "Sliding Windows",
            "Session Windows",
            "Global Windows"
        ],
        "answer": "Session Windows",
        "explanation": "Session windows gap-fill based on activity. Sliding windows overlap (e.g. every 5 min show last 1 hour). Fixed windows are tumbling.",
        "frequency_score": 9
    },
    {
        "id": 291,
        "topic": "Cloud Storage",
        "companies": [
            "Google",
            "Snapchat"
        ],
        "question": "You are designing a storage solution for profile pictures. The requirement is high frequency access. What storage class should you use? ",
        "options": [
            "Standard",
            "Nearline",
            "Coldline",
            "Archive"
        ],
        "answer": "Standard",
        "explanation": "Standard for hot data. Nearline < 1/month. Coldline < 1/quarter. Archive < 1/year.",
        "frequency_score": 6
    },
    {
        "id": 292,
        "topic": "Apache Spark",
        "companies": [
            "Google",
            "Databricks",
            "Facebook",
            "Netflix"
        ],
        "question": "You are optimizing a Spark job that is suffering from data skew. One task takes 10x longer than others during a wide transformation. Which technique is most effective? ",
        "options": [
            "Salting the key",
            "Increasing the number of executors",
            "Using a larger instance type",
            "Broadcasting the large table"
        ],
        "answer": "Salting the key",
        "explanation": "Salting adds a random prefix to the skewed key to distribute it. Broadcasting is best for Skewed Joins where one table is small.",
        "frequency_score": 6
    },
    {
        "id": 293,
        "topic": "Data Structures",
        "companies": [
            "Google",
            "Amazon",
            "Microsoft",
            "Facebook"
        ],
        "question": "You need to implement a look-up service that checks if a user ID exists in a set of 1 billion users with O(log n) average time complexity. Which data structure is best? ",
        "options": [
            "Hash Table / HashSet",
            "Binary Search Tree",
            "Linked List",
            "Array"
        ],
        "answer": "Binary Search Tree",
        "explanation": "Hash Tables provide O(1) average case lookup. BST is O(log n).",
        "frequency_score": 8
    },
    {
        "id": 294,
        "topic": "BigQuery",
        "companies": [
            "Google",
            "Spotify",
            "Twitter"
        ],
        "question": "You need to store 1 PB of sensor metrics data in BigQuery. The data is accessed daily. Which storage class fits best to minimize costs? ",
        "options": [
            "Active Storage",
            "Long-term Storage",
            "Nearline Storage",
            "Coldline Storage"
        ],
        "answer": "Active Storage",
        "explanation": "BigQuery Long-term storage applies automatically after 90 days of no modification, reducing price by ~50%.",
        "frequency_score": 10
    },
    {
        "id": 295,
        "topic": "Apache Spark",
        "companies": [
            "Google",
            "Databricks",
            "Facebook",
            "Netflix"
        ],
        "question": "You are optimizing a Spark job that is suffering from data skew. One task takes 10x longer than others during a wide transformation. Which technique is most effective? ",
        "options": [
            "Salting the key",
            "Increasing the number of executors",
            "Using a larger instance type",
            "Broadcasting the large table"
        ],
        "answer": "Salting the key",
        "explanation": "Salting adds a random prefix to the skewed key to distribute it. Broadcasting is best for Skewed Joins where one table is small.",
        "frequency_score": 6
    },
    {
        "id": 296,
        "topic": "Bigtable",
        "companies": [
            "Google",
            "Spotify"
        ],
        "question": "You are designing a Bigtable schema for IoT events. Queries will primarily be retrieve most recent events globally. Which row key design is optimal? ",
        "options": [
            "SensorID#Timestamp",
            "Timestamp#SensorID",
            "ReverseTimestamp#SensorID",
            "Random#SensorID"
        ],
        "answer": "ReverseTimestamp#SensorID",
        "explanation": "Avoid starting with timestamp to prevent hotspots. Use EntityID first for entity-lookup queries. Use ReverseTimestamp for 'latest items' queries globally.",
        "frequency_score": 7
    },
    {
        "id": 297,
        "topic": "Apache Kafka",
        "companies": [
            "Google",
            "LinkedIn"
        ],
        "question": "What happens if a Kafka Consumer Group has more consumers than partitions in the topic? ",
        "options": [
            "Some consumers will be idle",
            "Throughput increases linearly",
            "Kafka automatically creates more partitions",
            "The extra consumers duplicate the data"
        ],
        "answer": "Some consumers will be idle",
        "explanation": "A partition can be consumed by only one consumer within a group at a time. Extra consumers stay idle.",
        "frequency_score": 6
    },
    {
        "id": 298,
        "topic": "Data Structures",
        "companies": [
            "Google",
            "Amazon",
            "Microsoft",
            "Facebook"
        ],
        "question": "You need to implement a look-up service that checks if a user ID exists in a set of 1 billion users with O(1) average time complexity. Which data structure is best? ",
        "options": [
            "Hash Table / HashSet",
            "Binary Search Tree",
            "Linked List",
            "Array"
        ],
        "answer": "Hash Table / HashSet",
        "explanation": "Hash Tables provide O(1) average case lookup. BST is O(log n).",
        "frequency_score": 8
    },
    {
        "id": 299,
        "topic": "Data Structures",
        "companies": [
            "Google",
            "Amazon",
            "Microsoft",
            "Facebook"
        ],
        "question": "You need to implement a look-up service that checks if a user ID exists in a set of 1 billion users with O(log n) average time complexity. Which data structure is best? ",
        "options": [
            "Hash Table / HashSet",
            "Binary Search Tree",
            "Linked List",
            "Array"
        ],
        "answer": "Binary Search Tree",
        "explanation": "Hash Tables provide O(1) average case lookup. BST is O(log n).",
        "frequency_score": 8
    },
    {
        "id": 300,
        "topic": "Cloud Spanner",
        "companies": [
            "Google",
            "Uber",
            "Pokemon GO"
        ],
        "question": "You are designing a global banking ledger. You require strong consistency and horizontal scalability. Which database service should you choose? ",
        "options": [
            "Cloud Spanner",
            "Cloud SQL",
            "Bigtable",
            "Firestore"
        ],
        "answer": "Cloud Spanner",
        "explanation": "Cloud Spanner is the only service providing global strong consistency and horizontal scalability with relational semantics (SQL).",
        "frequency_score": 8
    },
    {
        "id": 301,
        "topic": "Pub/Sub",
        "companies": [
            "Google",
            "Uber"
        ],
        "question": "Your application publishes high throughput messages to Pub/Sub. You observe throughput limits on specific keys. What is the most likely cause? ",
        "options": [
            "Subscribers are too slow (backlog)",
            "Publisher quota exceeded",
            "Message size too large",
            "Ordering keys are causing hotspots"
        ],
        "answer": "Ordering keys are causing hotspots",
        "explanation": "If using ordering keys, high throughput on a single key can limit scalability (1MB/s limit per key). Slow subscribers cause increased backlog.",
        "frequency_score": 7
    },
    {
        "id": 302,
        "topic": "Bigtable",
        "companies": [
            "Google",
            "Spotify"
        ],
        "question": "You are designing a Bigtable schema for social media posts. Queries will primarily be retrieve most recent events globally. Which row key design is optimal? ",
        "options": [
            "UserID#Date",
            "Date#UserID",
            "ReverseTimestamp#UserID",
            "Random#UserID"
        ],
        "answer": "ReverseTimestamp#UserID",
        "explanation": "Avoid starting with timestamp to prevent hotspots. Use EntityID first for entity-lookup queries. Use ReverseTimestamp for 'latest items' queries globally.",
        "frequency_score": 7
    },
    {
        "id": 303,
        "topic": "BigQuery",
        "companies": [
            "Google",
            "Spotify",
            "Twitter"
        ],
        "question": "You need to store 2 PB of audit logs data in BigQuery. The data is accessed continuously. Which storage class fits best to minimize costs?",
        "options": [
            "Active Storage",
            "Long-term Storage",
            "Nearline Storage",
            "Coldline Storage"
        ],
        "answer": "Active Storage",
        "explanation": "BigQuery Long-term storage applies automatically after 90 days of no modification, reducing price by ~50%.",
        "frequency_score": 10
    },
    {
        "id": 304,
        "topic": "Apache Kafka",
        "companies": [
            "Google",
            "LinkedIn",
            "Uber",
            "Netflix"
        ],
        "question": "You need to ensure strict ordering of messages in Kafka for a specific Device ID. How should you configure the producer? ",
        "options": [
            "Use the Device ID as the partition key",
            "Use a single partition for the entire topic",
            "Enable idempotent producer",
            "Increase replication factor"
        ],
        "answer": "Use the Device ID as the partition key",
        "explanation": "Kafka guarantees ordering WITHIN a partition. Using the Entity ID as the key ensures all messages for that entity go to the same partition.",
        "frequency_score": 6
    },
    {
        "id": 305,
        "topic": "Cloud Spanner",
        "companies": [
            "Google",
            "Uber",
            "Pokemon GO"
        ],
        "question": "You are designing a global banking ledger. You require strong consistency and horizontal scalability. Which database service should you choose? ",
        "options": [
            "Cloud Spanner",
            "Cloud SQL",
            "Bigtable",
            "Firestore"
        ],
        "answer": "Cloud Spanner",
        "explanation": "Cloud Spanner is the only service providing global strong consistency and horizontal scalability with relational semantics (SQL).",
        "frequency_score": 8
    },
    {
        "id": 306,
        "topic": "Apache Spark",
        "companies": [
            "Google",
            "Databricks",
            "Facebook",
            "Netflix"
        ],
        "question": "You are optimizing a Spark job that is suffering from data skew. You are joining a large skewed table with a small reference table. Which technique is most effective? ",
        "options": [
            "Salting the key",
            "Increasing the number of executors",
            "Using a larger instance type",
            "Broadcasting the large table"
        ],
        "answer": "Salting the key",
        "explanation": "Salting adds a random prefix to the skewed key to distribute it. Broadcasting is best for Skewed Joins where one table is small.",
        "frequency_score": 6
    },
    {
        "id": 307,
        "topic": "Data Structures",
        "companies": [
            "Google",
            "Amazon",
            "Microsoft",
            "Facebook"
        ],
        "question": "You need to implement a look-up service that checks if a user ID exists in a set of 1 billion users with O(1) average time complexity. Which data structure is best? ",
        "options": [
            "Hash Table / HashSet",
            "Binary Search Tree",
            "Linked List",
            "Array"
        ],
        "answer": "Hash Table / HashSet",
        "explanation": "Hash Tables provide O(1) average case lookup. BST is O(log n).",
        "frequency_score": 8
    },
    {
        "id": 308,
        "topic": "Cloud Spanner",
        "companies": [
            "Google",
            "Uber",
            "Pokemon GO"
        ],
        "question": "You are designing a global banking ledger. You require strong consistency and 99.999% availability. Which database service should you choose? ",
        "options": [
            "Cloud Spanner",
            "Cloud SQL",
            "Bigtable",
            "Firestore"
        ],
        "answer": "Cloud Spanner",
        "explanation": "Cloud Spanner is the only service providing global strong consistency and horizontal scalability with relational semantics (SQL).",
        "frequency_score": 8
    },
    {
        "id": 309,
        "topic": "Algorithms",
        "companies": [
            "Google",
            "Amazon",
            "Microsoft"
        ],
        "question": "What is the time complexity of a Merge Sort algorithm in the worst case? ",
        "options": [
            "O(n log n)",
            "O(n^2)",
            "O(n)",
            "O(log n)"
        ],
        "answer": "O(n log n)",
        "explanation": "Merge Sort is O(n log n). Quick Sort is O(n^2) in worst case (though avg O(n log n)). Bubble Sort is O(n^2).",
        "frequency_score": 8
    },
    {
        "id": 310,
        "topic": "Cloud Storage",
        "companies": [
            "Google",
            "Snapchat"
        ],
        "question": "You are designing a storage solution for regulatory archives. The requirement is access once a quarter. What storage class should you use?",
        "options": [
            "Standard",
            "Nearline",
            "Coldline",
            "Archive"
        ],
        "answer": "Coldline",
        "explanation": "Standard for hot data. Nearline < 1/month. Coldline < 1/quarter. Archive < 1/year.",
        "frequency_score": 6
    },
    {
        "id": 311,
        "topic": "Apache Spark",
        "companies": [
            "Google",
            "Databricks",
            "Amazon"
        ],
        "question": "In Spark, what is the difference between a Transformation and an Action? ",
        "options": [
            "Transformations are lazy, Actions match strict execution",
            "Actions are lazy, Transformations trigger execution",
            "They are the same",
            "Transformations save to disk, Actions read from disk"
        ],
        "answer": "Transformations are lazy, Actions match strict execution",
        "explanation": "Transformations (like map, filter) build the DAG but do not execute. Actions (like count, collect, save) trigger the actual computation.",
        "frequency_score": 6
    },
    {
        "id": 312,
        "topic": "Apache Spark",
        "companies": [
            "Google",
            "Databricks",
            "Facebook",
            "Netflix"
        ],
        "question": "You are optimizing a Spark job that is suffering from data skew. One task takes 10x longer than others during a wide transformation. Which technique is most effective? ",
        "options": [
            "Salting the key",
            "Increasing the number of executors",
            "Using a larger instance type",
            "Broadcasting the large table"
        ],
        "answer": "Salting the key",
        "explanation": "Salting adds a random prefix to the skewed key to distribute it. Broadcasting is best for Skewed Joins where one table is small.",
        "frequency_score": 6
    },
    {
        "id": 313,
        "topic": "Algorithms",
        "companies": [
            "Google",
            "Amazon",
            "Microsoft"
        ],
        "question": "What is the time complexity of a Quick Sort algorithm in the worst case? ",
        "options": [
            "O(n log n)",
            "O(n^2)",
            "O(n)",
            "O(log n)"
        ],
        "answer": "O(n^2)",
        "explanation": "Merge Sort is O(n log n). Quick Sort is O(n^2) in worst case (though avg O(n log n)). Bubble Sort is O(n^2).",
        "frequency_score": 8
    },
    {
        "id": 314,
        "topic": "IAM",
        "companies": [
            "Google"
        ],
        "question": "A developer needs to deploy Cloud Functions in a production project. Following the principle of least privilege, which role should you grant? ",
        "options": [
            "Viewer",
            "Editor",
            "Owner",
            "Cloud Functions Developer"
        ],
        "answer": "Cloud Functions Developer",
        "explanation": "Always prefer predefined specific roles (like BigQuery Data Viewer, Storage Object Admin) over basic roles (Viewer/Editor/Owner) to ensure least privilege.",
        "frequency_score": 9
    },
    {
        "id": 315,
        "topic": "Dataflow",
        "companies": [
            "Google",
            "Spotify",
            "New York Times"
        ],
        "question": "You are building a streaming pipeline to process server logs. You need to handle periods of user activity separated by gaps. What windowing strategy is appropriate? ",
        "options": [
            "Fixed Windows",
            "Sliding Windows",
            "Session Windows",
            "Global Windows"
        ],
        "answer": "Session Windows",
        "explanation": "Session windows gap-fill based on activity. Sliding windows overlap (e.g. every 5 min show last 1 hour). Fixed windows are tumbling.",
        "frequency_score": 9
    },
    {
        "id": 316,
        "topic": "Apache Spark",
        "companies": [
            "Google",
            "Databricks",
            "Amazon"
        ],
        "question": "In Spark, what is the difference between a Transformation and an Action? ",
        "options": [
            "Transformations are lazy, Actions match strict execution",
            "Actions are lazy, Transformations trigger execution",
            "They are the same",
            "Transformations save to disk, Actions read from disk"
        ],
        "answer": "Transformations are lazy, Actions match strict execution",
        "explanation": "Transformations (like map, filter) build the DAG but do not execute. Actions (like count, collect, save) trigger the actual computation.",
        "frequency_score": 6
    },
    {
        "id": 317,
        "topic": "Bigtable",
        "companies": [
            "Google",
            "Spotify"
        ],
        "question": "You are designing a Bigtable schema for social media posts. Queries will primarily be retrieve most recent events globally. Which row key design is optimal? ",
        "options": [
            "DeviceID#Date",
            "Date#DeviceID",
            "ReverseTimestamp#DeviceID",
            "Random#DeviceID"
        ],
        "answer": "ReverseTimestamp#DeviceID",
        "explanation": "Avoid starting with timestamp to prevent hotspots. Use EntityID first for entity-lookup queries. Use ReverseTimestamp for 'latest items' queries globally.",
        "frequency_score": 7
    },
    {
        "id": 318,
        "topic": "Algorithms",
        "companies": [
            "Google",
            "Amazon",
            "Microsoft"
        ],
        "question": "What is the time complexity of a Quick Sort algorithm in the worst case? ",
        "options": [
            "O(n log n)",
            "O(n^2)",
            "O(n)",
            "O(log n)"
        ],
        "answer": "O(n^2)",
        "explanation": "Merge Sort is O(n log n). Quick Sort is O(n^2) in worst case (though avg O(n log n)). Bubble Sort is O(n^2).",
        "frequency_score": 8
    },
    {
        "id": 319,
        "topic": "Bigtable",
        "companies": [
            "Google",
            "Spotify"
        ],
        "question": "You are designing a Bigtable schema for IoT events. Queries will primarily be retrieve latest events for a specific entity. Which row key design is optimal? ",
        "options": [
            "DeviceID#Date",
            "Date#DeviceID",
            "ReverseTimestamp#DeviceID",
            "Random#DeviceID"
        ],
        "answer": "DeviceID#Date",
        "explanation": "Avoid starting with timestamp to prevent hotspots. Use EntityID first for entity-lookup queries. Use ReverseTimestamp for 'latest items' queries globally.",
        "frequency_score": 7
    },
    {
        "id": 320,
        "topic": "Apache Spark",
        "companies": [
            "Google",
            "Databricks",
            "Amazon"
        ],
        "question": "In Spark, what is the difference between a Transformation and an Action? ",
        "options": [
            "Transformations are lazy, Actions match strict execution",
            "Actions are lazy, Transformations trigger execution",
            "They are the same",
            "Transformations save to disk, Actions read from disk"
        ],
        "answer": "Transformations are lazy, Actions match strict execution",
        "explanation": "Transformations (like map, filter) build the DAG but do not execute. Actions (like count, collect, save) trigger the actual computation.",
        "frequency_score": 6
    },
    {
        "id": 321,
        "topic": "Bigtable",
        "companies": [
            "Google",
            "Spotify"
        ],
        "question": "You are designing a Bigtable schema for social media posts. Queries will primarily be retrieve most recent events globally. Which row key design is optimal? ",
        "options": [
            "UserID#Timestamp",
            "Timestamp#UserID",
            "ReverseTimestamp#UserID",
            "Random#UserID"
        ],
        "answer": "ReverseTimestamp#UserID",
        "explanation": "Avoid starting with timestamp to prevent hotspots. Use EntityID first for entity-lookup queries. Use ReverseTimestamp for 'latest items' queries globally.",
        "frequency_score": 7
    },
    {
        "id": 322,
        "topic": "Bigtable",
        "companies": [
            "Google",
            "Spotify"
        ],
        "question": "You are designing a Bigtable schema for financial transactions. Queries will primarily be retrieve most recent events globally. Which row key design is optimal? ",
        "options": [
            "SensorID#Date",
            "Date#SensorID",
            "ReverseTimestamp#SensorID",
            "Random#SensorID"
        ],
        "answer": "ReverseTimestamp#SensorID",
        "explanation": "Avoid starting with timestamp to prevent hotspots. Use EntityID first for entity-lookup queries. Use ReverseTimestamp for 'latest items' queries globally.",
        "frequency_score": 7
    },
    {
        "id": 323,
        "topic": "Algorithms",
        "companies": [
            "Google",
            "Amazon",
            "Microsoft"
        ],
        "question": "What is the time complexity of a Bubble Sort algorithm in the worst case? ",
        "options": [
            "O(n log n)",
            "O(n^2)",
            "O(n)",
            "O(log n)"
        ],
        "answer": "O(n^2)",
        "explanation": "Merge Sort is O(n log n). Quick Sort is O(n^2) in worst case (though avg O(n log n)). Bubble Sort is O(n^2).",
        "frequency_score": 8
    },
    {
        "id": 324,
        "topic": "Data Structures",
        "companies": [
            "Google",
            "Amazon",
            "Microsoft",
            "Facebook"
        ],
        "question": "You need to implement a look-up service that checks if a user ID exists in a set of 1 billion users with O(1) average time complexity. Which data structure is best? ",
        "options": [
            "Hash Table / HashSet",
            "Binary Search Tree",
            "Linked List",
            "Array"
        ],
        "answer": "Hash Table / HashSet",
        "explanation": "Hash Tables provide O(1) average case lookup. BST is O(log n).",
        "frequency_score": 8
    },
    {
        "id": 325,
        "topic": "Data Structures",
        "companies": [
            "Google",
            "Amazon",
            "Microsoft",
            "Facebook"
        ],
        "question": "You need to implement a look-up service that checks if a user ID exists in a set of 1 billion users with O(1) average time complexity. Which data structure is best? ",
        "options": [
            "Hash Table / HashSet",
            "Binary Search Tree",
            "Linked List",
            "Array"
        ],
        "answer": "Hash Table / HashSet",
        "explanation": "Hash Tables provide O(1) average case lookup. BST is O(log n).",
        "frequency_score": 8
    },
    {
        "id": 326,
        "topic": "BigQuery",
        "companies": [
            "Google",
            "Spotify",
            "Twitter"
        ],
        "question": "You need to store 2 PB of sensor metrics data in BigQuery. The data is accessed once a quarter. Which storage class fits best to minimize costs?",
        "options": [
            "Active Storage",
            "Long-term Storage",
            "Nearline Storage",
            "Coldline Storage"
        ],
        "answer": "Active Storage",
        "explanation": "BigQuery Long-term storage applies automatically after 90 days of no modification, reducing price by ~50%.",
        "frequency_score": 10
    },
    {
        "id": 327,
        "topic": "Cloud Storage",
        "companies": [
            "Google",
            "Snapchat"
        ],
        "question": "You are designing a storage solution for regulatory archives. The requirement is access once a quarter. What storage class should you use? ",
        "options": [
            "Standard",
            "Nearline",
            "Coldline",
            "Archive"
        ],
        "answer": "Coldline",
        "explanation": "Standard for hot data. Nearline < 1/month. Coldline < 1/quarter. Archive < 1/year.",
        "frequency_score": 6
    },
    {
        "id": 328,
        "topic": "Data Structures",
        "companies": [
            "Google",
            "Amazon",
            "Microsoft",
            "Facebook"
        ],
        "question": "You need to implement a look-up service that checks if a user ID exists in a set of 1 billion users with O(log n) average time complexity. Which data structure is best? ",
        "options": [
            "Hash Table / HashSet",
            "Binary Search Tree",
            "Linked List",
            "Array"
        ],
        "answer": "Binary Search Tree",
        "explanation": "Hash Tables provide O(1) average case lookup. BST is O(log n).",
        "frequency_score": 8
    },
    {
        "id": 329,
        "topic": "Pub/Sub",
        "companies": [
            "Google",
            "Uber"
        ],
        "question": "Your application publishes high throughput messages to Pub/Sub. You observe increased end-to-end latency and growing backlog. What is the most likely cause? ",
        "options": [
            "Subscribers are too slow (backlog)",
            "Publisher quota exceeded",
            "Message size too large",
            "Ordering keys are causing hotspots"
        ],
        "answer": "Subscribers are too slow (backlog)",
        "explanation": "If using ordering keys, high throughput on a single key can limit scalability (1MB/s limit per key). Slow subscribers cause increased backlog.",
        "frequency_score": 7
    },
    {
        "id": 330,
        "topic": "Bigtable",
        "companies": [
            "Google",
            "Spotify"
        ],
        "question": "You are designing a Bigtable schema for IoT events. Queries will primarily be retrieve latest events for a specific entity. Which row key design is optimal? ",
        "options": [
            "DeviceID#Timestamp",
            "Timestamp#DeviceID",
            "ReverseTimestamp#DeviceID",
            "Random#DeviceID"
        ],
        "answer": "DeviceID#Timestamp",
        "explanation": "Avoid starting with timestamp to prevent hotspots. Use EntityID first for entity-lookup queries. Use ReverseTimestamp for 'latest items' queries globally.",
        "frequency_score": 7
    },
    {
        "id": 331,
        "topic": "Apache Spark",
        "companies": [
            "Google",
            "Databricks",
            "Amazon"
        ],
        "question": "In Spark, what is the difference between a Transformation and an Action? ",
        "options": [
            "Transformations are lazy, Actions match strict execution",
            "Actions are lazy, Transformations trigger execution",
            "They are the same",
            "Transformations save to disk, Actions read from disk"
        ],
        "answer": "Transformations are lazy, Actions match strict execution",
        "explanation": "Transformations (like map, filter) build the DAG but do not execute. Actions (like count, collect, save) trigger the actual computation.",
        "frequency_score": 6
    },
    {
        "id": 332,
        "topic": "Pub/Sub",
        "companies": [
            "Google",
            "Uber"
        ],
        "question": "Your application publishes high throughput messages to Pub/Sub. You observe throughput limits on specific keys. What is the most likely cause? ",
        "options": [
            "Subscribers are too slow (backlog)",
            "Publisher quota exceeded",
            "Message size too large",
            "Ordering keys are causing hotspots"
        ],
        "answer": "Ordering keys are causing hotspots",
        "explanation": "If using ordering keys, high throughput on a single key can limit scalability (1MB/s limit per key). Slow subscribers cause increased backlog.",
        "frequency_score": 7
    },
    {
        "id": 333,
        "topic": "IAM",
        "companies": [
            "Google"
        ],
        "question": "A developer needs to upload files to a bucket in a production project. Following the principle of least privilege, which role should you grant? ",
        "options": [
            "Viewer",
            "Editor",
            "Owner",
            "Cloud Functions Developer"
        ],
        "answer": "Cloud Functions Developer",
        "explanation": "Always prefer predefined specific roles (like BigQuery Data Viewer, Storage Object Admin) over basic roles (Viewer/Editor/Owner) to ensure least privilege.",
        "frequency_score": 9
    },
    {
        "id": 334,
        "topic": "Apache Kafka",
        "companies": [
            "Google",
            "LinkedIn",
            "Uber",
            "Netflix"
        ],
        "question": "You need to ensure strict ordering of messages in Kafka for a specific User ID. How should you configure the producer? ",
        "options": [
            "Use the User ID as the partition key",
            "Use a single partition for the entire topic",
            "Enable idempotent producer",
            "Increase replication factor"
        ],
        "answer": "Use the User ID as the partition key",
        "explanation": "Kafka guarantees ordering WITHIN a partition. Using the Entity ID as the key ensures all messages for that entity go to the same partition.",
        "frequency_score": 6
    },
    {
        "id": 335,
        "topic": "Bigtable",
        "companies": [
            "Google",
            "Spotify"
        ],
        "question": "You are designing a Bigtable schema for IoT events. Queries will primarily be retrieve latest events for a specific entity. Which row key design is optimal? ",
        "options": [
            "SensorID#Date",
            "Date#SensorID",
            "ReverseTimestamp#SensorID",
            "Random#SensorID"
        ],
        "answer": "SensorID#Date",
        "explanation": "Avoid starting with timestamp to prevent hotspots. Use EntityID first for entity-lookup queries. Use ReverseTimestamp for 'latest items' queries globally.",
        "frequency_score": 7
    },
    {
        "id": 336,
        "topic": "Dataflow",
        "companies": [
            "Google",
            "Spotify",
            "New York Times"
        ],
        "question": "You are building a streaming pipeline to process IoT temperature sensors. You need to handle rolling averages every minute for the last hour. What windowing strategy is appropriate? ",
        "options": [
            "Fixed Windows",
            "Sliding Windows",
            "Session Windows",
            "Global Windows"
        ],
        "answer": "Sliding Windows",
        "explanation": "Session windows gap-fill based on activity. Sliding windows overlap (e.g. every 5 min show last 1 hour). Fixed windows are tumbling.",
        "frequency_score": 9
    },
    {
        "id": 337,
        "topic": "Apache Spark",
        "companies": [
            "Google",
            "Databricks",
            "Amazon"
        ],
        "question": "In Spark, what is the difference between a Transformation and an Action? ",
        "options": [
            "Transformations are lazy, Actions match strict execution",
            "Actions are lazy, Transformations trigger execution",
            "They are the same",
            "Transformations save to disk, Actions read from disk"
        ],
        "answer": "Transformations are lazy, Actions match strict execution",
        "explanation": "Transformations (like map, filter) build the DAG but do not execute. Actions (like count, collect, save) trigger the actual computation.",
        "frequency_score": 6
    },
    {
        "id": 338,
        "topic": "Cloud Spanner",
        "companies": [
            "Google",
            "Uber",
            "Pokemon GO"
        ],
        "question": "You are designing a global banking ledger. You require strong consistency and horizontal scalability. Which database service should you choose? ",
        "options": [
            "Cloud Spanner",
            "Cloud SQL",
            "Bigtable",
            "Firestore"
        ],
        "answer": "Cloud Spanner",
        "explanation": "Cloud Spanner is the only service providing global strong consistency and horizontal scalability with relational semantics (SQL).",
        "frequency_score": 8
    },
    {
        "id": 339,
        "topic": "Bigtable",
        "companies": [
            "Google",
            "Spotify"
        ],
        "question": "You are designing a Bigtable schema for financial transactions. Queries will primarily be retrieve latest events for a specific entity. Which row key design is optimal? ",
        "options": [
            "SensorID#Timestamp",
            "Timestamp#SensorID",
            "ReverseTimestamp#SensorID",
            "Random#SensorID"
        ],
        "answer": "SensorID#Timestamp",
        "explanation": "Avoid starting with timestamp to prevent hotspots. Use EntityID first for entity-lookup queries. Use ReverseTimestamp for 'latest items' queries globally.",
        "frequency_score": 7
    },
    {
        "id": 340,
        "topic": "Cloud Storage",
        "companies": [
            "Google",
            "Snapchat"
        ],
        "question": "You are designing a storage solution for daily analytics content. The requirement is access once a quarter. What storage class should you use? ",
        "options": [
            "Standard",
            "Nearline",
            "Coldline",
            "Archive"
        ],
        "answer": "Coldline",
        "explanation": "Standard for hot data. Nearline < 1/month. Coldline < 1/quarter. Archive < 1/year.",
        "frequency_score": 6
    },
    {
        "id": 341,
        "topic": "Cloud Storage",
        "companies": [
            "Google",
            "Snapchat"
        ],
        "question": "You are designing a storage solution for profile pictures. The requirement is high frequency access. What storage class should you use? ",
        "options": [
            "Standard",
            "Nearline",
            "Coldline",
            "Archive"
        ],
        "answer": "Standard",
        "explanation": "Standard for hot data. Nearline < 1/month. Coldline < 1/quarter. Archive < 1/year.",
        "frequency_score": 6
    },
    {
        "id": 342,
        "topic": "BigQuery",
        "companies": [
            "Google",
            "Spotify",
            "Twitter"
        ],
        "question": "You need to store 50 TB of clickstream data data in BigQuery. The data is accessed daily. Which storage class fits best to minimize costs?",
        "options": [
            "Active Storage",
            "Long-term Storage",
            "Nearline Storage",
            "Coldline Storage"
        ],
        "answer": "Active Storage",
        "explanation": "BigQuery Long-term storage applies automatically after 90 days of no modification, reducing price by ~50%.",
        "frequency_score": 10
    },
    {
        "id": 343,
        "topic": "Apache Spark",
        "companies": [
            "Google",
            "Databricks",
            "Facebook",
            "Netflix"
        ],
        "question": "You are optimizing a Spark job that is suffering from data skew. You are joining a large skewed table with a small reference table. Which technique is most effective? ",
        "options": [
            "Salting the key",
            "Increasing the number of executors",
            "Using a larger instance type",
            "Broadcasting the large table"
        ],
        "answer": "Salting the key",
        "explanation": "Salting adds a random prefix to the skewed key to distribute it. Broadcasting is best for Skewed Joins where one table is small.",
        "frequency_score": 6
    },
    {
        "id": 344,
        "topic": "Pub/Sub",
        "companies": [
            "Google",
            "Uber"
        ],
        "question": "Your application publishes high throughput messages to Pub/Sub. You observe throughput limits on specific keys. What is the most likely cause? ",
        "options": [
            "Subscribers are too slow (backlog)",
            "Publisher quota exceeded",
            "Message size too large",
            "Ordering keys are causing hotspots"
        ],
        "answer": "Ordering keys are causing hotspots",
        "explanation": "If using ordering keys, high throughput on a single key can limit scalability (1MB/s limit per key). Slow subscribers cause increased backlog.",
        "frequency_score": 7
    },
    {
        "id": 345,
        "topic": "IAM",
        "companies": [
            "Google"
        ],
        "question": "A developer needs to deploy Cloud Functions in a production project. Following the principle of least privilege, which role should you grant? ",
        "options": [
            "Viewer",
            "Editor",
            "Owner",
            "BigQuery Data Viewer"
        ],
        "answer": "BigQuery Data Viewer",
        "explanation": "Always prefer predefined specific roles (like BigQuery Data Viewer, Storage Object Admin) over basic roles (Viewer/Editor/Owner) to ensure least privilege.",
        "frequency_score": 9
    },
    {
        "id": 346,
        "topic": "IAM",
        "companies": [
            "Google"
        ],
        "question": "A developer needs to deploy Cloud Functions in a production project. Following the principle of least privilege, which role should you grant? ",
        "options": [
            "Viewer",
            "Editor",
            "Owner",
            "BigQuery Data Viewer"
        ],
        "answer": "BigQuery Data Viewer",
        "explanation": "Always prefer predefined specific roles (like BigQuery Data Viewer, Storage Object Admin) over basic roles (Viewer/Editor/Owner) to ensure least privilege.",
        "frequency_score": 9
    },
    {
        "id": 347,
        "topic": "Data Structures",
        "companies": [
            "Google",
            "Amazon",
            "Microsoft",
            "Facebook"
        ],
        "question": "You need to implement a look-up service that checks if a user ID exists in a set of 1 billion users with O(log n) average time complexity. Which data structure is best? ",
        "options": [
            "Hash Table / HashSet",
            "Binary Search Tree",
            "Linked List",
            "Array"
        ],
        "answer": "Binary Search Tree",
        "explanation": "Hash Tables provide O(1) average case lookup. BST is O(log n).",
        "frequency_score": 8
    },
    {
        "id": 348,
        "topic": "Algorithms",
        "companies": [
            "Google",
            "Amazon",
            "Microsoft"
        ],
        "question": "What is the time complexity of a Quick Sort algorithm in the worst case? ",
        "options": [
            "O(n log n)",
            "O(n^2)",
            "O(n)",
            "O(log n)"
        ],
        "answer": "O(n^2)",
        "explanation": "Merge Sort is O(n log n). Quick Sort is O(n^2) in worst case (though avg O(n log n)). Bubble Sort is O(n^2).",
        "frequency_score": 8
    },
    {
        "id": 349,
        "topic": "Cloud Storage",
        "companies": [
            "Google",
            "Snapchat"
        ],
        "question": "You are designing a storage solution for profile pictures. The requirement is access once a quarter. What storage class should you use?",
        "options": [
            "Standard",
            "Nearline",
            "Coldline",
            "Archive"
        ],
        "answer": "Coldline",
        "explanation": "Standard for hot data. Nearline < 1/month. Coldline < 1/quarter. Archive < 1/year.",
        "frequency_score": 6
    },
    {
        "id": 350,
        "topic": "Dataflow",
        "companies": [
            "Google",
            "Spotify",
            "New York Times"
        ],
        "question": "You are building a streaming pipeline to process server logs. You need to handle hourly reporting. What windowing strategy is appropriate? ",
        "options": [
            "Fixed Windows",
            "Sliding Windows",
            "Session Windows",
            "Global Windows"
        ],
        "answer": "Fixed Windows",
        "explanation": "Session windows gap-fill based on activity. Sliding windows overlap (e.g. every 5 min show last 1 hour). Fixed windows are tumbling.",
        "frequency_score": 9
    },
    {
        "id": 351,
        "topic": "Data Structures",
        "companies": [
            "Google",
            "Amazon",
            "Microsoft",
            "Facebook"
        ],
        "question": "You need to implement a look-up service that checks if a user ID exists in a set of 1 billion users with O(log n) average time complexity. Which data structure is best? ",
        "options": [
            "Hash Table / HashSet",
            "Binary Search Tree",
            "Linked List",
            "Array"
        ],
        "answer": "Binary Search Tree",
        "explanation": "Hash Tables provide O(1) average case lookup. BST is O(log n).",
        "frequency_score": 8
    },
    {
        "id": 352,
        "topic": "Apache Spark",
        "companies": [
            "Google",
            "Databricks",
            "Amazon"
        ],
        "question": "In Spark, what is the difference between a Transformation and an Action? ",
        "options": [
            "Transformations are lazy, Actions match strict execution",
            "Actions are lazy, Transformations trigger execution",
            "They are the same",
            "Transformations save to disk, Actions read from disk"
        ],
        "answer": "Transformations are lazy, Actions match strict execution",
        "explanation": "Transformations (like map, filter) build the DAG but do not execute. Actions (like count, collect, save) trigger the actual computation.",
        "frequency_score": 6
    },
    {
        "id": 353,
        "topic": "Cloud Storage",
        "companies": [
            "Google",
            "Snapchat"
        ],
        "question": "You are designing a storage solution for daily analytics content. The requirement is access once a month. What storage class should you use? ",
        "options": [
            "Standard",
            "Nearline",
            "Coldline",
            "Archive"
        ],
        "answer": "Nearline",
        "explanation": "Standard for hot data. Nearline < 1/month. Coldline < 1/quarter. Archive < 1/year.",
        "frequency_score": 6
    },
    {
        "id": 354,
        "topic": "Algorithms",
        "companies": [
            "Google",
            "Amazon",
            "Microsoft"
        ],
        "question": "What is the time complexity of a Bubble Sort algorithm in the worst case? ",
        "options": [
            "O(n log n)",
            "O(n^2)",
            "O(n)",
            "O(log n)"
        ],
        "answer": "O(n^2)",
        "explanation": "Merge Sort is O(n log n). Quick Sort is O(n^2) in worst case (though avg O(n log n)). Bubble Sort is O(n^2).",
        "frequency_score": 8
    },
    {
        "id": 355,
        "topic": "Apache Kafka",
        "companies": [
            "Google",
            "LinkedIn"
        ],
        "question": "What happens if a Kafka Consumer Group has more consumers than partitions in the topic? ",
        "options": [
            "Some consumers will be idle",
            "Throughput increases linearly",
            "Kafka automatically creates more partitions",
            "The extra consumers duplicate the data"
        ],
        "answer": "Some consumers will be idle",
        "explanation": "A partition can be consumed by only one consumer within a group at a time. Extra consumers stay idle.",
        "frequency_score": 6
    },
    {
        "id": 356,
        "topic": "Dataflow",
        "companies": [
            "Google",
            "Spotify",
            "New York Times"
        ],
        "question": "You are building a streaming pipeline to process IoT temperature sensors. You need to handle hourly reporting. What windowing strategy is appropriate? ",
        "options": [
            "Fixed Windows",
            "Sliding Windows",
            "Session Windows",
            "Global Windows"
        ],
        "answer": "Fixed Windows",
        "explanation": "Session windows gap-fill based on activity. Sliding windows overlap (e.g. every 5 min show last 1 hour). Fixed windows are tumbling.",
        "frequency_score": 9
    },
    {
        "id": 357,
        "topic": "Algorithms",
        "companies": [
            "Google",
            "Amazon",
            "Microsoft"
        ],
        "question": "What is the time complexity of a Merge Sort algorithm in the worst case? ",
        "options": [
            "O(n log n)",
            "O(n^2)",
            "O(n)",
            "O(log n)"
        ],
        "answer": "O(n log n)",
        "explanation": "Merge Sort is O(n log n). Quick Sort is O(n^2) in worst case (though avg O(n log n)). Bubble Sort is O(n^2).",
        "frequency_score": 8
    },
    {
        "id": 358,
        "topic": "Apache Kafka",
        "companies": [
            "Google",
            "LinkedIn",
            "Uber",
            "Netflix"
        ],
        "question": "You need to ensure strict ordering of messages in Kafka for a specific Transaction ID. How should you configure the producer? ",
        "options": [
            "Use the Transaction ID as the partition key",
            "Use a single partition for the entire topic",
            "Enable idempotent producer",
            "Increase replication factor"
        ],
        "answer": "Use the Transaction ID as the partition key",
        "explanation": "Kafka guarantees ordering WITHIN a partition. Using the Entity ID as the key ensures all messages for that entity go to the same partition.",
        "frequency_score": 6
    },
    {
        "id": 359,
        "topic": "Dataflow",
        "companies": [
            "Google",
            "Spotify",
            "New York Times"
        ],
        "question": "You are building a streaming pipeline to process user clickstreams. You need to handle periods of user activity separated by gaps. What windowing strategy is appropriate? ",
        "options": [
            "Fixed Windows",
            "Sliding Windows",
            "Session Windows",
            "Global Windows"
        ],
        "answer": "Session Windows",
        "explanation": "Session windows gap-fill based on activity. Sliding windows overlap (e.g. every 5 min show last 1 hour). Fixed windows are tumbling.",
        "frequency_score": 9
    },
    {
        "id": 360,
        "topic": "Pub/Sub",
        "companies": [
            "Google",
            "Uber"
        ],
        "question": "Your application publishes 1 million/sec messages to Pub/Sub. You observe increased end-to-end latency and growing backlog. What is the most likely cause? ",
        "options": [
            "Subscribers are too slow (backlog)",
            "Publisher quota exceeded",
            "Message size too large",
            "Ordering keys are causing hotspots"
        ],
        "answer": "Subscribers are too slow (backlog)",
        "explanation": "If using ordering keys, high throughput on a single key can limit scalability (1MB/s limit per key). Slow subscribers cause increased backlog.",
        "frequency_score": 7
    },
    {
        "id": 361,
        "topic": "BigQuery",
        "companies": [
            "Google",
            "Spotify",
            "Twitter"
        ],
        "question": "You need to store 2 PB of sensor metrics data in BigQuery. The data is accessed daily. Which storage class fits best to minimize costs?",
        "options": [
            "Active Storage",
            "Long-term Storage",
            "Nearline Storage",
            "Coldline Storage"
        ],
        "answer": "Active Storage",
        "explanation": "BigQuery Long-term storage applies automatically after 90 days of no modification, reducing price by ~50%.",
        "frequency_score": 10
    },
    {
        "id": 362,
        "topic": "Cloud Spanner",
        "companies": [
            "Google",
            "Uber",
            "Pokemon GO"
        ],
        "question": "You are designing a global banking ledger. You require strong consistency and horizontal scalability. Which database service should you choose? ",
        "options": [
            "Cloud Spanner",
            "Cloud SQL",
            "Bigtable",
            "Firestore"
        ],
        "answer": "Cloud Spanner",
        "explanation": "Cloud Spanner is the only service providing global strong consistency and horizontal scalability with relational semantics (SQL).",
        "frequency_score": 8
    },
    {
        "id": 363,
        "topic": "Apache Spark",
        "companies": [
            "Google",
            "Databricks",
            "Facebook",
            "Netflix"
        ],
        "question": "You are optimizing a Spark job that is suffering from data skew. One task takes 10x longer than others during a wide transformation. Which technique is most effective? ",
        "options": [
            "Salting the key",
            "Increasing the number of executors",
            "Using a larger instance type",
            "Broadcasting the large table"
        ],
        "answer": "Salting the key",
        "explanation": "Salting adds a random prefix to the skewed key to distribute it. Broadcasting is best for Skewed Joins where one table is small.",
        "frequency_score": 6
    },
    {
        "id": 364,
        "topic": "Cloud Storage",
        "companies": [
            "Google",
            "Snapchat"
        ],
        "question": "You are designing a storage solution for profile pictures. The requirement is access once a quarter. What storage class should you use? ",
        "options": [
            "Standard",
            "Nearline",
            "Coldline",
            "Archive"
        ],
        "answer": "Coldline",
        "explanation": "Standard for hot data. Nearline < 1/month. Coldline < 1/quarter. Archive < 1/year.",
        "frequency_score": 6
    },
    {
        "id": 365,
        "topic": "BigQuery",
        "companies": [
            "Google",
            "Spotify",
            "Twitter"
        ],
        "question": "You need to store 50 TB of clickstream data data in BigQuery. The data is accessed continuously. Which storage class fits best to minimize costs?",
        "options": [
            "Active Storage",
            "Long-term Storage",
            "Nearline Storage",
            "Coldline Storage"
        ],
        "answer": "Active Storage",
        "explanation": "BigQuery Long-term storage applies automatically after 90 days of no modification, reducing price by ~50%.",
        "frequency_score": 10
    },
    {
        "id": 366,
        "topic": "Cloud Spanner",
        "companies": [
            "Google",
            "Uber",
            "Pokemon GO"
        ],
        "question": "You are designing a global banking ledger. You require strong consistency and horizontal scalability. Which database service should you choose? ",
        "options": [
            "Cloud Spanner",
            "Cloud SQL",
            "Bigtable",
            "Firestore"
        ],
        "answer": "Cloud Spanner",
        "explanation": "Cloud Spanner is the only service providing global strong consistency and horizontal scalability with relational semantics (SQL).",
        "frequency_score": 8
    },
    {
        "id": 367,
        "topic": "Apache Kafka",
        "companies": [
            "Google",
            "LinkedIn",
            "Uber",
            "Netflix"
        ],
        "question": "You need to ensure strict ordering of messages in Kafka for a specific Transaction ID. How should you configure the producer? ",
        "options": [
            "Use the Transaction ID as the partition key",
            "Use a single partition for the entire topic",
            "Enable idempotent producer",
            "Increase replication factor"
        ],
        "answer": "Use the Transaction ID as the partition key",
        "explanation": "Kafka guarantees ordering WITHIN a partition. Using the Entity ID as the key ensures all messages for that entity go to the same partition.",
        "frequency_score": 6
    },
    {
        "id": 368,
        "topic": "Cloud Spanner",
        "companies": [
            "Google",
            "Uber",
            "Pokemon GO"
        ],
        "question": "You are designing a global banking ledger. You require strong consistency and horizontal scalability. Which database service should you choose? ",
        "options": [
            "Cloud Spanner",
            "Cloud SQL",
            "Bigtable",
            "Firestore"
        ],
        "answer": "Cloud Spanner",
        "explanation": "Cloud Spanner is the only service providing global strong consistency and horizontal scalability with relational semantics (SQL).",
        "frequency_score": 8
    },
    {
        "id": 369,
        "topic": "Algorithms",
        "companies": [
            "Google",
            "Amazon",
            "Microsoft"
        ],
        "question": "What is the time complexity of a Bubble Sort algorithm in the worst case? ",
        "options": [
            "O(n log n)",
            "O(n^2)",
            "O(n)",
            "O(log n)"
        ],
        "answer": "O(n^2)",
        "explanation": "Merge Sort is O(n log n). Quick Sort is O(n^2) in worst case (though avg O(n log n)). Bubble Sort is O(n^2).",
        "frequency_score": 8
    },
    {
        "id": 370,
        "topic": "Dataflow",
        "companies": [
            "Google",
            "Spotify",
            "New York Times"
        ],
        "question": "You are building a streaming pipeline to process user clickstreams. You need to handle rolling averages every minute for the last hour. What windowing strategy is appropriate? ",
        "options": [
            "Fixed Windows",
            "Sliding Windows",
            "Session Windows",
            "Global Windows"
        ],
        "answer": "Sliding Windows",
        "explanation": "Session windows gap-fill based on activity. Sliding windows overlap (e.g. every 5 min show last 1 hour). Fixed windows are tumbling.",
        "frequency_score": 9
    },
    {
        "id": 371,
        "topic": "BigQuery",
        "companies": [
            "Google",
            "Spotify",
            "Twitter"
        ],
        "question": "You need to store 1 PB of audit logs data in BigQuery. The data is accessed daily. Which storage class fits best to minimize costs?",
        "options": [
            "Active Storage",
            "Long-term Storage",
            "Nearline Storage",
            "Coldline Storage"
        ],
        "answer": "Active Storage",
        "explanation": "BigQuery Long-term storage applies automatically after 90 days of no modification, reducing price by ~50%.",
        "frequency_score": 10
    },
    {
        "id": 372,
        "topic": "Cloud Spanner",
        "companies": [
            "Google",
            "Uber",
            "Pokemon GO"
        ],
        "question": "You are designing a global banking ledger. You require strong consistency and 99.999% availability. Which database service should you choose? ",
        "options": [
            "Cloud Spanner",
            "Cloud SQL",
            "Bigtable",
            "Firestore"
        ],
        "answer": "Cloud Spanner",
        "explanation": "Cloud Spanner is the only service providing global strong consistency and horizontal scalability with relational semantics (SQL).",
        "frequency_score": 8
    },
    {
        "id": 373,
        "topic": "Pub/Sub",
        "companies": [
            "Google",
            "Uber"
        ],
        "question": "Your application publishes 1 million/sec messages to Pub/Sub. You observe throughput limits on specific keys. What is the most likely cause? ",
        "options": [
            "Subscribers are too slow (backlog)",
            "Publisher quota exceeded",
            "Message size too large",
            "Ordering keys are causing hotspots"
        ],
        "answer": "Ordering keys are causing hotspots",
        "explanation": "If using ordering keys, high throughput on a single key can limit scalability (1MB/s limit per key). Slow subscribers cause increased backlog.",
        "frequency_score": 7
    },
    {
        "id": 374,
        "topic": "Apache Spark",
        "companies": [
            "Google",
            "Databricks",
            "Amazon"
        ],
        "question": "In Spark, what is the difference between a Transformation and an Action? ",
        "options": [
            "Transformations are lazy, Actions match strict execution",
            "Actions are lazy, Transformations trigger execution",
            "They are the same",
            "Transformations save to disk, Actions read from disk"
        ],
        "answer": "Transformations are lazy, Actions match strict execution",
        "explanation": "Transformations (like map, filter) build the DAG but do not execute. Actions (like count, collect, save) trigger the actual computation.",
        "frequency_score": 6
    },
    {
        "id": 375,
        "topic": "Pub/Sub",
        "companies": [
            "Google",
            "Uber"
        ],
        "question": "Your application publishes high throughput messages to Pub/Sub. You observe throughput limits on specific keys. What is the most likely cause? ",
        "options": [
            "Subscribers are too slow (backlog)",
            "Publisher quota exceeded",
            "Message size too large",
            "Ordering keys are causing hotspots"
        ],
        "answer": "Ordering keys are causing hotspots",
        "explanation": "If using ordering keys, high throughput on a single key can limit scalability (1MB/s limit per key). Slow subscribers cause increased backlog.",
        "frequency_score": 7
    },
    {
        "id": 376,
        "topic": "Cloud Storage",
        "companies": [
            "Google",
            "Snapchat"
        ],
        "question": "You are designing a storage solution for regulatory archives. The requirement is access once a month. What storage class should you use? ",
        "options": [
            "Standard",
            "Nearline",
            "Coldline",
            "Archive"
        ],
        "answer": "Nearline",
        "explanation": "Standard for hot data. Nearline < 1/month. Coldline < 1/quarter. Archive < 1/year.",
        "frequency_score": 6
    },
    {
        "id": 377,
        "topic": "Cloud Spanner",
        "companies": [
            "Google",
            "Uber",
            "Pokemon GO"
        ],
        "question": "You are designing a global banking ledger. You require strong consistency and 99.999% availability. Which database service should you choose? ",
        "options": [
            "Cloud Spanner",
            "Cloud SQL",
            "Bigtable",
            "Firestore"
        ],
        "answer": "Cloud Spanner",
        "explanation": "Cloud Spanner is the only service providing global strong consistency and horizontal scalability with relational semantics (SQL).",
        "frequency_score": 8
    },
    {
        "id": 378,
        "topic": "Apache Kafka",
        "companies": [
            "Google",
            "LinkedIn",
            "Uber",
            "Netflix"
        ],
        "question": "You need to ensure strict ordering of messages in Kafka for a specific User ID. How should you configure the producer? ",
        "options": [
            "Use the User ID as the partition key",
            "Use a single partition for the entire topic",
            "Enable idempotent producer",
            "Increase replication factor"
        ],
        "answer": "Use the User ID as the partition key",
        "explanation": "Kafka guarantees ordering WITHIN a partition. Using the Entity ID as the key ensures all messages for that entity go to the same partition.",
        "frequency_score": 6
    },
    {
        "id": 379,
        "topic": "Cloud Storage",
        "companies": [
            "Google",
            "Snapchat"
        ],
        "question": "You are designing a storage solution for profile pictures. The requirement is access once a year. What storage class should you use?",
        "options": [
            "Standard",
            "Nearline",
            "Coldline",
            "Archive"
        ],
        "answer": "Archive",
        "explanation": "Standard for hot data. Nearline < 1/month. Coldline < 1/quarter. Archive < 1/year.",
        "frequency_score": 6
    },
    {
        "id": 380,
        "topic": "Algorithms",
        "companies": [
            "Google",
            "Amazon",
            "Microsoft"
        ],
        "question": "What is the time complexity of a Quick Sort algorithm in the worst case? ",
        "options": [
            "O(n log n)",
            "O(n^2)",
            "O(n)",
            "O(log n)"
        ],
        "answer": "O(n^2)",
        "explanation": "Merge Sort is O(n log n). Quick Sort is O(n^2) in worst case (though avg O(n log n)). Bubble Sort is O(n^2).",
        "frequency_score": 8
    },
    {
        "id": 381,
        "topic": "Cloud Spanner",
        "companies": [
            "Google",
            "Uber",
            "Pokemon GO"
        ],
        "question": "You are designing a global banking ledger. You require strong consistency and 99.999% availability. Which database service should you choose? ",
        "options": [
            "Cloud Spanner",
            "Cloud SQL",
            "Bigtable",
            "Firestore"
        ],
        "answer": "Cloud Spanner",
        "explanation": "Cloud Spanner is the only service providing global strong consistency and horizontal scalability with relational semantics (SQL).",
        "frequency_score": 8
    },
    {
        "id": 382,
        "topic": "Cloud Storage",
        "companies": [
            "Google",
            "Snapchat"
        ],
        "question": "You are designing a storage solution for profile pictures. The requirement is high frequency access. What storage class should you use? ",
        "options": [
            "Standard",
            "Nearline",
            "Coldline",
            "Archive"
        ],
        "answer": "Standard",
        "explanation": "Standard for hot data. Nearline < 1/month. Coldline < 1/quarter. Archive < 1/year.",
        "frequency_score": 6
    },
    {
        "id": 383,
        "topic": "Pub/Sub",
        "companies": [
            "Google",
            "Uber"
        ],
        "question": "Your application publishes high throughput messages to Pub/Sub. You observe throughput limits on specific keys. What is the most likely cause? ",
        "options": [
            "Subscribers are too slow (backlog)",
            "Publisher quota exceeded",
            "Message size too large",
            "Ordering keys are causing hotspots"
        ],
        "answer": "Ordering keys are causing hotspots",
        "explanation": "If using ordering keys, high throughput on a single key can limit scalability (1MB/s limit per key). Slow subscribers cause increased backlog.",
        "frequency_score": 7
    },
    {
        "id": 384,
        "topic": "IAM",
        "companies": [
            "Google"
        ],
        "question": "A developer needs to upload files to a bucket in a production project. Following the principle of least privilege, which role should you grant? ",
        "options": [
            "Viewer",
            "Editor",
            "Owner",
            "Cloud Functions Developer"
        ],
        "answer": "Cloud Functions Developer",
        "explanation": "Always prefer predefined specific roles (like BigQuery Data Viewer, Storage Object Admin) over basic roles (Viewer/Editor/Owner) to ensure least privilege.",
        "frequency_score": 9
    },
    {
        "id": 385,
        "topic": "Bigtable",
        "companies": [
            "Google",
            "Spotify"
        ],
        "question": "You are designing a Bigtable schema for social media posts. Queries will primarily be retrieve latest events for a specific entity. Which row key design is optimal? ",
        "options": [
            "DeviceID#Date",
            "Date#DeviceID",
            "ReverseTimestamp#DeviceID",
            "Random#DeviceID"
        ],
        "answer": "DeviceID#Date",
        "explanation": "Avoid starting with timestamp to prevent hotspots. Use EntityID first for entity-lookup queries. Use ReverseTimestamp for 'latest items' queries globally.",
        "frequency_score": 7
    },
    {
        "id": 386,
        "topic": "Data Structures",
        "companies": [
            "Google",
            "Amazon",
            "Microsoft",
            "Facebook"
        ],
        "question": "You need to implement a look-up service that checks if a user ID exists in a set of 1 billion users with O(1) average time complexity. Which data structure is best? ",
        "options": [
            "Hash Table / HashSet",
            "Binary Search Tree",
            "Linked List",
            "Array"
        ],
        "answer": "Hash Table / HashSet",
        "explanation": "Hash Tables provide O(1) average case lookup. BST is O(log n).",
        "frequency_score": 8
    },
    {
        "id": 387,
        "topic": "Dataflow",
        "companies": [
            "Google",
            "Spotify",
            "New York Times"
        ],
        "question": "You are building a streaming pipeline to process server logs. You need to handle rolling averages every minute for the last hour. What windowing strategy is appropriate? ",
        "options": [
            "Fixed Windows",
            "Sliding Windows",
            "Session Windows",
            "Global Windows"
        ],
        "answer": "Sliding Windows",
        "explanation": "Session windows gap-fill based on activity. Sliding windows overlap (e.g. every 5 min show last 1 hour). Fixed windows are tumbling.",
        "frequency_score": 9
    },
    {
        "id": 388,
        "topic": "Apache Kafka",
        "companies": [
            "Google",
            "LinkedIn",
            "Uber",
            "Netflix"
        ],
        "question": "You need to ensure strict ordering of messages in Kafka for a specific Transaction ID. How should you configure the producer? ",
        "options": [
            "Use the Transaction ID as the partition key",
            "Use a single partition for the entire topic",
            "Enable idempotent producer",
            "Increase replication factor"
        ],
        "answer": "Use the Transaction ID as the partition key",
        "explanation": "Kafka guarantees ordering WITHIN a partition. Using the Entity ID as the key ensures all messages for that entity go to the same partition.",
        "frequency_score": 6
    },
    {
        "id": 389,
        "topic": "Apache Kafka",
        "companies": [
            "Google",
            "LinkedIn",
            "Uber",
            "Netflix"
        ],
        "question": "You need to ensure strict ordering of messages in Kafka for a specific Transaction ID. How should you configure the producer? ",
        "options": [
            "Use the Transaction ID as the partition key",
            "Use a single partition for the entire topic",
            "Enable idempotent producer",
            "Increase replication factor"
        ],
        "answer": "Use the Transaction ID as the partition key",
        "explanation": "Kafka guarantees ordering WITHIN a partition. Using the Entity ID as the key ensures all messages for that entity go to the same partition.",
        "frequency_score": 6
    },
    {
        "id": 390,
        "topic": "Bigtable",
        "companies": [
            "Google",
            "Spotify"
        ],
        "question": "You are designing a Bigtable schema for IoT events. Queries will primarily be retrieve latest events for a specific entity. Which row key design is optimal? ",
        "options": [
            "SensorID#Date",
            "Date#SensorID",
            "ReverseTimestamp#SensorID",
            "Random#SensorID"
        ],
        "answer": "SensorID#Date",
        "explanation": "Avoid starting with timestamp to prevent hotspots. Use EntityID first for entity-lookup queries. Use ReverseTimestamp for 'latest items' queries globally.",
        "frequency_score": 7
    },
    {
        "id": 391,
        "topic": "Apache Kafka",
        "companies": [
            "Google",
            "LinkedIn"
        ],
        "question": "What happens if a Kafka Consumer Group has more consumers than partitions in the topic? ",
        "options": [
            "Some consumers will be idle",
            "Throughput increases linearly",
            "Kafka automatically creates more partitions",
            "The extra consumers duplicate the data"
        ],
        "answer": "Some consumers will be idle",
        "explanation": "A partition can be consumed by only one consumer within a group at a time. Extra consumers stay idle.",
        "frequency_score": 6
    },
    {
        "id": 392,
        "topic": "Dataflow",
        "companies": [
            "Google",
            "Spotify",
            "New York Times"
        ],
        "question": "You are building a streaming pipeline to process user clickstreams. You need to handle periods of user activity separated by gaps. What windowing strategy is appropriate? ",
        "options": [
            "Fixed Windows",
            "Sliding Windows",
            "Session Windows",
            "Global Windows"
        ],
        "answer": "Session Windows",
        "explanation": "Session windows gap-fill based on activity. Sliding windows overlap (e.g. every 5 min show last 1 hour). Fixed windows are tumbling.",
        "frequency_score": 9
    },
    {
        "id": 393,
        "topic": "Apache Spark",
        "companies": [
            "Google",
            "Databricks",
            "Amazon"
        ],
        "question": "In Spark, what is the difference between a Transformation and an Action? ",
        "options": [
            "Transformations are lazy, Actions match strict execution",
            "Actions are lazy, Transformations trigger execution",
            "They are the same",
            "Transformations save to disk, Actions read from disk"
        ],
        "answer": "Transformations are lazy, Actions match strict execution",
        "explanation": "Transformations (like map, filter) build the DAG but do not execute. Actions (like count, collect, save) trigger the actual computation.",
        "frequency_score": 6
    },
    {
        "id": 394,
        "topic": "Apache Kafka",
        "companies": [
            "Google",
            "LinkedIn"
        ],
        "question": "What happens if a Kafka Consumer Group has more consumers than partitions in the topic? ",
        "options": [
            "Some consumers will be idle",
            "Throughput increases linearly",
            "Kafka automatically creates more partitions",
            "The extra consumers duplicate the data"
        ],
        "answer": "Some consumers will be idle",
        "explanation": "A partition can be consumed by only one consumer within a group at a time. Extra consumers stay idle.",
        "frequency_score": 6
    },
    {
        "id": 395,
        "topic": "Algorithms",
        "companies": [
            "Google",
            "Amazon",
            "Microsoft"
        ],
        "question": "What is the time complexity of a Merge Sort algorithm in the worst case? ",
        "options": [
            "O(n log n)",
            "O(n^2)",
            "O(n)",
            "O(log n)"
        ],
        "answer": "O(n log n)",
        "explanation": "Merge Sort is O(n log n). Quick Sort is O(n^2) in worst case (though avg O(n log n)). Bubble Sort is O(n^2).",
        "frequency_score": 8
    },
    {
        "id": 396,
        "topic": "Apache Spark",
        "companies": [
            "Google",
            "Databricks",
            "Amazon"
        ],
        "question": "In Spark, what is the difference between a Transformation and an Action? ",
        "options": [
            "Transformations are lazy, Actions match strict execution",
            "Actions are lazy, Transformations trigger execution",
            "They are the same",
            "Transformations save to disk, Actions read from disk"
        ],
        "answer": "Transformations are lazy, Actions match strict execution",
        "explanation": "Transformations (like map, filter) build the DAG but do not execute. Actions (like count, collect, save) trigger the actual computation.",
        "frequency_score": 6
    },
    {
        "id": 397,
        "topic": "Apache Kafka",
        "companies": [
            "Google",
            "LinkedIn"
        ],
        "question": "What happens if a Kafka Consumer Group has more consumers than partitions in the topic? ",
        "options": [
            "Some consumers will be idle",
            "Throughput increases linearly",
            "Kafka automatically creates more partitions",
            "The extra consumers duplicate the data"
        ],
        "answer": "Some consumers will be idle",
        "explanation": "A partition can be consumed by only one consumer within a group at a time. Extra consumers stay idle.",
        "frequency_score": 6
    },
    {
        "id": 398,
        "topic": "IAM",
        "companies": [
            "Google"
        ],
        "question": "A developer needs to upload files to a bucket in a production project. Following the principle of least privilege, which role should you grant? ",
        "options": [
            "Viewer",
            "Editor",
            "Owner",
            "Storage Object Creator"
        ],
        "answer": "Storage Object Creator",
        "explanation": "Always prefer predefined specific roles (like BigQuery Data Viewer, Storage Object Admin) over basic roles (Viewer/Editor/Owner) to ensure least privilege.",
        "frequency_score": 9
    },
    {
        "id": 399,
        "topic": "Bigtable",
        "companies": [
            "Google",
            "Spotify"
        ],
        "question": "You are designing a Bigtable schema for social media posts. Queries will primarily be retrieve most recent events globally. Which row key design is optimal? ",
        "options": [
            "SensorID#Date",
            "Date#SensorID",
            "ReverseTimestamp#SensorID",
            "Random#SensorID"
        ],
        "answer": "ReverseTimestamp#SensorID",
        "explanation": "Avoid starting with timestamp to prevent hotspots. Use EntityID first for entity-lookup queries. Use ReverseTimestamp for 'latest items' queries globally.",
        "frequency_score": 7
    },
    {
        "id": 400,
        "topic": "Apache Kafka",
        "companies": [
            "Google",
            "LinkedIn"
        ],
        "question": "What happens if a Kafka Consumer Group has more consumers than partitions in the topic? ",
        "options": [
            "Some consumers will be idle",
            "Throughput increases linearly",
            "Kafka automatically creates more partitions",
            "The extra consumers duplicate the data"
        ],
        "answer": "Some consumers will be idle",
        "explanation": "A partition can be consumed by only one consumer within a group at a time. Extra consumers stay idle.",
        "frequency_score": 6
    },
    {
        "id": 401,
        "topic": "Apache Kafka",
        "companies": [
            "Google",
            "LinkedIn"
        ],
        "question": "What happens if a Kafka Consumer Group has more consumers than partitions in the topic? ",
        "options": [
            "Some consumers will be idle",
            "Throughput increases linearly",
            "Kafka automatically creates more partitions",
            "The extra consumers duplicate the data"
        ],
        "answer": "Some consumers will be idle",
        "explanation": "A partition can be consumed by only one consumer within a group at a time. Extra consumers stay idle.",
        "frequency_score": 6
    },
    {
        "id": 402,
        "topic": "IAM",
        "companies": [
            "Google"
        ],
        "question": "A developer needs to upload files to a bucket in a production project. Following the principle of least privilege, which role should you grant? ",
        "options": [
            "Viewer",
            "Editor",
            "Owner",
            "Storage Object Creator"
        ],
        "answer": "Storage Object Creator",
        "explanation": "Always prefer predefined specific roles (like BigQuery Data Viewer, Storage Object Admin) over basic roles (Viewer/Editor/Owner) to ensure least privilege.",
        "frequency_score": 9
    },
    {
        "id": 403,
        "topic": "BigQuery",
        "companies": [
            "Google",
            "Spotify",
            "Twitter"
        ],
        "question": "You need to store 50 TB of clickstream data data in BigQuery. The data is accessed once a quarter. Which storage class fits best to minimize costs?",
        "options": [
            "Active Storage",
            "Long-term Storage",
            "Nearline Storage",
            "Coldline Storage"
        ],
        "answer": "Active Storage",
        "explanation": "BigQuery Long-term storage applies automatically after 90 days of no modification, reducing price by ~50%.",
        "frequency_score": 10
    },
    {
        "id": 404,
        "topic": "Apache Spark",
        "companies": [
            "Google",
            "Databricks",
            "Amazon"
        ],
        "question": "In Spark, what is the difference between a Transformation and an Action? ",
        "options": [
            "Transformations are lazy, Actions match strict execution",
            "Actions are lazy, Transformations trigger execution",
            "They are the same",
            "Transformations save to disk, Actions read from disk"
        ],
        "answer": "Transformations are lazy, Actions match strict execution",
        "explanation": "Transformations (like map, filter) build the DAG but do not execute. Actions (like count, collect, save) trigger the actual computation.",
        "frequency_score": 6
    },
    {
        "id": 405,
        "topic": "Algorithms",
        "companies": [
            "Google",
            "Amazon",
            "Microsoft"
        ],
        "question": "What is the time complexity of a Quick Sort algorithm in the worst case? ",
        "options": [
            "O(n log n)",
            "O(n^2)",
            "O(n)",
            "O(log n)"
        ],
        "answer": "O(n^2)",
        "explanation": "Merge Sort is O(n log n). Quick Sort is O(n^2) in worst case (though avg O(n log n)). Bubble Sort is O(n^2).",
        "frequency_score": 8
    },
    {
        "id": 406,
        "topic": "Cloud Storage",
        "companies": [
            "Google",
            "Snapchat"
        ],
        "question": "You are designing a storage solution for regulatory archives. The requirement is high frequency access. What storage class should you use? ",
        "options": [
            "Standard",
            "Nearline",
            "Coldline",
            "Archive"
        ],
        "answer": "Standard",
        "explanation": "Standard for hot data. Nearline < 1/month. Coldline < 1/quarter. Archive < 1/year.",
        "frequency_score": 6
    },
    {
        "id": 407,
        "topic": "Apache Kafka",
        "companies": [
            "Google",
            "LinkedIn",
            "Uber",
            "Netflix"
        ],
        "question": "You need to ensure strict ordering of messages in Kafka for a specific Device ID. How should you configure the producer? ",
        "options": [
            "Use the Device ID as the partition key",
            "Use a single partition for the entire topic",
            "Enable idempotent producer",
            "Increase replication factor"
        ],
        "answer": "Use the Device ID as the partition key",
        "explanation": "Kafka guarantees ordering WITHIN a partition. Using the Entity ID as the key ensures all messages for that entity go to the same partition.",
        "frequency_score": 6
    },
    {
        "id": 408,
        "topic": "BigQuery",
        "companies": [
            "Google",
            "Spotify",
            "Twitter"
        ],
        "question": "You need to store 500 TB of clickstream data data in BigQuery. The data is accessed rarely (every 6 months). Which storage class fits best to minimize costs?",
        "options": [
            "Active Storage",
            "Long-term Storage",
            "Nearline Storage",
            "Coldline Storage"
        ],
        "answer": "Long-term Storage",
        "explanation": "BigQuery Long-term storage applies automatically after 90 days of no modification, reducing price by ~50%.",
        "frequency_score": 10
    },
    {
        "id": 409,
        "topic": "BigQuery",
        "companies": [
            "Google",
            "Spotify",
            "Twitter"
        ],
        "question": "You need to store 50 TB of clickstream data data in BigQuery. The data is accessed continuously. Which storage class fits best to minimize costs? ",
        "options": [
            "Active Storage",
            "Long-term Storage",
            "Nearline Storage",
            "Coldline Storage"
        ],
        "answer": "Active Storage",
        "explanation": "BigQuery Long-term storage applies automatically after 90 days of no modification, reducing price by ~50%.",
        "frequency_score": 10
    },
    {
        "id": 410,
        "topic": "IAM",
        "companies": [
            "Google"
        ],
        "question": "A developer needs to view BigQuery datasets in a production project. Following the principle of least privilege, which role should you grant? ",
        "options": [
            "Viewer",
            "Editor",
            "Owner",
            "Storage Object Creator"
        ],
        "answer": "Storage Object Creator",
        "explanation": "Always prefer predefined specific roles (like BigQuery Data Viewer, Storage Object Admin) over basic roles (Viewer/Editor/Owner) to ensure least privilege.",
        "frequency_score": 9
    },
    {
        "id": 411,
        "topic": "Cloud Storage",
        "companies": [
            "Google",
            "Snapchat"
        ],
        "question": "You are designing a storage solution for daily analytics content. The requirement is access once a year. What storage class should you use? ",
        "options": [
            "Standard",
            "Nearline",
            "Coldline",
            "Archive"
        ],
        "answer": "Archive",
        "explanation": "Standard for hot data. Nearline < 1/month. Coldline < 1/quarter. Archive < 1/year.",
        "frequency_score": 6
    },
    {
        "id": 412,
        "topic": "Pub/Sub",
        "companies": [
            "Google",
            "Uber"
        ],
        "question": "Your application publishes 1 million/sec messages to Pub/Sub. You observe throughput limits on specific keys. What is the most likely cause? ",
        "options": [
            "Subscribers are too slow (backlog)",
            "Publisher quota exceeded",
            "Message size too large",
            "Ordering keys are causing hotspots"
        ],
        "answer": "Ordering keys are causing hotspots",
        "explanation": "If using ordering keys, high throughput on a single key can limit scalability (1MB/s limit per key). Slow subscribers cause increased backlog.",
        "frequency_score": 7
    },
    {
        "id": 413,
        "topic": "Apache Spark",
        "companies": [
            "Google",
            "Databricks",
            "Amazon"
        ],
        "question": "In Spark, what is the difference between a Transformation and an Action? ",
        "options": [
            "Transformations are lazy, Actions match strict execution",
            "Actions are lazy, Transformations trigger execution",
            "They are the same",
            "Transformations save to disk, Actions read from disk"
        ],
        "answer": "Transformations are lazy, Actions match strict execution",
        "explanation": "Transformations (like map, filter) build the DAG but do not execute. Actions (like count, collect, save) trigger the actual computation.",
        "frequency_score": 6
    },
    {
        "id": 414,
        "topic": "Algorithms",
        "companies": [
            "Google",
            "Amazon",
            "Microsoft"
        ],
        "question": "What is the time complexity of a Merge Sort algorithm in the worst case? ",
        "options": [
            "O(n log n)",
            "O(n^2)",
            "O(n)",
            "O(log n)"
        ],
        "answer": "O(n log n)",
        "explanation": "Merge Sort is O(n log n). Quick Sort is O(n^2) in worst case (though avg O(n log n)). Bubble Sort is O(n^2).",
        "frequency_score": 8
    },
    {
        "id": 415,
        "topic": "Cloud Spanner",
        "companies": [
            "Google",
            "Uber",
            "Pokemon GO"
        ],
        "question": "You are designing a global banking ledger. You require strong consistency and horizontal scalability. Which database service should you choose? ",
        "options": [
            "Cloud Spanner",
            "Cloud SQL",
            "Bigtable",
            "Firestore"
        ],
        "answer": "Cloud Spanner",
        "explanation": "Cloud Spanner is the only service providing global strong consistency and horizontal scalability with relational semantics (SQL).",
        "frequency_score": 8
    },
    {
        "id": 416,
        "topic": "Algorithms",
        "companies": [
            "Google",
            "Amazon",
            "Microsoft"
        ],
        "question": "What is the time complexity of a Merge Sort algorithm in the worst case? ",
        "options": [
            "O(n log n)",
            "O(n^2)",
            "O(n)",
            "O(log n)"
        ],
        "answer": "O(n log n)",
        "explanation": "Merge Sort is O(n log n). Quick Sort is O(n^2) in worst case (though avg O(n log n)). Bubble Sort is O(n^2).",
        "frequency_score": 8
    },
    {
        "id": 417,
        "topic": "Bigtable",
        "companies": [
            "Google",
            "Spotify"
        ],
        "question": "You are designing a Bigtable schema for IoT events. Queries will primarily be retrieve most recent events globally. Which row key design is optimal? ",
        "options": [
            "DeviceID#Timestamp",
            "Timestamp#DeviceID",
            "ReverseTimestamp#DeviceID",
            "Random#DeviceID"
        ],
        "answer": "ReverseTimestamp#DeviceID",
        "explanation": "Avoid starting with timestamp to prevent hotspots. Use EntityID first for entity-lookup queries. Use ReverseTimestamp for 'latest items' queries globally.",
        "frequency_score": 7
    },
    {
        "id": 418,
        "topic": "Cloud Spanner",
        "companies": [
            "Google",
            "Uber",
            "Pokemon GO"
        ],
        "question": "You are designing a global banking ledger. You require strong consistency and horizontal scalability. Which database service should you choose? ",
        "options": [
            "Cloud Spanner",
            "Cloud SQL",
            "Bigtable",
            "Firestore"
        ],
        "answer": "Cloud Spanner",
        "explanation": "Cloud Spanner is the only service providing global strong consistency and horizontal scalability with relational semantics (SQL).",
        "frequency_score": 8
    },
    {
        "id": 419,
        "topic": "BigQuery",
        "companies": [
            "Google",
            "Spotify",
            "Twitter"
        ],
        "question": "You need to store 500 TB of clickstream data data in BigQuery. The data is accessed continuously. Which storage class fits best to minimize costs? ",
        "options": [
            "Active Storage",
            "Long-term Storage",
            "Nearline Storage",
            "Coldline Storage"
        ],
        "answer": "Active Storage",
        "explanation": "BigQuery Long-term storage applies automatically after 90 days of no modification, reducing price by ~50%.",
        "frequency_score": 10
    },
    {
        "id": 420,
        "topic": "Dataflow",
        "companies": [
            "Google",
            "Spotify",
            "New York Times"
        ],
        "question": "You are building a streaming pipeline to process server logs. You need to handle hourly reporting. What windowing strategy is appropriate? ",
        "options": [
            "Fixed Windows",
            "Sliding Windows",
            "Session Windows",
            "Global Windows"
        ],
        "answer": "Fixed Windows",
        "explanation": "Session windows gap-fill based on activity. Sliding windows overlap (e.g. every 5 min show last 1 hour). Fixed windows are tumbling.",
        "frequency_score": 9
    },
    {
        "id": 421,
        "topic": "Bigtable",
        "companies": [
            "Google",
            "Spotify"
        ],
        "question": "You are designing a Bigtable schema for social media posts. Queries will primarily be retrieve latest events for a specific entity. Which row key design is optimal? ",
        "options": [
            "DeviceID#Timestamp",
            "Timestamp#DeviceID",
            "ReverseTimestamp#DeviceID",
            "Random#DeviceID"
        ],
        "answer": "DeviceID#Timestamp",
        "explanation": "Avoid starting with timestamp to prevent hotspots. Use EntityID first for entity-lookup queries. Use ReverseTimestamp for 'latest items' queries globally.",
        "frequency_score": 7
    },
    {
        "id": 422,
        "topic": "Apache Kafka",
        "companies": [
            "Google",
            "LinkedIn",
            "Uber",
            "Netflix"
        ],
        "question": "You need to ensure strict ordering of messages in Kafka for a specific User ID. How should you configure the producer? ",
        "options": [
            "Use the User ID as the partition key",
            "Use a single partition for the entire topic",
            "Enable idempotent producer",
            "Increase replication factor"
        ],
        "answer": "Use the User ID as the partition key",
        "explanation": "Kafka guarantees ordering WITHIN a partition. Using the Entity ID as the key ensures all messages for that entity go to the same partition.",
        "frequency_score": 6
    },
    {
        "id": 423,
        "topic": "Algorithms",
        "companies": [
            "Google",
            "Amazon",
            "Microsoft"
        ],
        "question": "What is the time complexity of a Bubble Sort algorithm in the worst case? ",
        "options": [
            "O(n log n)",
            "O(n^2)",
            "O(n)",
            "O(log n)"
        ],
        "answer": "O(n^2)",
        "explanation": "Merge Sort is O(n log n). Quick Sort is O(n^2) in worst case (though avg O(n log n)). Bubble Sort is O(n^2).",
        "frequency_score": 8
    },
    {
        "id": 424,
        "topic": "Algorithms",
        "companies": [
            "Google",
            "Amazon",
            "Microsoft"
        ],
        "question": "What is the time complexity of a Merge Sort algorithm in the worst case? ",
        "options": [
            "O(n log n)",
            "O(n^2)",
            "O(n)",
            "O(log n)"
        ],
        "answer": "O(n log n)",
        "explanation": "Merge Sort is O(n log n). Quick Sort is O(n^2) in worst case (though avg O(n log n)). Bubble Sort is O(n^2).",
        "frequency_score": 8
    },
    {
        "id": 425,
        "topic": "Cloud Storage",
        "companies": [
            "Google",
            "Snapchat"
        ],
        "question": "You are designing a storage solution for daily analytics content. The requirement is high frequency access. What storage class should you use?",
        "options": [
            "Standard",
            "Nearline",
            "Coldline",
            "Archive"
        ],
        "answer": "Standard",
        "explanation": "Standard for hot data. Nearline < 1/month. Coldline < 1/quarter. Archive < 1/year.",
        "frequency_score": 6
    },
    {
        "id": 426,
        "topic": "Apache Kafka",
        "companies": [
            "Google",
            "LinkedIn",
            "Uber",
            "Netflix"
        ],
        "question": "You need to ensure strict ordering of messages in Kafka for a specific User ID. How should you configure the producer? ",
        "options": [
            "Use the User ID as the partition key",
            "Use a single partition for the entire topic",
            "Enable idempotent producer",
            "Increase replication factor"
        ],
        "answer": "Use the User ID as the partition key",
        "explanation": "Kafka guarantees ordering WITHIN a partition. Using the Entity ID as the key ensures all messages for that entity go to the same partition.",
        "frequency_score": 6
    },
    {
        "id": 427,
        "topic": "Cloud Storage",
        "companies": [
            "Google",
            "Snapchat"
        ],
        "question": "You are designing a storage solution for profile pictures. The requirement is access once a quarter. What storage class should you use? ",
        "options": [
            "Standard",
            "Nearline",
            "Coldline",
            "Archive"
        ],
        "answer": "Coldline",
        "explanation": "Standard for hot data. Nearline < 1/month. Coldline < 1/quarter. Archive < 1/year.",
        "frequency_score": 6
    },
    {
        "id": 428,
        "topic": "Apache Kafka",
        "companies": [
            "Google",
            "LinkedIn",
            "Uber",
            "Netflix"
        ],
        "question": "You need to ensure strict ordering of messages in Kafka for a specific User ID. How should you configure the producer? ",
        "options": [
            "Use the User ID as the partition key",
            "Use a single partition for the entire topic",
            "Enable idempotent producer",
            "Increase replication factor"
        ],
        "answer": "Use the User ID as the partition key",
        "explanation": "Kafka guarantees ordering WITHIN a partition. Using the Entity ID as the key ensures all messages for that entity go to the same partition.",
        "frequency_score": 6
    },
    {
        "id": 429,
        "topic": "IAM",
        "companies": [
            "Google"
        ],
        "question": "A developer needs to upload files to a bucket in a production project. Following the principle of least privilege, which role should you grant? ",
        "options": [
            "Viewer",
            "Editor",
            "Owner",
            "Cloud Functions Developer"
        ],
        "answer": "Cloud Functions Developer",
        "explanation": "Always prefer predefined specific roles (like BigQuery Data Viewer, Storage Object Admin) over basic roles (Viewer/Editor/Owner) to ensure least privilege.",
        "frequency_score": 9
    },
    {
        "id": 430,
        "topic": "Algorithms",
        "companies": [
            "Google",
            "Amazon",
            "Microsoft"
        ],
        "question": "What is the time complexity of a Bubble Sort algorithm in the worst case? ",
        "options": [
            "O(n log n)",
            "O(n^2)",
            "O(n)",
            "O(log n)"
        ],
        "answer": "O(n^2)",
        "explanation": "Merge Sort is O(n log n). Quick Sort is O(n^2) in worst case (though avg O(n log n)). Bubble Sort is O(n^2).",
        "frequency_score": 8
    },
    {
        "id": 431,
        "topic": "BigQuery",
        "companies": [
            "Google",
            "Spotify",
            "Twitter"
        ],
        "question": "You need to store 50 TB of clickstream data data in BigQuery. The data is accessed daily. Which storage class fits best to minimize costs? ",
        "options": [
            "Active Storage",
            "Long-term Storage",
            "Nearline Storage",
            "Coldline Storage"
        ],
        "answer": "Active Storage",
        "explanation": "BigQuery Long-term storage applies automatically after 90 days of no modification, reducing price by ~50%.",
        "frequency_score": 10
    },
    {
        "id": 432,
        "topic": "Algorithms",
        "companies": [
            "Google",
            "Amazon",
            "Microsoft"
        ],
        "question": "What is the time complexity of a Bubble Sort algorithm in the worst case? ",
        "options": [
            "O(n log n)",
            "O(n^2)",
            "O(n)",
            "O(log n)"
        ],
        "answer": "O(n^2)",
        "explanation": "Merge Sort is O(n log n). Quick Sort is O(n^2) in worst case (though avg O(n log n)). Bubble Sort is O(n^2).",
        "frequency_score": 8
    },
    {
        "id": 433,
        "topic": "Apache Kafka",
        "companies": [
            "Google",
            "LinkedIn"
        ],
        "question": "What happens if a Kafka Consumer Group has more consumers than partitions in the topic? ",
        "options": [
            "Some consumers will be idle",
            "Throughput increases linearly",
            "Kafka automatically creates more partitions",
            "The extra consumers duplicate the data"
        ],
        "answer": "Some consumers will be idle",
        "explanation": "A partition can be consumed by only one consumer within a group at a time. Extra consumers stay idle.",
        "frequency_score": 6
    },
    {
        "id": 434,
        "topic": "Apache Spark",
        "companies": [
            "Google",
            "Databricks",
            "Amazon"
        ],
        "question": "In Spark, what is the difference between a Transformation and an Action? ",
        "options": [
            "Transformations are lazy, Actions match strict execution",
            "Actions are lazy, Transformations trigger execution",
            "They are the same",
            "Transformations save to disk, Actions read from disk"
        ],
        "answer": "Transformations are lazy, Actions match strict execution",
        "explanation": "Transformations (like map, filter) build the DAG but do not execute. Actions (like count, collect, save) trigger the actual computation.",
        "frequency_score": 6
    },
    {
        "id": 435,
        "topic": "BigQuery",
        "companies": [
            "Google",
            "Spotify",
            "Twitter"
        ],
        "question": "You need to store 50 TB of clickstream data data in BigQuery. The data is accessed rarely (every 6 months). Which storage class fits best to minimize costs?",
        "options": [
            "Active Storage",
            "Long-term Storage",
            "Nearline Storage",
            "Coldline Storage"
        ],
        "answer": "Long-term Storage",
        "explanation": "BigQuery Long-term storage applies automatically after 90 days of no modification, reducing price by ~50%.",
        "frequency_score": 10
    },
    {
        "id": 436,
        "topic": "Dataflow",
        "companies": [
            "Google",
            "Spotify",
            "New York Times"
        ],
        "question": "You are building a streaming pipeline to process user clickstreams. You need to handle hourly reporting. What windowing strategy is appropriate? ",
        "options": [
            "Fixed Windows",
            "Sliding Windows",
            "Session Windows",
            "Global Windows"
        ],
        "answer": "Fixed Windows",
        "explanation": "Session windows gap-fill based on activity. Sliding windows overlap (e.g. every 5 min show last 1 hour). Fixed windows are tumbling.",
        "frequency_score": 9
    },
    {
        "id": 437,
        "topic": "Pub/Sub",
        "companies": [
            "Google",
            "Uber"
        ],
        "question": "Your application publishes 1 million/sec messages to Pub/Sub. You observe throughput limits on specific keys. What is the most likely cause? ",
        "options": [
            "Subscribers are too slow (backlog)",
            "Publisher quota exceeded",
            "Message size too large",
            "Ordering keys are causing hotspots"
        ],
        "answer": "Ordering keys are causing hotspots",
        "explanation": "If using ordering keys, high throughput on a single key can limit scalability (1MB/s limit per key). Slow subscribers cause increased backlog.",
        "frequency_score": 7
    },
    {
        "id": 438,
        "topic": "Apache Kafka",
        "companies": [
            "Google",
            "LinkedIn"
        ],
        "question": "What happens if a Kafka Consumer Group has more consumers than partitions in the topic? ",
        "options": [
            "Some consumers will be idle",
            "Throughput increases linearly",
            "Kafka automatically creates more partitions",
            "The extra consumers duplicate the data"
        ],
        "answer": "Some consumers will be idle",
        "explanation": "A partition can be consumed by only one consumer within a group at a time. Extra consumers stay idle.",
        "frequency_score": 6
    },
    {
        "id": 439,
        "topic": "Algorithms",
        "companies": [
            "Google",
            "Amazon",
            "Microsoft"
        ],
        "question": "What is the time complexity of a Bubble Sort algorithm in the worst case? ",
        "options": [
            "O(n log n)",
            "O(n^2)",
            "O(n)",
            "O(log n)"
        ],
        "answer": "O(n^2)",
        "explanation": "Merge Sort is O(n log n). Quick Sort is O(n^2) in worst case (though avg O(n log n)). Bubble Sort is O(n^2).",
        "frequency_score": 8
    },
    {
        "id": 440,
        "topic": "Apache Spark",
        "companies": [
            "Google",
            "Databricks",
            "Amazon"
        ],
        "question": "In Spark, what is the difference between a Transformation and an Action? ",
        "options": [
            "Transformations are lazy, Actions match strict execution",
            "Actions are lazy, Transformations trigger execution",
            "They are the same",
            "Transformations save to disk, Actions read from disk"
        ],
        "answer": "Transformations are lazy, Actions match strict execution",
        "explanation": "Transformations (like map, filter) build the DAG but do not execute. Actions (like count, collect, save) trigger the actual computation.",
        "frequency_score": 6
    },
    {
        "id": 441,
        "topic": "Data Structures",
        "companies": [
            "Google",
            "Amazon",
            "Microsoft",
            "Facebook"
        ],
        "question": "You need to implement a look-up service that checks if a user ID exists in a set of 1 billion users with O(log n) average time complexity. Which data structure is best? ",
        "options": [
            "Hash Table / HashSet",
            "Binary Search Tree",
            "Linked List",
            "Array"
        ],
        "answer": "Binary Search Tree",
        "explanation": "Hash Tables provide O(1) average case lookup. BST is O(log n).",
        "frequency_score": 8
    },
    {
        "id": 442,
        "topic": "Dataflow",
        "companies": [
            "Google",
            "Spotify",
            "New York Times"
        ],
        "question": "You are building a streaming pipeline to process server logs. You need to handle rolling averages every minute for the last hour. What windowing strategy is appropriate? ",
        "options": [
            "Fixed Windows",
            "Sliding Windows",
            "Session Windows",
            "Global Windows"
        ],
        "answer": "Sliding Windows",
        "explanation": "Session windows gap-fill based on activity. Sliding windows overlap (e.g. every 5 min show last 1 hour). Fixed windows are tumbling.",
        "frequency_score": 9
    },
    {
        "id": 443,
        "topic": "Bigtable",
        "companies": [
            "Google",
            "Spotify"
        ],
        "question": "You are designing a Bigtable schema for financial transactions. Queries will primarily be retrieve latest events for a specific entity. Which row key design is optimal? ",
        "options": [
            "SensorID#Timestamp",
            "Timestamp#SensorID",
            "ReverseTimestamp#SensorID",
            "Random#SensorID"
        ],
        "answer": "SensorID#Timestamp",
        "explanation": "Avoid starting with timestamp to prevent hotspots. Use EntityID first for entity-lookup queries. Use ReverseTimestamp for 'latest items' queries globally.",
        "frequency_score": 7
    },
    {
        "id": 444,
        "topic": "Bigtable",
        "companies": [
            "Google",
            "Spotify"
        ],
        "question": "You are designing a Bigtable schema for social media posts. Queries will primarily be retrieve latest events for a specific entity. Which row key design is optimal? ",
        "options": [
            "SensorID#Date",
            "Date#SensorID",
            "ReverseTimestamp#SensorID",
            "Random#SensorID"
        ],
        "answer": "SensorID#Date",
        "explanation": "Avoid starting with timestamp to prevent hotspots. Use EntityID first for entity-lookup queries. Use ReverseTimestamp for 'latest items' queries globally.",
        "frequency_score": 7
    },
    {
        "id": 445,
        "topic": "Data Structures",
        "companies": [
            "Google",
            "Amazon",
            "Microsoft",
            "Facebook"
        ],
        "question": "You need to implement a look-up service that checks if a user ID exists in a set of 1 billion users with O(log n) average time complexity. Which data structure is best? ",
        "options": [
            "Hash Table / HashSet",
            "Binary Search Tree",
            "Linked List",
            "Array"
        ],
        "answer": "Binary Search Tree",
        "explanation": "Hash Tables provide O(1) average case lookup. BST is O(log n).",
        "frequency_score": 8
    },
    {
        "id": 446,
        "topic": "Apache Spark",
        "companies": [
            "Google",
            "Databricks",
            "Amazon"
        ],
        "question": "In Spark, what is the difference between a Transformation and an Action? ",
        "options": [
            "Transformations are lazy, Actions match strict execution",
            "Actions are lazy, Transformations trigger execution",
            "They are the same",
            "Transformations save to disk, Actions read from disk"
        ],
        "answer": "Transformations are lazy, Actions match strict execution",
        "explanation": "Transformations (like map, filter) build the DAG but do not execute. Actions (like count, collect, save) trigger the actual computation.",
        "frequency_score": 6
    },
    {
        "id": 447,
        "topic": "IAM",
        "companies": [
            "Google"
        ],
        "question": "A developer needs to view BigQuery datasets in a production project. Following the principle of least privilege, which role should you grant? ",
        "options": [
            "Viewer",
            "Editor",
            "Owner",
            "Cloud Functions Developer"
        ],
        "answer": "Cloud Functions Developer",
        "explanation": "Always prefer predefined specific roles (like BigQuery Data Viewer, Storage Object Admin) over basic roles (Viewer/Editor/Owner) to ensure least privilege.",
        "frequency_score": 9
    },
    {
        "id": 448,
        "topic": "Cloud Spanner",
        "companies": [
            "Google",
            "Uber",
            "Pokemon GO"
        ],
        "question": "You are designing a global banking ledger. You require strong consistency and horizontal scalability. Which database service should you choose? ",
        "options": [
            "Cloud Spanner",
            "Cloud SQL",
            "Bigtable",
            "Firestore"
        ],
        "answer": "Cloud Spanner",
        "explanation": "Cloud Spanner is the only service providing global strong consistency and horizontal scalability with relational semantics (SQL).",
        "frequency_score": 8
    },
    {
        "id": 449,
        "topic": "Bigtable",
        "companies": [
            "Google",
            "Spotify"
        ],
        "question": "You are designing a Bigtable schema for IoT events. Queries will primarily be retrieve latest events for a specific entity. Which row key design is optimal? ",
        "options": [
            "SensorID#Timestamp",
            "Timestamp#SensorID",
            "ReverseTimestamp#SensorID",
            "Random#SensorID"
        ],
        "answer": "SensorID#Timestamp",
        "explanation": "Avoid starting with timestamp to prevent hotspots. Use EntityID first for entity-lookup queries. Use ReverseTimestamp for 'latest items' queries globally.",
        "frequency_score": 7
    },
    {
        "id": 450,
        "topic": "Cloud Spanner",
        "companies": [
            "Google",
            "Uber",
            "Pokemon GO"
        ],
        "question": "You are designing a global banking ledger. You require strong consistency and 99.999% availability. Which database service should you choose? ",
        "options": [
            "Cloud Spanner",
            "Cloud SQL",
            "Bigtable",
            "Firestore"
        ],
        "answer": "Cloud Spanner",
        "explanation": "Cloud Spanner is the only service providing global strong consistency and horizontal scalability with relational semantics (SQL).",
        "frequency_score": 8
    },
    {
        "id": 451,
        "topic": "Pub/Sub",
        "companies": [
            "Google",
            "Uber"
        ],
        "question": "Your application publishes 1 million/sec messages to Pub/Sub. You observe increased end-to-end latency and growing backlog. What is the most likely cause? ",
        "options": [
            "Subscribers are too slow (backlog)",
            "Publisher quota exceeded",
            "Message size too large",
            "Ordering keys are causing hotspots"
        ],
        "answer": "Subscribers are too slow (backlog)",
        "explanation": "If using ordering keys, high throughput on a single key can limit scalability (1MB/s limit per key). Slow subscribers cause increased backlog.",
        "frequency_score": 7
    },
    {
        "id": 452,
        "topic": "Bigtable",
        "companies": [
            "Google",
            "Spotify"
        ],
        "question": "You are designing a Bigtable schema for financial transactions. Queries will primarily be retrieve latest events for a specific entity. Which row key design is optimal? ",
        "options": [
            "DeviceID#Date",
            "Date#DeviceID",
            "ReverseTimestamp#DeviceID",
            "Random#DeviceID"
        ],
        "answer": "DeviceID#Date",
        "explanation": "Avoid starting with timestamp to prevent hotspots. Use EntityID first for entity-lookup queries. Use ReverseTimestamp for 'latest items' queries globally.",
        "frequency_score": 7
    },
    {
        "id": 453,
        "topic": "Data Structures",
        "companies": [
            "Google",
            "Amazon",
            "Microsoft",
            "Facebook"
        ],
        "question": "You need to implement a look-up service that checks if a user ID exists in a set of 1 billion users with O(log n) average time complexity. Which data structure is best? ",
        "options": [
            "Hash Table / HashSet",
            "Binary Search Tree",
            "Linked List",
            "Array"
        ],
        "answer": "Binary Search Tree",
        "explanation": "Hash Tables provide O(1) average case lookup. BST is O(log n).",
        "frequency_score": 8
    },
    {
        "id": 454,
        "topic": "Algorithms",
        "companies": [
            "Google",
            "Amazon",
            "Microsoft"
        ],
        "question": "What is the time complexity of a Bubble Sort algorithm in the worst case? ",
        "options": [
            "O(n log n)",
            "O(n^2)",
            "O(n)",
            "O(log n)"
        ],
        "answer": "O(n^2)",
        "explanation": "Merge Sort is O(n log n). Quick Sort is O(n^2) in worst case (though avg O(n log n)). Bubble Sort is O(n^2).",
        "frequency_score": 8
    },
    {
        "id": 455,
        "topic": "Apache Spark",
        "companies": [
            "Google",
            "Databricks",
            "Amazon"
        ],
        "question": "In Spark, what is the difference between a Transformation and an Action? ",
        "options": [
            "Transformations are lazy, Actions match strict execution",
            "Actions are lazy, Transformations trigger execution",
            "They are the same",
            "Transformations save to disk, Actions read from disk"
        ],
        "answer": "Transformations are lazy, Actions match strict execution",
        "explanation": "Transformations (like map, filter) build the DAG but do not execute. Actions (like count, collect, save) trigger the actual computation.",
        "frequency_score": 6
    },
    {
        "id": 456,
        "topic": "Apache Spark",
        "companies": [
            "Google",
            "Databricks",
            "Facebook",
            "Netflix"
        ],
        "question": "You are optimizing a Spark job that is suffering from data skew. You are joining a large skewed table with a small reference table. Which technique is most effective? ",
        "options": [
            "Salting the key",
            "Increasing the number of executors",
            "Using a larger instance type",
            "Broadcasting the large table"
        ],
        "answer": "Salting the key",
        "explanation": "Salting adds a random prefix to the skewed key to distribute it. Broadcasting is best for Skewed Joins where one table is small.",
        "frequency_score": 6
    },
    {
        "id": 457,
        "topic": "BigQuery",
        "companies": [
            "Google",
            "Spotify",
            "Twitter"
        ],
        "question": "You need to store 500 TB of clickstream data data in BigQuery. The data is accessed rarely (every 6 months). Which storage class fits best to minimize costs? ",
        "options": [
            "Active Storage",
            "Long-term Storage",
            "Nearline Storage",
            "Coldline Storage"
        ],
        "answer": "Long-term Storage",
        "explanation": "BigQuery Long-term storage applies automatically after 90 days of no modification, reducing price by ~50%.",
        "frequency_score": 10
    },
    {
        "id": 458,
        "topic": "Pub/Sub",
        "companies": [
            "Google",
            "Uber"
        ],
        "question": "Your application publishes 1 million/sec messages to Pub/Sub. You observe throughput limits on specific keys. What is the most likely cause? ",
        "options": [
            "Subscribers are too slow (backlog)",
            "Publisher quota exceeded",
            "Message size too large",
            "Ordering keys are causing hotspots"
        ],
        "answer": "Ordering keys are causing hotspots",
        "explanation": "If using ordering keys, high throughput on a single key can limit scalability (1MB/s limit per key). Slow subscribers cause increased backlog.",
        "frequency_score": 7
    },
    {
        "id": 459,
        "topic": "Pub/Sub",
        "companies": [
            "Google",
            "Uber"
        ],
        "question": "Your application publishes high throughput messages to Pub/Sub. You observe throughput limits on specific keys. What is the most likely cause? ",
        "options": [
            "Subscribers are too slow (backlog)",
            "Publisher quota exceeded",
            "Message size too large",
            "Ordering keys are causing hotspots"
        ],
        "answer": "Ordering keys are causing hotspots",
        "explanation": "If using ordering keys, high throughput on a single key can limit scalability (1MB/s limit per key). Slow subscribers cause increased backlog.",
        "frequency_score": 7
    },
    {
        "id": 460,
        "topic": "Apache Spark",
        "companies": [
            "Google",
            "Databricks",
            "Amazon"
        ],
        "question": "In Spark, what is the difference between a Transformation and an Action? ",
        "options": [
            "Transformations are lazy, Actions match strict execution",
            "Actions are lazy, Transformations trigger execution",
            "They are the same",
            "Transformations save to disk, Actions read from disk"
        ],
        "answer": "Transformations are lazy, Actions match strict execution",
        "explanation": "Transformations (like map, filter) build the DAG but do not execute. Actions (like count, collect, save) trigger the actual computation.",
        "frequency_score": 6
    },
    {
        "id": 461,
        "topic": "BigQuery",
        "companies": [
            "Google",
            "Spotify",
            "Twitter"
        ],
        "question": "You need to store 500 TB of audit logs data in BigQuery. The data is accessed continuously. Which storage class fits best to minimize costs?",
        "options": [
            "Active Storage",
            "Long-term Storage",
            "Nearline Storage",
            "Coldline Storage"
        ],
        "answer": "Active Storage",
        "explanation": "BigQuery Long-term storage applies automatically after 90 days of no modification, reducing price by ~50%.",
        "frequency_score": 10
    },
    {
        "id": 462,
        "topic": "Algorithms",
        "companies": [
            "Google",
            "Amazon",
            "Microsoft"
        ],
        "question": "What is the time complexity of a Merge Sort algorithm in the worst case? ",
        "options": [
            "O(n log n)",
            "O(n^2)",
            "O(n)",
            "O(log n)"
        ],
        "answer": "O(n log n)",
        "explanation": "Merge Sort is O(n log n). Quick Sort is O(n^2) in worst case (though avg O(n log n)). Bubble Sort is O(n^2).",
        "frequency_score": 8
    },
    {
        "id": 463,
        "topic": "IAM",
        "companies": [
            "Google"
        ],
        "question": "A developer needs to deploy Cloud Functions in a production project. Following the principle of least privilege, which role should you grant? ",
        "options": [
            "Viewer",
            "Editor",
            "Owner",
            "Storage Object Creator"
        ],
        "answer": "Storage Object Creator",
        "explanation": "Always prefer predefined specific roles (like BigQuery Data Viewer, Storage Object Admin) over basic roles (Viewer/Editor/Owner) to ensure least privilege.",
        "frequency_score": 9
    },
    {
        "id": 464,
        "topic": "Apache Spark",
        "companies": [
            "Google",
            "Databricks",
            "Amazon"
        ],
        "question": "In Spark, what is the difference between a Transformation and an Action? ",
        "options": [
            "Transformations are lazy, Actions match strict execution",
            "Actions are lazy, Transformations trigger execution",
            "They are the same",
            "Transformations save to disk, Actions read from disk"
        ],
        "answer": "Transformations are lazy, Actions match strict execution",
        "explanation": "Transformations (like map, filter) build the DAG but do not execute. Actions (like count, collect, save) trigger the actual computation.",
        "frequency_score": 6
    },
    {
        "id": 465,
        "topic": "Pub/Sub",
        "companies": [
            "Google",
            "Uber"
        ],
        "question": "Your application publishes high throughput messages to Pub/Sub. You observe throughput limits on specific keys. What is the most likely cause? ",
        "options": [
            "Subscribers are too slow (backlog)",
            "Publisher quota exceeded",
            "Message size too large",
            "Ordering keys are causing hotspots"
        ],
        "answer": "Ordering keys are causing hotspots",
        "explanation": "If using ordering keys, high throughput on a single key can limit scalability (1MB/s limit per key). Slow subscribers cause increased backlog.",
        "frequency_score": 7
    },
    {
        "id": 466,
        "topic": "Data Structures",
        "companies": [
            "Google",
            "Amazon",
            "Microsoft",
            "Facebook"
        ],
        "question": "You need to implement a look-up service that checks if a user ID exists in a set of 1 billion users with O(log n) average time complexity. Which data structure is best? ",
        "options": [
            "Hash Table / HashSet",
            "Binary Search Tree",
            "Linked List",
            "Array"
        ],
        "answer": "Binary Search Tree",
        "explanation": "Hash Tables provide O(1) average case lookup. BST is O(log n).",
        "frequency_score": 8
    },
    {
        "id": 467,
        "topic": "Apache Kafka",
        "companies": [
            "Google",
            "LinkedIn",
            "Uber",
            "Netflix"
        ],
        "question": "You need to ensure strict ordering of messages in Kafka for a specific Device ID. How should you configure the producer? ",
        "options": [
            "Use the Device ID as the partition key",
            "Use a single partition for the entire topic",
            "Enable idempotent producer",
            "Increase replication factor"
        ],
        "answer": "Use the Device ID as the partition key",
        "explanation": "Kafka guarantees ordering WITHIN a partition. Using the Entity ID as the key ensures all messages for that entity go to the same partition.",
        "frequency_score": 6
    },
    {
        "id": 468,
        "topic": "Dataflow",
        "companies": [
            "Google",
            "Spotify",
            "New York Times"
        ],
        "question": "You are building a streaming pipeline to process IoT temperature sensors. You need to handle rolling averages every minute for the last hour. What windowing strategy is appropriate? ",
        "options": [
            "Fixed Windows",
            "Sliding Windows",
            "Session Windows",
            "Global Windows"
        ],
        "answer": "Sliding Windows",
        "explanation": "Session windows gap-fill based on activity. Sliding windows overlap (e.g. every 5 min show last 1 hour). Fixed windows are tumbling.",
        "frequency_score": 9
    },
    {
        "id": 469,
        "topic": "BigQuery",
        "companies": [
            "Google",
            "Spotify",
            "Twitter"
        ],
        "question": "You need to store 50 TB of clickstream data data in BigQuery. The data is accessed once a quarter. Which storage class fits best to minimize costs? ",
        "options": [
            "Active Storage",
            "Long-term Storage",
            "Nearline Storage",
            "Coldline Storage"
        ],
        "answer": "Active Storage",
        "explanation": "BigQuery Long-term storage applies automatically after 90 days of no modification, reducing price by ~50%.",
        "frequency_score": 10
    },
    {
        "id": 470,
        "topic": "Apache Kafka",
        "companies": [
            "Google",
            "LinkedIn"
        ],
        "question": "What happens if a Kafka Consumer Group has more consumers than partitions in the topic? ",
        "options": [
            "Some consumers will be idle",
            "Throughput increases linearly",
            "Kafka automatically creates more partitions",
            "The extra consumers duplicate the data"
        ],
        "answer": "Some consumers will be idle",
        "explanation": "A partition can be consumed by only one consumer within a group at a time. Extra consumers stay idle.",
        "frequency_score": 6
    },
    {
        "id": 471,
        "topic": "Algorithms",
        "companies": [
            "Google",
            "Amazon",
            "Microsoft"
        ],
        "question": "What is the time complexity of a Quick Sort algorithm in the worst case? ",
        "options": [
            "O(n log n)",
            "O(n^2)",
            "O(n)",
            "O(log n)"
        ],
        "answer": "O(n^2)",
        "explanation": "Merge Sort is O(n log n). Quick Sort is O(n^2) in worst case (though avg O(n log n)). Bubble Sort is O(n^2).",
        "frequency_score": 8
    },
    {
        "id": 472,
        "topic": "Cloud Storage",
        "companies": [
            "Google",
            "Snapchat"
        ],
        "question": "You are designing a storage solution for disaster recovery backups. The requirement is access once a quarter. What storage class should you use? ",
        "options": [
            "Standard",
            "Nearline",
            "Coldline",
            "Archive"
        ],
        "answer": "Coldline",
        "explanation": "Standard for hot data. Nearline < 1/month. Coldline < 1/quarter. Archive < 1/year.",
        "frequency_score": 6
    },
    {
        "id": 473,
        "topic": "Apache Spark",
        "companies": [
            "Google",
            "Databricks",
            "Amazon"
        ],
        "question": "In Spark, what is the difference between a Transformation and an Action? ",
        "options": [
            "Transformations are lazy, Actions match strict execution",
            "Actions are lazy, Transformations trigger execution",
            "They are the same",
            "Transformations save to disk, Actions read from disk"
        ],
        "answer": "Transformations are lazy, Actions match strict execution",
        "explanation": "Transformations (like map, filter) build the DAG but do not execute. Actions (like count, collect, save) trigger the actual computation.",
        "frequency_score": 6
    },
    {
        "id": 474,
        "topic": "Apache Kafka",
        "companies": [
            "Google",
            "LinkedIn",
            "Uber",
            "Netflix"
        ],
        "question": "You need to ensure strict ordering of messages in Kafka for a specific User ID. How should you configure the producer? ",
        "options": [
            "Use the User ID as the partition key",
            "Use a single partition for the entire topic",
            "Enable idempotent producer",
            "Increase replication factor"
        ],
        "answer": "Use the User ID as the partition key",
        "explanation": "Kafka guarantees ordering WITHIN a partition. Using the Entity ID as the key ensures all messages for that entity go to the same partition.",
        "frequency_score": 6
    },
    {
        "id": 475,
        "topic": "IAM",
        "companies": [
            "Google"
        ],
        "question": "A developer needs to view BigQuery datasets in a production project. Following the principle of least privilege, which role should you grant? ",
        "options": [
            "Viewer",
            "Editor",
            "Owner",
            "Cloud Functions Developer"
        ],
        "answer": "Cloud Functions Developer",
        "explanation": "Always prefer predefined specific roles (like BigQuery Data Viewer, Storage Object Admin) over basic roles (Viewer/Editor/Owner) to ensure least privilege.",
        "frequency_score": 9
    },
    {
        "id": 476,
        "topic": "BigQuery",
        "companies": [
            "Google",
            "Spotify",
            "Twitter"
        ],
        "question": "You need to store 500 TB of transaction records data in BigQuery. The data is accessed rarely (every 6 months). Which storage class fits best to minimize costs? ",
        "options": [
            "Active Storage",
            "Long-term Storage",
            "Nearline Storage",
            "Coldline Storage"
        ],
        "answer": "Long-term Storage",
        "explanation": "BigQuery Long-term storage applies automatically after 90 days of no modification, reducing price by ~50%.",
        "frequency_score": 10
    },
    {
        "id": 477,
        "topic": "Apache Spark",
        "companies": [
            "Google",
            "Databricks",
            "Facebook",
            "Netflix"
        ],
        "question": "You are optimizing a Spark job that is suffering from data skew. You are joining a large skewed table with a small reference table. Which technique is most effective? ",
        "options": [
            "Salting the key",
            "Increasing the number of executors",
            "Using a larger instance type",
            "Broadcasting the large table"
        ],
        "answer": "Salting the key",
        "explanation": "Salting adds a random prefix to the skewed key to distribute it. Broadcasting is best for Skewed Joins where one table is small.",
        "frequency_score": 6
    },
    {
        "id": 478,
        "topic": "Dataflow",
        "companies": [
            "Google",
            "Spotify",
            "New York Times"
        ],
        "question": "You are building a streaming pipeline to process server logs. You need to handle rolling averages every minute for the last hour. What windowing strategy is appropriate? ",
        "options": [
            "Fixed Windows",
            "Sliding Windows",
            "Session Windows",
            "Global Windows"
        ],
        "answer": "Sliding Windows",
        "explanation": "Session windows gap-fill based on activity. Sliding windows overlap (e.g. every 5 min show last 1 hour). Fixed windows are tumbling.",
        "frequency_score": 9
    },
    {
        "id": 479,
        "topic": "Dataflow",
        "companies": [
            "Google",
            "Spotify",
            "New York Times"
        ],
        "question": "You are building a streaming pipeline to process user clickstreams. You need to handle rolling averages every minute for the last hour. What windowing strategy is appropriate? ",
        "options": [
            "Fixed Windows",
            "Sliding Windows",
            "Session Windows",
            "Global Windows"
        ],
        "answer": "Sliding Windows",
        "explanation": "Session windows gap-fill based on activity. Sliding windows overlap (e.g. every 5 min show last 1 hour). Fixed windows are tumbling.",
        "frequency_score": 9
    },
    {
        "id": 480,
        "topic": "Algorithms",
        "companies": [
            "Google",
            "Amazon",
            "Microsoft"
        ],
        "question": "What is the time complexity of a Merge Sort algorithm in the worst case? ",
        "options": [
            "O(n log n)",
            "O(n^2)",
            "O(n)",
            "O(log n)"
        ],
        "answer": "O(n log n)",
        "explanation": "Merge Sort is O(n log n). Quick Sort is O(n^2) in worst case (though avg O(n log n)). Bubble Sort is O(n^2).",
        "frequency_score": 8
    },
    {
        "id": 481,
        "topic": "BigQuery",
        "companies": [
            "Google",
            "Spotify",
            "Twitter"
        ],
        "question": "You need to store 2 PB of audit logs data in BigQuery. The data is accessed rarely (every 6 months). Which storage class fits best to minimize costs?",
        "options": [
            "Active Storage",
            "Long-term Storage",
            "Nearline Storage",
            "Coldline Storage"
        ],
        "answer": "Long-term Storage",
        "explanation": "BigQuery Long-term storage applies automatically after 90 days of no modification, reducing price by ~50%.",
        "frequency_score": 10
    },
    {
        "id": 482,
        "topic": "Algorithms",
        "companies": [
            "Google",
            "Amazon",
            "Microsoft"
        ],
        "question": "What is the time complexity of a Quick Sort algorithm in the worst case? ",
        "options": [
            "O(n log n)",
            "O(n^2)",
            "O(n)",
            "O(log n)"
        ],
        "answer": "O(n^2)",
        "explanation": "Merge Sort is O(n log n). Quick Sort is O(n^2) in worst case (though avg O(n log n)). Bubble Sort is O(n^2).",
        "frequency_score": 8
    },
    {
        "id": 483,
        "topic": "Dataflow",
        "companies": [
            "Google",
            "Spotify",
            "New York Times"
        ],
        "question": "You are building a streaming pipeline to process server logs. You need to handle rolling averages every minute for the last hour. What windowing strategy is appropriate? ",
        "options": [
            "Fixed Windows",
            "Sliding Windows",
            "Session Windows",
            "Global Windows"
        ],
        "answer": "Sliding Windows",
        "explanation": "Session windows gap-fill based on activity. Sliding windows overlap (e.g. every 5 min show last 1 hour). Fixed windows are tumbling.",
        "frequency_score": 9
    },
    {
        "id": 484,
        "topic": "IAM",
        "companies": [
            "Google"
        ],
        "question": "A developer needs to view BigQuery datasets in a production project. Following the principle of least privilege, which role should you grant? ",
        "options": [
            "Viewer",
            "Editor",
            "Owner",
            "Storage Object Creator"
        ],
        "answer": "Storage Object Creator",
        "explanation": "Always prefer predefined specific roles (like BigQuery Data Viewer, Storage Object Admin) over basic roles (Viewer/Editor/Owner) to ensure least privilege.",
        "frequency_score": 9
    },
    {
        "id": 485,
        "topic": "Cloud Spanner",
        "companies": [
            "Google",
            "Uber",
            "Pokemon GO"
        ],
        "question": "You are designing a global banking ledger. You require strong consistency and 99.999% availability. Which database service should you choose? ",
        "options": [
            "Cloud Spanner",
            "Cloud SQL",
            "Bigtable",
            "Firestore"
        ],
        "answer": "Cloud Spanner",
        "explanation": "Cloud Spanner is the only service providing global strong consistency and horizontal scalability with relational semantics (SQL).",
        "frequency_score": 8
    },
    {
        "id": 486,
        "topic": "Pub/Sub",
        "companies": [
            "Google",
            "Uber"
        ],
        "question": "Your application publishes 1 million/sec messages to Pub/Sub. You observe throughput limits on specific keys. What is the most likely cause? ",
        "options": [
            "Subscribers are too slow (backlog)",
            "Publisher quota exceeded",
            "Message size too large",
            "Ordering keys are causing hotspots"
        ],
        "answer": "Ordering keys are causing hotspots",
        "explanation": "If using ordering keys, high throughput on a single key can limit scalability (1MB/s limit per key). Slow subscribers cause increased backlog.",
        "frequency_score": 7
    },
    {
        "id": 487,
        "topic": "IAM",
        "companies": [
            "Google"
        ],
        "question": "A developer needs to view BigQuery datasets in a production project. Following the principle of least privilege, which role should you grant? ",
        "options": [
            "Viewer",
            "Editor",
            "Owner",
            "BigQuery Data Viewer"
        ],
        "answer": "BigQuery Data Viewer",
        "explanation": "Always prefer predefined specific roles (like BigQuery Data Viewer, Storage Object Admin) over basic roles (Viewer/Editor/Owner) to ensure least privilege.",
        "frequency_score": 9
    },
    {
        "id": 488,
        "topic": "Data Structures",
        "companies": [
            "Google",
            "Amazon",
            "Microsoft",
            "Facebook"
        ],
        "question": "You need to implement a look-up service that checks if a user ID exists in a set of 1 billion users with O(log n) average time complexity. Which data structure is best? ",
        "options": [
            "Hash Table / HashSet",
            "Binary Search Tree",
            "Linked List",
            "Array"
        ],
        "answer": "Binary Search Tree",
        "explanation": "Hash Tables provide O(1) average case lookup. BST is O(log n).",
        "frequency_score": 8
    },
    {
        "id": 489,
        "topic": "Bigtable",
        "companies": [
            "Google",
            "Spotify"
        ],
        "question": "You are designing a Bigtable schema for financial transactions. Queries will primarily be retrieve latest events for a specific entity. Which row key design is optimal? ",
        "options": [
            "DeviceID#Timestamp",
            "Timestamp#DeviceID",
            "ReverseTimestamp#DeviceID",
            "Random#DeviceID"
        ],
        "answer": "DeviceID#Timestamp",
        "explanation": "Avoid starting with timestamp to prevent hotspots. Use EntityID first for entity-lookup queries. Use ReverseTimestamp for 'latest items' queries globally.",
        "frequency_score": 7
    },
    {
        "id": 490,
        "topic": "Bigtable",
        "companies": [
            "Google",
            "Spotify"
        ],
        "question": "You are designing a Bigtable schema for financial transactions. Queries will primarily be retrieve latest events for a specific entity. Which row key design is optimal? ",
        "options": [
            "UserID#Date",
            "Date#UserID",
            "ReverseTimestamp#UserID",
            "Random#UserID"
        ],
        "answer": "UserID#Date",
        "explanation": "Avoid starting with timestamp to prevent hotspots. Use EntityID first for entity-lookup queries. Use ReverseTimestamp for 'latest items' queries globally.",
        "frequency_score": 7
    },
    {
        "id": 491,
        "topic": "IAM",
        "companies": [
            "Google"
        ],
        "question": "A developer needs to view BigQuery datasets in a production project. Following the principle of least privilege, which role should you grant? ",
        "options": [
            "Viewer",
            "Editor",
            "Owner",
            "BigQuery Data Viewer"
        ],
        "answer": "BigQuery Data Viewer",
        "explanation": "Always prefer predefined specific roles (like BigQuery Data Viewer, Storage Object Admin) over basic roles (Viewer/Editor/Owner) to ensure least privilege.",
        "frequency_score": 9
    },
    {
        "id": 492,
        "topic": "Bigtable",
        "companies": [
            "Google",
            "Spotify"
        ],
        "question": "You are designing a Bigtable schema for social media posts. Queries will primarily be retrieve most recent events globally. Which row key design is optimal? ",
        "options": [
            "SensorID#Timestamp",
            "Timestamp#SensorID",
            "ReverseTimestamp#SensorID",
            "Random#SensorID"
        ],
        "answer": "ReverseTimestamp#SensorID",
        "explanation": "Avoid starting with timestamp to prevent hotspots. Use EntityID first for entity-lookup queries. Use ReverseTimestamp for 'latest items' queries globally.",
        "frequency_score": 7
    },
    {
        "id": 493,
        "topic": "Algorithms",
        "companies": [
            "Google",
            "Amazon",
            "Microsoft"
        ],
        "question": "What is the time complexity of a Quick Sort algorithm in the worst case? ",
        "options": [
            "O(n log n)",
            "O(n^2)",
            "O(n)",
            "O(log n)"
        ],
        "answer": "O(n^2)",
        "explanation": "Merge Sort is O(n log n). Quick Sort is O(n^2) in worst case (though avg O(n log n)). Bubble Sort is O(n^2).",
        "frequency_score": 8
    },
    {
        "id": 494,
        "topic": "Cloud Spanner",
        "companies": [
            "Google",
            "Uber",
            "Pokemon GO"
        ],
        "question": "You are designing a global banking ledger. You require strong consistency and horizontal scalability. Which database service should you choose? ",
        "options": [
            "Cloud Spanner",
            "Cloud SQL",
            "Bigtable",
            "Firestore"
        ],
        "answer": "Cloud Spanner",
        "explanation": "Cloud Spanner is the only service providing global strong consistency and horizontal scalability with relational semantics (SQL).",
        "frequency_score": 8
    },
    {
        "id": 495,
        "topic": "Cloud Spanner",
        "companies": [
            "Google",
            "Uber",
            "Pokemon GO"
        ],
        "question": "You are designing a global banking ledger. You require strong consistency and horizontal scalability. Which database service should you choose? ",
        "options": [
            "Cloud Spanner",
            "Cloud SQL",
            "Bigtable",
            "Firestore"
        ],
        "answer": "Cloud Spanner",
        "explanation": "Cloud Spanner is the only service providing global strong consistency and horizontal scalability with relational semantics (SQL).",
        "frequency_score": 8
    },
    {
        "id": 496,
        "topic": "Apache Spark",
        "companies": [
            "Google",
            "Databricks",
            "Facebook",
            "Netflix"
        ],
        "question": "You are optimizing a Spark job that is suffering from data skew. You are joining a large skewed table with a small reference table. Which technique is most effective? ",
        "options": [
            "Salting the key",
            "Increasing the number of executors",
            "Using a larger instance type",
            "Broadcasting the large table"
        ],
        "answer": "Salting the key",
        "explanation": "Salting adds a random prefix to the skewed key to distribute it. Broadcasting is best for Skewed Joins where one table is small.",
        "frequency_score": 6
    },
    {
        "id": 497,
        "topic": "Algorithms",
        "companies": [
            "Google",
            "Amazon",
            "Microsoft"
        ],
        "question": "What is the time complexity of a Bubble Sort algorithm in the worst case? ",
        "options": [
            "O(n log n)",
            "O(n^2)",
            "O(n)",
            "O(log n)"
        ],
        "answer": "O(n^2)",
        "explanation": "Merge Sort is O(n log n). Quick Sort is O(n^2) in worst case (though avg O(n log n)). Bubble Sort is O(n^2).",
        "frequency_score": 8
    },
    {
        "id": 498,
        "topic": "Cloud Spanner",
        "companies": [
            "Google",
            "Uber",
            "Pokemon GO"
        ],
        "question": "You are designing a global banking ledger. You require strong consistency and horizontal scalability. Which database service should you choose? ",
        "options": [
            "Cloud Spanner",
            "Cloud SQL",
            "Bigtable",
            "Firestore"
        ],
        "answer": "Cloud Spanner",
        "explanation": "Cloud Spanner is the only service providing global strong consistency and horizontal scalability with relational semantics (SQL).",
        "frequency_score": 8
    },
    {
        "id": 499,
        "topic": "Cloud Storage",
        "companies": [
            "Google",
            "Snapchat"
        ],
        "question": "You are designing a storage solution for daily analytics content. The requirement is access once a quarter. What storage class should you use? ",
        "options": [
            "Standard",
            "Nearline",
            "Coldline",
            "Archive"
        ],
        "answer": "Coldline",
        "explanation": "Standard for hot data. Nearline < 1/month. Coldline < 1/quarter. Archive < 1/year.",
        "frequency_score": 6
    },
    {
        "id": 500,
        "topic": "Apache Kafka",
        "companies": [
            "Google",
            "LinkedIn",
            "Uber",
            "Netflix"
        ],
        "question": "You need to ensure strict ordering of messages in Kafka for a specific User ID. How should you configure the producer? ",
        "options": [
            "Use the User ID as the partition key",
            "Use a single partition for the entire topic",
            "Enable idempotent producer",
            "Increase replication factor"
        ],
        "answer": "Use the User ID as the partition key",
        "explanation": "Kafka guarantees ordering WITHIN a partition. Using the Entity ID as the key ensures all messages for that entity go to the same partition.",
        "frequency_score": 6
    },
    {
        "id": 501,
        "topic": "BigQuery",
        "companies": [
            "Google",
            "Spotify",
            "Twitter"
        ],
        "question": "You need to store 50 TB of transaction records data in BigQuery. The data is accessed rarely (every 6 months). Which storage class fits best to minimize costs?",
        "options": [
            "Active Storage",
            "Long-term Storage",
            "Nearline Storage",
            "Coldline Storage"
        ],
        "answer": "Long-term Storage",
        "explanation": "BigQuery Long-term storage applies automatically after 90 days of no modification, reducing price by ~50%.",
        "frequency_score": 10
    },
    {
        "id": 502,
        "topic": "Apache Spark",
        "companies": [
            "Google",
            "Databricks",
            "Amazon"
        ],
        "question": "In Spark, what is the difference between a Transformation and an Action? ",
        "options": [
            "Transformations are lazy, Actions match strict execution",
            "Actions are lazy, Transformations trigger execution",
            "They are the same",
            "Transformations save to disk, Actions read from disk"
        ],
        "answer": "Transformations are lazy, Actions match strict execution",
        "explanation": "Transformations (like map, filter) build the DAG but do not execute. Actions (like count, collect, save) trigger the actual computation.",
        "frequency_score": 6
    },
    {
        "id": 503,
        "topic": "Cloud Spanner",
        "companies": [
            "Google",
            "Uber",
            "Pokemon GO"
        ],
        "question": "You are designing a global banking ledger. You require strong consistency and 99.999% availability. Which database service should you choose? ",
        "options": [
            "Cloud Spanner",
            "Cloud SQL",
            "Bigtable",
            "Firestore"
        ],
        "answer": "Cloud Spanner",
        "explanation": "Cloud Spanner is the only service providing global strong consistency and horizontal scalability with relational semantics (SQL).",
        "frequency_score": 8
    },
    {
        "id": 504,
        "topic": "Apache Kafka",
        "companies": [
            "Google",
            "LinkedIn",
            "Uber",
            "Netflix"
        ],
        "question": "You need to ensure strict ordering of messages in Kafka for a specific Device ID. How should you configure the producer? ",
        "options": [
            "Use the Device ID as the partition key",
            "Use a single partition for the entire topic",
            "Enable idempotent producer",
            "Increase replication factor"
        ],
        "answer": "Use the Device ID as the partition key",
        "explanation": "Kafka guarantees ordering WITHIN a partition. Using the Entity ID as the key ensures all messages for that entity go to the same partition.",
        "frequency_score": 6
    },
    {
        "id": 505,
        "topic": "Pub/Sub",
        "companies": [
            "Google",
            "Uber"
        ],
        "question": "Your application publishes high throughput messages to Pub/Sub. You observe throughput limits on specific keys. What is the most likely cause? ",
        "options": [
            "Subscribers are too slow (backlog)",
            "Publisher quota exceeded",
            "Message size too large",
            "Ordering keys are causing hotspots"
        ],
        "answer": "Ordering keys are causing hotspots",
        "explanation": "If using ordering keys, high throughput on a single key can limit scalability (1MB/s limit per key). Slow subscribers cause increased backlog.",
        "frequency_score": 7
    },
    {
        "id": 506,
        "topic": "Apache Kafka",
        "companies": [
            "Google",
            "LinkedIn",
            "Uber",
            "Netflix"
        ],
        "question": "You need to ensure strict ordering of messages in Kafka for a specific Transaction ID. How should you configure the producer? ",
        "options": [
            "Use the Transaction ID as the partition key",
            "Use a single partition for the entire topic",
            "Enable idempotent producer",
            "Increase replication factor"
        ],
        "answer": "Use the Transaction ID as the partition key",
        "explanation": "Kafka guarantees ordering WITHIN a partition. Using the Entity ID as the key ensures all messages for that entity go to the same partition.",
        "frequency_score": 6
    },
    {
        "id": 507,
        "topic": "Apache Kafka",
        "companies": [
            "Google",
            "LinkedIn",
            "Uber",
            "Netflix"
        ],
        "question": "You need to ensure strict ordering of messages in Kafka for a specific User ID. How should you configure the producer? ",
        "options": [
            "Use the User ID as the partition key",
            "Use a single partition for the entire topic",
            "Enable idempotent producer",
            "Increase replication factor"
        ],
        "answer": "Use the User ID as the partition key",
        "explanation": "Kafka guarantees ordering WITHIN a partition. Using the Entity ID as the key ensures all messages for that entity go to the same partition.",
        "frequency_score": 6
    },
    {
        "id": 508,
        "topic": "Algorithms",
        "companies": [
            "Google",
            "Amazon",
            "Microsoft"
        ],
        "question": "What is the time complexity of a Merge Sort algorithm in the worst case? ",
        "options": [
            "O(n log n)",
            "O(n^2)",
            "O(n)",
            "O(log n)"
        ],
        "answer": "O(n log n)",
        "explanation": "Merge Sort is O(n log n). Quick Sort is O(n^2) in worst case (though avg O(n log n)). Bubble Sort is O(n^2).",
        "frequency_score": 8
    },
    {
        "id": 509,
        "topic": "Algorithms",
        "companies": [
            "Google",
            "Amazon",
            "Microsoft"
        ],
        "question": "What is the time complexity of a Bubble Sort algorithm in the worst case? ",
        "options": [
            "O(n log n)",
            "O(n^2)",
            "O(n)",
            "O(log n)"
        ],
        "answer": "O(n^2)",
        "explanation": "Merge Sort is O(n log n). Quick Sort is O(n^2) in worst case (though avg O(n log n)). Bubble Sort is O(n^2).",
        "frequency_score": 8
    },
    {
        "id": 510,
        "topic": "BigQuery",
        "companies": [
            "Google",
            "Spotify",
            "Twitter"
        ],
        "question": "You need to store 500 TB of transaction records data in BigQuery. The data is accessed rarely (every 6 months). Which storage class fits best to minimize costs? ",
        "options": [
            "Active Storage",
            "Long-term Storage",
            "Nearline Storage",
            "Coldline Storage"
        ],
        "answer": "Long-term Storage",
        "explanation": "BigQuery Long-term storage applies automatically after 90 days of no modification, reducing price by ~50%.",
        "frequency_score": 10
    },
    {
        "id": 511,
        "topic": "IAM",
        "companies": [
            "Google"
        ],
        "question": "A developer needs to deploy Cloud Functions in a production project. Following the principle of least privilege, which role should you grant? ",
        "options": [
            "Viewer",
            "Editor",
            "Owner",
            "Storage Object Creator"
        ],
        "answer": "Storage Object Creator",
        "explanation": "Always prefer predefined specific roles (like BigQuery Data Viewer, Storage Object Admin) over basic roles (Viewer/Editor/Owner) to ensure least privilege.",
        "frequency_score": 9
    },
    {
        "id": 512,
        "topic": "Apache Kafka",
        "companies": [
            "Google",
            "LinkedIn",
            "Uber",
            "Netflix"
        ],
        "question": "You need to ensure strict ordering of messages in Kafka for a specific Transaction ID. How should you configure the producer? ",
        "options": [
            "Use the Transaction ID as the partition key",
            "Use a single partition for the entire topic",
            "Enable idempotent producer",
            "Increase replication factor"
        ],
        "answer": "Use the Transaction ID as the partition key",
        "explanation": "Kafka guarantees ordering WITHIN a partition. Using the Entity ID as the key ensures all messages for that entity go to the same partition.",
        "frequency_score": 6
    },
    {
        "id": 513,
        "topic": "Apache Kafka",
        "companies": [
            "Google",
            "LinkedIn",
            "Uber",
            "Netflix"
        ],
        "question": "You need to ensure strict ordering of messages in Kafka for a specific User ID. How should you configure the producer? ",
        "options": [
            "Use the User ID as the partition key",
            "Use a single partition for the entire topic",
            "Enable idempotent producer",
            "Increase replication factor"
        ],
        "answer": "Use the User ID as the partition key",
        "explanation": "Kafka guarantees ordering WITHIN a partition. Using the Entity ID as the key ensures all messages for that entity go to the same partition.",
        "frequency_score": 6
    },
    {
        "id": 514,
        "topic": "Cloud Spanner",
        "companies": [
            "Google",
            "Uber",
            "Pokemon GO"
        ],
        "question": "You are designing a global banking ledger. You require strong consistency and horizontal scalability. Which database service should you choose? ",
        "options": [
            "Cloud Spanner",
            "Cloud SQL",
            "Bigtable",
            "Firestore"
        ],
        "answer": "Cloud Spanner",
        "explanation": "Cloud Spanner is the only service providing global strong consistency and horizontal scalability with relational semantics (SQL).",
        "frequency_score": 8
    },
    {
        "id": 515,
        "topic": "Apache Kafka",
        "companies": [
            "Google",
            "LinkedIn",
            "Uber",
            "Netflix"
        ],
        "question": "You need to ensure strict ordering of messages in Kafka for a specific User ID. How should you configure the producer? ",
        "options": [
            "Use the User ID as the partition key",
            "Use a single partition for the entire topic",
            "Enable idempotent producer",
            "Increase replication factor"
        ],
        "answer": "Use the User ID as the partition key",
        "explanation": "Kafka guarantees ordering WITHIN a partition. Using the Entity ID as the key ensures all messages for that entity go to the same partition.",
        "frequency_score": 6
    },
    {
        "id": 516,
        "topic": "Data Structures",
        "companies": [
            "Google",
            "Amazon",
            "Microsoft",
            "Facebook"
        ],
        "question": "You need to implement a look-up service that checks if a user ID exists in a set of 1 billion users with O(log n) average time complexity. Which data structure is best? ",
        "options": [
            "Hash Table / HashSet",
            "Binary Search Tree",
            "Linked List",
            "Array"
        ],
        "answer": "Binary Search Tree",
        "explanation": "Hash Tables provide O(1) average case lookup. BST is O(log n).",
        "frequency_score": 8
    },
    {
        "id": 517,
        "topic": "Algorithms",
        "companies": [
            "Google",
            "Amazon",
            "Microsoft"
        ],
        "question": "What is the time complexity of a Merge Sort algorithm in the worst case? ",
        "options": [
            "O(n log n)",
            "O(n^2)",
            "O(n)",
            "O(log n)"
        ],
        "answer": "O(n log n)",
        "explanation": "Merge Sort is O(n log n). Quick Sort is O(n^2) in worst case (though avg O(n log n)). Bubble Sort is O(n^2).",
        "frequency_score": 8
    },
    {
        "id": 518,
        "topic": "BigQuery",
        "companies": [
            "Google",
            "Spotify",
            "Twitter"
        ],
        "question": "You need to store 1 PB of sensor metrics data in BigQuery. The data is accessed daily. Which storage class fits best to minimize costs? ",
        "options": [
            "Active Storage",
            "Long-term Storage",
            "Nearline Storage",
            "Coldline Storage"
        ],
        "answer": "Active Storage",
        "explanation": "BigQuery Long-term storage applies automatically after 90 days of no modification, reducing price by ~50%.",
        "frequency_score": 10
    },
    {
        "id": 519,
        "topic": "Apache Spark",
        "companies": [
            "Google",
            "Databricks",
            "Amazon"
        ],
        "question": "In Spark, what is the difference between a Transformation and an Action? ",
        "options": [
            "Transformations are lazy, Actions match strict execution",
            "Actions are lazy, Transformations trigger execution",
            "They are the same",
            "Transformations save to disk, Actions read from disk"
        ],
        "answer": "Transformations are lazy, Actions match strict execution",
        "explanation": "Transformations (like map, filter) build the DAG but do not execute. Actions (like count, collect, save) trigger the actual computation.",
        "frequency_score": 6
    },
    {
        "id": 520,
        "topic": "Apache Kafka",
        "companies": [
            "Google",
            "LinkedIn",
            "Uber",
            "Netflix"
        ],
        "question": "You need to ensure strict ordering of messages in Kafka for a specific Device ID. How should you configure the producer? ",
        "options": [
            "Use the Device ID as the partition key",
            "Use a single partition for the entire topic",
            "Enable idempotent producer",
            "Increase replication factor"
        ],
        "answer": "Use the Device ID as the partition key",
        "explanation": "Kafka guarantees ordering WITHIN a partition. Using the Entity ID as the key ensures all messages for that entity go to the same partition.",
        "frequency_score": 6
    },
    {
        "id": 521,
        "topic": "Apache Kafka",
        "companies": [
            "Google",
            "LinkedIn",
            "Uber",
            "Netflix"
        ],
        "question": "You need to ensure strict ordering of messages in Kafka for a specific User ID. How should you configure the producer? ",
        "options": [
            "Use the User ID as the partition key",
            "Use a single partition for the entire topic",
            "Enable idempotent producer",
            "Increase replication factor"
        ],
        "answer": "Use the User ID as the partition key",
        "explanation": "Kafka guarantees ordering WITHIN a partition. Using the Entity ID as the key ensures all messages for that entity go to the same partition.",
        "frequency_score": 6
    },
    {
        "id": 522,
        "topic": "Cloud Storage",
        "companies": [
            "Google",
            "Snapchat"
        ],
        "question": "You are designing a storage solution for profile pictures. The requirement is access once a year. What storage class should you use? ",
        "options": [
            "Standard",
            "Nearline",
            "Coldline",
            "Archive"
        ],
        "answer": "Archive",
        "explanation": "Standard for hot data. Nearline < 1/month. Coldline < 1/quarter. Archive < 1/year.",
        "frequency_score": 6
    },
    {
        "id": 523,
        "topic": "Apache Spark",
        "companies": [
            "Google",
            "Databricks",
            "Facebook",
            "Netflix"
        ],
        "question": "You are optimizing a Spark job that is suffering from data skew. You are joining a large skewed table with a small reference table. Which technique is most effective? ",
        "options": [
            "Salting the key",
            "Increasing the number of executors",
            "Using a larger instance type",
            "Broadcasting the large table"
        ],
        "answer": "Salting the key",
        "explanation": "Salting adds a random prefix to the skewed key to distribute it. Broadcasting is best for Skewed Joins where one table is small.",
        "frequency_score": 6
    },
    {
        "id": 524,
        "topic": "Data Structures",
        "companies": [
            "Google",
            "Amazon",
            "Microsoft",
            "Facebook"
        ],
        "question": "You need to implement a look-up service that checks if a user ID exists in a set of 1 billion users with O(1) average time complexity. Which data structure is best? ",
        "options": [
            "Hash Table / HashSet",
            "Binary Search Tree",
            "Linked List",
            "Array"
        ],
        "answer": "Hash Table / HashSet",
        "explanation": "Hash Tables provide O(1) average case lookup. BST is O(log n).",
        "frequency_score": 8
    },
    {
        "id": 525,
        "topic": "Cloud Storage",
        "companies": [
            "Google",
            "Snapchat"
        ],
        "question": "You are designing a storage solution for daily analytics content. The requirement is access once a month. What storage class should you use? ",
        "options": [
            "Standard",
            "Nearline",
            "Coldline",
            "Archive"
        ],
        "answer": "Nearline",
        "explanation": "Standard for hot data. Nearline < 1/month. Coldline < 1/quarter. Archive < 1/year.",
        "frequency_score": 6
    },
    {
        "id": 526,
        "topic": "Apache Kafka",
        "companies": [
            "Google",
            "LinkedIn",
            "Uber",
            "Netflix"
        ],
        "question": "You need to ensure strict ordering of messages in Kafka for a specific User ID. How should you configure the producer? ",
        "options": [
            "Use the User ID as the partition key",
            "Use a single partition for the entire topic",
            "Enable idempotent producer",
            "Increase replication factor"
        ],
        "answer": "Use the User ID as the partition key",
        "explanation": "Kafka guarantees ordering WITHIN a partition. Using the Entity ID as the key ensures all messages for that entity go to the same partition.",
        "frequency_score": 6
    },
    {
        "id": 527,
        "topic": "Bigtable",
        "companies": [
            "Google",
            "Spotify"
        ],
        "question": "You are designing a Bigtable schema for financial transactions. Queries will primarily be retrieve most recent events globally. Which row key design is optimal? ",
        "options": [
            "SensorID#Date",
            "Date#SensorID",
            "ReverseTimestamp#SensorID",
            "Random#SensorID"
        ],
        "answer": "ReverseTimestamp#SensorID",
        "explanation": "Avoid starting with timestamp to prevent hotspots. Use EntityID first for entity-lookup queries. Use ReverseTimestamp for 'latest items' queries globally.",
        "frequency_score": 7
    },
    {
        "id": 528,
        "topic": "BigQuery",
        "companies": [
            "Google",
            "Spotify",
            "Twitter"
        ],
        "question": "You need to store 50 TB of clickstream data data in BigQuery. The data is accessed daily. Which storage class fits best to minimize costs? ",
        "options": [
            "Active Storage",
            "Long-term Storage",
            "Nearline Storage",
            "Coldline Storage"
        ],
        "answer": "Active Storage",
        "explanation": "BigQuery Long-term storage applies automatically after 90 days of no modification, reducing price by ~50%.",
        "frequency_score": 10
    },
    {
        "id": 529,
        "topic": "Apache Spark",
        "companies": [
            "Google",
            "Databricks",
            "Amazon"
        ],
        "question": "In Spark, what is the difference between a Transformation and an Action? ",
        "options": [
            "Transformations are lazy, Actions match strict execution",
            "Actions are lazy, Transformations trigger execution",
            "They are the same",
            "Transformations save to disk, Actions read from disk"
        ],
        "answer": "Transformations are lazy, Actions match strict execution",
        "explanation": "Transformations (like map, filter) build the DAG but do not execute. Actions (like count, collect, save) trigger the actual computation.",
        "frequency_score": 6
    },
    {
        "id": 530,
        "topic": "Dataflow",
        "companies": [
            "Google",
            "Spotify",
            "New York Times"
        ],
        "question": "You are building a streaming pipeline to process server logs. You need to handle rolling averages every minute for the last hour. What windowing strategy is appropriate? ",
        "options": [
            "Fixed Windows",
            "Sliding Windows",
            "Session Windows",
            "Global Windows"
        ],
        "answer": "Sliding Windows",
        "explanation": "Session windows gap-fill based on activity. Sliding windows overlap (e.g. every 5 min show last 1 hour). Fixed windows are tumbling.",
        "frequency_score": 9
    },
    {
        "id": 531,
        "topic": "Apache Spark",
        "companies": [
            "Google",
            "Databricks",
            "Facebook",
            "Netflix"
        ],
        "question": "You are optimizing a Spark job that is suffering from data skew. One task takes 10x longer than others during a wide transformation. Which technique is most effective? ",
        "options": [
            "Salting the key",
            "Increasing the number of executors",
            "Using a larger instance type",
            "Broadcasting the large table"
        ],
        "answer": "Salting the key",
        "explanation": "Salting adds a random prefix to the skewed key to distribute it. Broadcasting is best for Skewed Joins where one table is small.",
        "frequency_score": 6
    },
    {
        "id": 532,
        "topic": "Apache Spark",
        "companies": [
            "Google",
            "Databricks",
            "Amazon"
        ],
        "question": "In Spark, what is the difference between a Transformation and an Action? ",
        "options": [
            "Transformations are lazy, Actions match strict execution",
            "Actions are lazy, Transformations trigger execution",
            "They are the same",
            "Transformations save to disk, Actions read from disk"
        ],
        "answer": "Transformations are lazy, Actions match strict execution",
        "explanation": "Transformations (like map, filter) build the DAG but do not execute. Actions (like count, collect, save) trigger the actual computation.",
        "frequency_score": 6
    },
    {
        "id": 533,
        "topic": "Bigtable",
        "companies": [
            "Google",
            "Spotify"
        ],
        "question": "You are designing a Bigtable schema for social media posts. Queries will primarily be retrieve latest events for a specific entity. Which row key design is optimal? ",
        "options": [
            "UserID#Date",
            "Date#UserID",
            "ReverseTimestamp#UserID",
            "Random#UserID"
        ],
        "answer": "UserID#Date",
        "explanation": "Avoid starting with timestamp to prevent hotspots. Use EntityID first for entity-lookup queries. Use ReverseTimestamp for 'latest items' queries globally.",
        "frequency_score": 7
    },
    {
        "id": 534,
        "topic": "Apache Kafka",
        "companies": [
            "Google",
            "LinkedIn",
            "Uber",
            "Netflix"
        ],
        "question": "You need to ensure strict ordering of messages in Kafka for a specific User ID. How should you configure the producer? ",
        "options": [
            "Use the User ID as the partition key",
            "Use a single partition for the entire topic",
            "Enable idempotent producer",
            "Increase replication factor"
        ],
        "answer": "Use the User ID as the partition key",
        "explanation": "Kafka guarantees ordering WITHIN a partition. Using the Entity ID as the key ensures all messages for that entity go to the same partition.",
        "frequency_score": 6
    },
    {
        "id": 535,
        "topic": "Algorithms",
        "companies": [
            "Google",
            "Amazon",
            "Microsoft"
        ],
        "question": "What is the time complexity of a Bubble Sort algorithm in the worst case? ",
        "options": [
            "O(n log n)",
            "O(n^2)",
            "O(n)",
            "O(log n)"
        ],
        "answer": "O(n^2)",
        "explanation": "Merge Sort is O(n log n). Quick Sort is O(n^2) in worst case (though avg O(n log n)). Bubble Sort is O(n^2).",
        "frequency_score": 8
    },
    {
        "id": 536,
        "topic": "BigQuery",
        "companies": [
            "Google",
            "Spotify",
            "Twitter"
        ],
        "question": "You need to store 1 PB of sensor metrics data in BigQuery. The data is accessed once a quarter. Which storage class fits best to minimize costs?",
        "options": [
            "Active Storage",
            "Long-term Storage",
            "Nearline Storage",
            "Coldline Storage"
        ],
        "answer": "Active Storage",
        "explanation": "BigQuery Long-term storage applies automatically after 90 days of no modification, reducing price by ~50%.",
        "frequency_score": 10
    },
    {
        "id": 537,
        "topic": "Apache Kafka",
        "companies": [
            "Google",
            "LinkedIn",
            "Uber",
            "Netflix"
        ],
        "question": "You need to ensure strict ordering of messages in Kafka for a specific Device ID. How should you configure the producer? ",
        "options": [
            "Use the Device ID as the partition key",
            "Use a single partition for the entire topic",
            "Enable idempotent producer",
            "Increase replication factor"
        ],
        "answer": "Use the Device ID as the partition key",
        "explanation": "Kafka guarantees ordering WITHIN a partition. Using the Entity ID as the key ensures all messages for that entity go to the same partition.",
        "frequency_score": 6
    },
    {
        "id": 538,
        "topic": "Apache Kafka",
        "companies": [
            "Google",
            "LinkedIn",
            "Uber",
            "Netflix"
        ],
        "question": "You need to ensure strict ordering of messages in Kafka for a specific Transaction ID. How should you configure the producer? ",
        "options": [
            "Use the Transaction ID as the partition key",
            "Use a single partition for the entire topic",
            "Enable idempotent producer",
            "Increase replication factor"
        ],
        "answer": "Use the Transaction ID as the partition key",
        "explanation": "Kafka guarantees ordering WITHIN a partition. Using the Entity ID as the key ensures all messages for that entity go to the same partition.",
        "frequency_score": 6
    },
    {
        "id": 539,
        "topic": "Algorithms",
        "companies": [
            "Google",
            "Amazon",
            "Microsoft"
        ],
        "question": "What is the time complexity of a Quick Sort algorithm in the worst case? ",
        "options": [
            "O(n log n)",
            "O(n^2)",
            "O(n)",
            "O(log n)"
        ],
        "answer": "O(n^2)",
        "explanation": "Merge Sort is O(n log n). Quick Sort is O(n^2) in worst case (though avg O(n log n)). Bubble Sort is O(n^2).",
        "frequency_score": 8
    },
    {
        "id": 540,
        "topic": "Cloud Spanner",
        "companies": [
            "Google",
            "Uber",
            "Pokemon GO"
        ],
        "question": "You are designing a global banking ledger. You require strong consistency and 99.999% availability. Which database service should you choose? ",
        "options": [
            "Cloud Spanner",
            "Cloud SQL",
            "Bigtable",
            "Firestore"
        ],
        "answer": "Cloud Spanner",
        "explanation": "Cloud Spanner is the only service providing global strong consistency and horizontal scalability with relational semantics (SQL).",
        "frequency_score": 8
    },
    {
        "id": 541,
        "topic": "Cloud Storage",
        "companies": [
            "Google",
            "Snapchat"
        ],
        "question": "You are designing a storage solution for profile pictures. The requirement is high frequency access. What storage class should you use? ",
        "options": [
            "Standard",
            "Nearline",
            "Coldline",
            "Archive"
        ],
        "answer": "Standard",
        "explanation": "Standard for hot data. Nearline < 1/month. Coldline < 1/quarter. Archive < 1/year.",
        "frequency_score": 6
    },
    {
        "id": 542,
        "topic": "Pub/Sub",
        "companies": [
            "Google",
            "Uber"
        ],
        "question": "Your application publishes 1 million/sec messages to Pub/Sub. You observe increased end-to-end latency and growing backlog. What is the most likely cause? ",
        "options": [
            "Subscribers are too slow (backlog)",
            "Publisher quota exceeded",
            "Message size too large",
            "Ordering keys are causing hotspots"
        ],
        "answer": "Subscribers are too slow (backlog)",
        "explanation": "If using ordering keys, high throughput on a single key can limit scalability (1MB/s limit per key). Slow subscribers cause increased backlog.",
        "frequency_score": 7
    },
    {
        "id": 543,
        "topic": "Bigtable",
        "companies": [
            "Google",
            "Spotify"
        ],
        "question": "You are designing a Bigtable schema for IoT events. Queries will primarily be retrieve most recent events globally. Which row key design is optimal? ",
        "options": [
            "UserID#Date",
            "Date#UserID",
            "ReverseTimestamp#UserID",
            "Random#UserID"
        ],
        "answer": "ReverseTimestamp#UserID",
        "explanation": "Avoid starting with timestamp to prevent hotspots. Use EntityID first for entity-lookup queries. Use ReverseTimestamp for 'latest items' queries globally.",
        "frequency_score": 7
    },
    {
        "id": 544,
        "topic": "IAM",
        "companies": [
            "Google"
        ],
        "question": "A developer needs to upload files to a bucket in a production project. Following the principle of least privilege, which role should you grant? ",
        "options": [
            "Viewer",
            "Editor",
            "Owner",
            "Cloud Functions Developer"
        ],
        "answer": "Cloud Functions Developer",
        "explanation": "Always prefer predefined specific roles (like BigQuery Data Viewer, Storage Object Admin) over basic roles (Viewer/Editor/Owner) to ensure least privilege.",
        "frequency_score": 9
    },
    {
        "id": 545,
        "topic": "Cloud Spanner",
        "companies": [
            "Google",
            "Uber",
            "Pokemon GO"
        ],
        "question": "You are designing a global banking ledger. You require strong consistency and horizontal scalability. Which database service should you choose? ",
        "options": [
            "Cloud Spanner",
            "Cloud SQL",
            "Bigtable",
            "Firestore"
        ],
        "answer": "Cloud Spanner",
        "explanation": "Cloud Spanner is the only service providing global strong consistency and horizontal scalability with relational semantics (SQL).",
        "frequency_score": 8
    },
    {
        "id": 546,
        "topic": "Data Structures",
        "companies": [
            "Google",
            "Amazon",
            "Microsoft",
            "Facebook"
        ],
        "question": "You need to implement a look-up service that checks if a user ID exists in a set of 1 billion users with O(1) average time complexity. Which data structure is best? ",
        "options": [
            "Hash Table / HashSet",
            "Binary Search Tree",
            "Linked List",
            "Array"
        ],
        "answer": "Hash Table / HashSet",
        "explanation": "Hash Tables provide O(1) average case lookup. BST is O(log n).",
        "frequency_score": 8
    },
    {
        "id": 547,
        "topic": "Apache Kafka",
        "companies": [
            "Google",
            "LinkedIn",
            "Uber",
            "Netflix"
        ],
        "question": "You need to ensure strict ordering of messages in Kafka for a specific Transaction ID. How should you configure the producer? ",
        "options": [
            "Use the Transaction ID as the partition key",
            "Use a single partition for the entire topic",
            "Enable idempotent producer",
            "Increase replication factor"
        ],
        "answer": "Use the Transaction ID as the partition key",
        "explanation": "Kafka guarantees ordering WITHIN a partition. Using the Entity ID as the key ensures all messages for that entity go to the same partition.",
        "frequency_score": 6
    },
    {
        "id": 548,
        "topic": "Algorithms",
        "companies": [
            "Google",
            "Amazon",
            "Microsoft"
        ],
        "question": "What is the time complexity of a Quick Sort algorithm in the worst case? ",
        "options": [
            "O(n log n)",
            "O(n^2)",
            "O(n)",
            "O(log n)"
        ],
        "answer": "O(n^2)",
        "explanation": "Merge Sort is O(n log n). Quick Sort is O(n^2) in worst case (though avg O(n log n)). Bubble Sort is O(n^2).",
        "frequency_score": 8
    },
    {
        "id": 549,
        "topic": "Cloud Spanner",
        "companies": [
            "Google",
            "Uber",
            "Pokemon GO"
        ],
        "question": "You are designing a global banking ledger. You require strong consistency and horizontal scalability. Which database service should you choose? ",
        "options": [
            "Cloud Spanner",
            "Cloud SQL",
            "Bigtable",
            "Firestore"
        ],
        "answer": "Cloud Spanner",
        "explanation": "Cloud Spanner is the only service providing global strong consistency and horizontal scalability with relational semantics (SQL).",
        "frequency_score": 8
    },
    {
        "id": 550,
        "topic": "Apache Spark",
        "companies": [
            "Google",
            "Databricks",
            "Facebook",
            "Netflix"
        ],
        "question": "You are optimizing a Spark job that is suffering from data skew. You are joining a large skewed table with a small reference table. Which technique is most effective? ",
        "options": [
            "Salting the key",
            "Increasing the number of executors",
            "Using a larger instance type",
            "Broadcasting the large table"
        ],
        "answer": "Salting the key",
        "explanation": "Salting adds a random prefix to the skewed key to distribute it. Broadcasting is best for Skewed Joins where one table is small.",
        "frequency_score": 6
    },
    {
        "id": 551,
        "topic": "Dataflow",
        "companies": [
            "Google",
            "Spotify",
            "New York Times"
        ],
        "question": "You are building a streaming pipeline to process IoT temperature sensors. You need to handle hourly reporting. What windowing strategy is appropriate? ",
        "options": [
            "Fixed Windows",
            "Sliding Windows",
            "Session Windows",
            "Global Windows"
        ],
        "answer": "Fixed Windows",
        "explanation": "Session windows gap-fill based on activity. Sliding windows overlap (e.g. every 5 min show last 1 hour). Fixed windows are tumbling.",
        "frequency_score": 9
    },
    {
        "id": 552,
        "topic": "Apache Kafka",
        "companies": [
            "Google",
            "LinkedIn"
        ],
        "question": "What happens if a Kafka Consumer Group has more consumers than partitions in the topic? ",
        "options": [
            "Some consumers will be idle",
            "Throughput increases linearly",
            "Kafka automatically creates more partitions",
            "The extra consumers duplicate the data"
        ],
        "answer": "Some consumers will be idle",
        "explanation": "A partition can be consumed by only one consumer within a group at a time. Extra consumers stay idle.",
        "frequency_score": 6
    },
    {
        "id": 553,
        "topic": "Data Structures",
        "companies": [
            "Google",
            "Amazon",
            "Microsoft",
            "Facebook"
        ],
        "question": "You need to implement a look-up service that checks if a user ID exists in a set of 1 billion users with O(log n) average time complexity. Which data structure is best? ",
        "options": [
            "Hash Table / HashSet",
            "Binary Search Tree",
            "Linked List",
            "Array"
        ],
        "answer": "Binary Search Tree",
        "explanation": "Hash Tables provide O(1) average case lookup. BST is O(log n).",
        "frequency_score": 8
    },
    {
        "id": 554,
        "topic": "Algorithms",
        "companies": [
            "Google",
            "Amazon",
            "Microsoft"
        ],
        "question": "What is the time complexity of a Merge Sort algorithm in the worst case? ",
        "options": [
            "O(n log n)",
            "O(n^2)",
            "O(n)",
            "O(log n)"
        ],
        "answer": "O(n log n)",
        "explanation": "Merge Sort is O(n log n). Quick Sort is O(n^2) in worst case (though avg O(n log n)). Bubble Sort is O(n^2).",
        "frequency_score": 8
    },
    {
        "id": 555,
        "topic": "Pub/Sub",
        "companies": [
            "Google",
            "Uber"
        ],
        "question": "Your application publishes high throughput messages to Pub/Sub. You observe increased end-to-end latency and growing backlog. What is the most likely cause? ",
        "options": [
            "Subscribers are too slow (backlog)",
            "Publisher quota exceeded",
            "Message size too large",
            "Ordering keys are causing hotspots"
        ],
        "answer": "Subscribers are too slow (backlog)",
        "explanation": "If using ordering keys, high throughput on a single key can limit scalability (1MB/s limit per key). Slow subscribers cause increased backlog.",
        "frequency_score": 7
    },
    {
        "id": 556,
        "topic": "Data Structures",
        "companies": [
            "Google",
            "Amazon",
            "Microsoft",
            "Facebook"
        ],
        "question": "You need to implement a look-up service that checks if a user ID exists in a set of 1 billion users with O(log n) average time complexity. Which data structure is best? ",
        "options": [
            "Hash Table / HashSet",
            "Binary Search Tree",
            "Linked List",
            "Array"
        ],
        "answer": "Binary Search Tree",
        "explanation": "Hash Tables provide O(1) average case lookup. BST is O(log n).",
        "frequency_score": 8
    },
    {
        "id": 557,
        "topic": "Dataflow",
        "companies": [
            "Google",
            "Spotify",
            "New York Times"
        ],
        "question": "You are building a streaming pipeline to process IoT temperature sensors. You need to handle periods of user activity separated by gaps. What windowing strategy is appropriate? ",
        "options": [
            "Fixed Windows",
            "Sliding Windows",
            "Session Windows",
            "Global Windows"
        ],
        "answer": "Session Windows",
        "explanation": "Session windows gap-fill based on activity. Sliding windows overlap (e.g. every 5 min show last 1 hour). Fixed windows are tumbling.",
        "frequency_score": 9
    },
    {
        "id": 558,
        "topic": "Apache Kafka",
        "companies": [
            "Google",
            "LinkedIn"
        ],
        "question": "What happens if a Kafka Consumer Group has more consumers than partitions in the topic? ",
        "options": [
            "Some consumers will be idle",
            "Throughput increases linearly",
            "Kafka automatically creates more partitions",
            "The extra consumers duplicate the data"
        ],
        "answer": "Some consumers will be idle",
        "explanation": "A partition can be consumed by only one consumer within a group at a time. Extra consumers stay idle.",
        "frequency_score": 6
    },
    {
        "id": 559,
        "topic": "IAM",
        "companies": [
            "Google"
        ],
        "question": "A developer needs to view BigQuery datasets in a production project. Following the principle of least privilege, which role should you grant? ",
        "options": [
            "Viewer",
            "Editor",
            "Owner",
            "Storage Object Creator"
        ],
        "answer": "Storage Object Creator",
        "explanation": "Always prefer predefined specific roles (like BigQuery Data Viewer, Storage Object Admin) over basic roles (Viewer/Editor/Owner) to ensure least privilege.",
        "frequency_score": 9
    },
    {
        "id": 560,
        "topic": "Dataflow",
        "companies": [
            "Google",
            "Spotify",
            "New York Times"
        ],
        "question": "You are building a streaming pipeline to process server logs. You need to handle periods of user activity separated by gaps. What windowing strategy is appropriate? ",
        "options": [
            "Fixed Windows",
            "Sliding Windows",
            "Session Windows",
            "Global Windows"
        ],
        "answer": "Session Windows",
        "explanation": "Session windows gap-fill based on activity. Sliding windows overlap (e.g. every 5 min show last 1 hour). Fixed windows are tumbling.",
        "frequency_score": 9
    },
    {
        "id": 561,
        "topic": "BigQuery",
        "companies": [
            "Google",
            "Spotify",
            "Twitter"
        ],
        "question": "You need to store 50 TB of clickstream data data in BigQuery. The data is accessed daily. Which storage class fits best to minimize costs? ",
        "options": [
            "Active Storage",
            "Long-term Storage",
            "Nearline Storage",
            "Coldline Storage"
        ],
        "answer": "Active Storage",
        "explanation": "BigQuery Long-term storage applies automatically after 90 days of no modification, reducing price by ~50%.",
        "frequency_score": 10
    },
    {
        "id": 562,
        "topic": "Apache Spark",
        "companies": [
            "Google",
            "Databricks",
            "Amazon"
        ],
        "question": "In Spark, what is the difference between a Transformation and an Action? ",
        "options": [
            "Transformations are lazy, Actions match strict execution",
            "Actions are lazy, Transformations trigger execution",
            "They are the same",
            "Transformations save to disk, Actions read from disk"
        ],
        "answer": "Transformations are lazy, Actions match strict execution",
        "explanation": "Transformations (like map, filter) build the DAG but do not execute. Actions (like count, collect, save) trigger the actual computation.",
        "frequency_score": 6
    },
    {
        "id": 563,
        "topic": "Apache Spark",
        "companies": [
            "Google",
            "Databricks",
            "Amazon"
        ],
        "question": "In Spark, what is the difference between a Transformation and an Action? ",
        "options": [
            "Transformations are lazy, Actions match strict execution",
            "Actions are lazy, Transformations trigger execution",
            "They are the same",
            "Transformations save to disk, Actions read from disk"
        ],
        "answer": "Transformations are lazy, Actions match strict execution",
        "explanation": "Transformations (like map, filter) build the DAG but do not execute. Actions (like count, collect, save) trigger the actual computation.",
        "frequency_score": 6
    },
    {
        "id": 564,
        "topic": "Apache Kafka",
        "companies": [
            "Google",
            "LinkedIn"
        ],
        "question": "What happens if a Kafka Consumer Group has more consumers than partitions in the topic? ",
        "options": [
            "Some consumers will be idle",
            "Throughput increases linearly",
            "Kafka automatically creates more partitions",
            "The extra consumers duplicate the data"
        ],
        "answer": "Some consumers will be idle",
        "explanation": "A partition can be consumed by only one consumer within a group at a time. Extra consumers stay idle.",
        "frequency_score": 6
    },
    {
        "id": 565,
        "topic": "Bigtable",
        "companies": [
            "Google",
            "Spotify"
        ],
        "question": "You are designing a Bigtable schema for social media posts. Queries will primarily be retrieve most recent events globally. Which row key design is optimal? ",
        "options": [
            "DeviceID#Timestamp",
            "Timestamp#DeviceID",
            "ReverseTimestamp#DeviceID",
            "Random#DeviceID"
        ],
        "answer": "ReverseTimestamp#DeviceID",
        "explanation": "Avoid starting with timestamp to prevent hotspots. Use EntityID first for entity-lookup queries. Use ReverseTimestamp for 'latest items' queries globally.",
        "frequency_score": 7
    },
    {
        "id": 566,
        "topic": "Apache Kafka",
        "companies": [
            "Google",
            "LinkedIn",
            "Uber",
            "Netflix"
        ],
        "question": "You need to ensure strict ordering of messages in Kafka for a specific User ID. How should you configure the producer? ",
        "options": [
            "Use the User ID as the partition key",
            "Use a single partition for the entire topic",
            "Enable idempotent producer",
            "Increase replication factor"
        ],
        "answer": "Use the User ID as the partition key",
        "explanation": "Kafka guarantees ordering WITHIN a partition. Using the Entity ID as the key ensures all messages for that entity go to the same partition.",
        "frequency_score": 6
    },
    {
        "id": 567,
        "topic": "Bigtable",
        "companies": [
            "Google",
            "Spotify"
        ],
        "question": "You are designing a Bigtable schema for IoT events. Queries will primarily be retrieve most recent events globally. Which row key design is optimal? ",
        "options": [
            "DeviceID#Date",
            "Date#DeviceID",
            "ReverseTimestamp#DeviceID",
            "Random#DeviceID"
        ],
        "answer": "ReverseTimestamp#DeviceID",
        "explanation": "Avoid starting with timestamp to prevent hotspots. Use EntityID first for entity-lookup queries. Use ReverseTimestamp for 'latest items' queries globally.",
        "frequency_score": 7
    },
    {
        "id": 568,
        "topic": "Cloud Spanner",
        "companies": [
            "Google",
            "Uber",
            "Pokemon GO"
        ],
        "question": "You are designing a global banking ledger. You require strong consistency and horizontal scalability. Which database service should you choose? ",
        "options": [
            "Cloud Spanner",
            "Cloud SQL",
            "Bigtable",
            "Firestore"
        ],
        "answer": "Cloud Spanner",
        "explanation": "Cloud Spanner is the only service providing global strong consistency and horizontal scalability with relational semantics (SQL).",
        "frequency_score": 8
    },
    {
        "id": 569,
        "topic": "Apache Kafka",
        "companies": [
            "Google",
            "LinkedIn"
        ],
        "question": "What happens if a Kafka Consumer Group has more consumers than partitions in the topic? ",
        "options": [
            "Some consumers will be idle",
            "Throughput increases linearly",
            "Kafka automatically creates more partitions",
            "The extra consumers duplicate the data"
        ],
        "answer": "Some consumers will be idle",
        "explanation": "A partition can be consumed by only one consumer within a group at a time. Extra consumers stay idle.",
        "frequency_score": 6
    },
    {
        "id": 570,
        "topic": "Bigtable",
        "companies": [
            "Google",
            "Spotify"
        ],
        "question": "You are designing a Bigtable schema for financial transactions. Queries will primarily be retrieve latest events for a specific entity. Which row key design is optimal? ",
        "options": [
            "SensorID#Timestamp",
            "Timestamp#SensorID",
            "ReverseTimestamp#SensorID",
            "Random#SensorID"
        ],
        "answer": "SensorID#Timestamp",
        "explanation": "Avoid starting with timestamp to prevent hotspots. Use EntityID first for entity-lookup queries. Use ReverseTimestamp for 'latest items' queries globally.",
        "frequency_score": 7
    },
    {
        "id": 571,
        "topic": "Apache Spark",
        "companies": [
            "Google",
            "Databricks",
            "Amazon"
        ],
        "question": "In Spark, what is the difference between a Transformation and an Action? ",
        "options": [
            "Transformations are lazy, Actions match strict execution",
            "Actions are lazy, Transformations trigger execution",
            "They are the same",
            "Transformations save to disk, Actions read from disk"
        ],
        "answer": "Transformations are lazy, Actions match strict execution",
        "explanation": "Transformations (like map, filter) build the DAG but do not execute. Actions (like count, collect, save) trigger the actual computation.",
        "frequency_score": 6
    },
    {
        "id": 572,
        "topic": "Data Structures",
        "companies": [
            "Google",
            "Amazon",
            "Microsoft",
            "Facebook"
        ],
        "question": "You need to implement a look-up service that checks if a user ID exists in a set of 1 billion users with O(1) average time complexity. Which data structure is best? ",
        "options": [
            "Hash Table / HashSet",
            "Binary Search Tree",
            "Linked List",
            "Array"
        ],
        "answer": "Hash Table / HashSet",
        "explanation": "Hash Tables provide O(1) average case lookup. BST is O(log n).",
        "frequency_score": 8
    },
    {
        "id": 573,
        "topic": "IAM",
        "companies": [
            "Google"
        ],
        "question": "A developer needs to view BigQuery datasets in a production project. Following the principle of least privilege, which role should you grant? ",
        "options": [
            "Viewer",
            "Editor",
            "Owner",
            "BigQuery Data Viewer"
        ],
        "answer": "BigQuery Data Viewer",
        "explanation": "Always prefer predefined specific roles (like BigQuery Data Viewer, Storage Object Admin) over basic roles (Viewer/Editor/Owner) to ensure least privilege.",
        "frequency_score": 9
    },
    {
        "id": 574,
        "topic": "Apache Spark",
        "companies": [
            "Google",
            "Databricks",
            "Facebook",
            "Netflix"
        ],
        "question": "You are optimizing a Spark job that is suffering from data skew. You are joining a large skewed table with a small reference table. Which technique is most effective? ",
        "options": [
            "Salting the key",
            "Increasing the number of executors",
            "Using a larger instance type",
            "Broadcasting the large table"
        ],
        "answer": "Salting the key",
        "explanation": "Salting adds a random prefix to the skewed key to distribute it. Broadcasting is best for Skewed Joins where one table is small.",
        "frequency_score": 6
    },
    {
        "id": 575,
        "topic": "Algorithms",
        "companies": [
            "Google",
            "Amazon",
            "Microsoft"
        ],
        "question": "What is the time complexity of a Quick Sort algorithm in the worst case? ",
        "options": [
            "O(n log n)",
            "O(n^2)",
            "O(n)",
            "O(log n)"
        ],
        "answer": "O(n^2)",
        "explanation": "Merge Sort is O(n log n). Quick Sort is O(n^2) in worst case (though avg O(n log n)). Bubble Sort is O(n^2).",
        "frequency_score": 8
    },
    {
        "id": 576,
        "topic": "Bigtable",
        "companies": [
            "Google",
            "Spotify"
        ],
        "question": "You are designing a Bigtable schema for financial transactions. Queries will primarily be retrieve most recent events globally. Which row key design is optimal? ",
        "options": [
            "SensorID#Timestamp",
            "Timestamp#SensorID",
            "ReverseTimestamp#SensorID",
            "Random#SensorID"
        ],
        "answer": "ReverseTimestamp#SensorID",
        "explanation": "Avoid starting with timestamp to prevent hotspots. Use EntityID first for entity-lookup queries. Use ReverseTimestamp for 'latest items' queries globally.",
        "frequency_score": 7
    },
    {
        "id": 577,
        "topic": "Apache Spark",
        "companies": [
            "Google",
            "Databricks",
            "Facebook",
            "Netflix"
        ],
        "question": "You are optimizing a Spark job that is suffering from data skew. One task takes 10x longer than others during a wide transformation. Which technique is most effective? ",
        "options": [
            "Salting the key",
            "Increasing the number of executors",
            "Using a larger instance type",
            "Broadcasting the large table"
        ],
        "answer": "Salting the key",
        "explanation": "Salting adds a random prefix to the skewed key to distribute it. Broadcasting is best for Skewed Joins where one table is small.",
        "frequency_score": 6
    },
    {
        "id": 578,
        "topic": "Apache Kafka",
        "companies": [
            "Google",
            "LinkedIn",
            "Uber",
            "Netflix"
        ],
        "question": "You need to ensure strict ordering of messages in Kafka for a specific User ID. How should you configure the producer? ",
        "options": [
            "Use the User ID as the partition key",
            "Use a single partition for the entire topic",
            "Enable idempotent producer",
            "Increase replication factor"
        ],
        "answer": "Use the User ID as the partition key",
        "explanation": "Kafka guarantees ordering WITHIN a partition. Using the Entity ID as the key ensures all messages for that entity go to the same partition.",
        "frequency_score": 6
    },
    {
        "id": 579,
        "topic": "Apache Kafka",
        "companies": [
            "Google",
            "LinkedIn",
            "Uber",
            "Netflix"
        ],
        "question": "You need to ensure strict ordering of messages in Kafka for a specific User ID. How should you configure the producer? ",
        "options": [
            "Use the User ID as the partition key",
            "Use a single partition for the entire topic",
            "Enable idempotent producer",
            "Increase replication factor"
        ],
        "answer": "Use the User ID as the partition key",
        "explanation": "Kafka guarantees ordering WITHIN a partition. Using the Entity ID as the key ensures all messages for that entity go to the same partition.",
        "frequency_score": 6
    },
    {
        "id": 580,
        "topic": "BigQuery",
        "companies": [
            "Google",
            "Spotify",
            "Twitter"
        ],
        "question": "You need to store 2 PB of transaction records data in BigQuery. The data is accessed daily. Which storage class fits best to minimize costs?",
        "options": [
            "Active Storage",
            "Long-term Storage",
            "Nearline Storage",
            "Coldline Storage"
        ],
        "answer": "Active Storage",
        "explanation": "BigQuery Long-term storage applies automatically after 90 days of no modification, reducing price by ~50%.",
        "frequency_score": 10
    },
    {
        "id": 581,
        "topic": "Apache Kafka",
        "companies": [
            "Google",
            "LinkedIn"
        ],
        "question": "What happens if a Kafka Consumer Group has more consumers than partitions in the topic? ",
        "options": [
            "Some consumers will be idle",
            "Throughput increases linearly",
            "Kafka automatically creates more partitions",
            "The extra consumers duplicate the data"
        ],
        "answer": "Some consumers will be idle",
        "explanation": "A partition can be consumed by only one consumer within a group at a time. Extra consumers stay idle.",
        "frequency_score": 6
    },
    {
        "id": 582,
        "topic": "IAM",
        "companies": [
            "Google"
        ],
        "question": "A developer needs to deploy Cloud Functions in a production project. Following the principle of least privilege, which role should you grant? ",
        "options": [
            "Viewer",
            "Editor",
            "Owner",
            "Storage Object Creator"
        ],
        "answer": "Storage Object Creator",
        "explanation": "Always prefer predefined specific roles (like BigQuery Data Viewer, Storage Object Admin) over basic roles (Viewer/Editor/Owner) to ensure least privilege.",
        "frequency_score": 9
    },
    {
        "id": 583,
        "topic": "IAM",
        "companies": [
            "Google"
        ],
        "question": "A developer needs to upload files to a bucket in a production project. Following the principle of least privilege, which role should you grant? ",
        "options": [
            "Viewer",
            "Editor",
            "Owner",
            "BigQuery Data Viewer"
        ],
        "answer": "BigQuery Data Viewer",
        "explanation": "Always prefer predefined specific roles (like BigQuery Data Viewer, Storage Object Admin) over basic roles (Viewer/Editor/Owner) to ensure least privilege.",
        "frequency_score": 9
    },
    {
        "id": 584,
        "topic": "Cloud Spanner",
        "companies": [
            "Google",
            "Uber",
            "Pokemon GO"
        ],
        "question": "You are designing a global banking ledger. You require strong consistency and horizontal scalability. Which database service should you choose? ",
        "options": [
            "Cloud Spanner",
            "Cloud SQL",
            "Bigtable",
            "Firestore"
        ],
        "answer": "Cloud Spanner",
        "explanation": "Cloud Spanner is the only service providing global strong consistency and horizontal scalability with relational semantics (SQL).",
        "frequency_score": 8
    },
    {
        "id": 585,
        "topic": "Apache Spark",
        "companies": [
            "Google",
            "Databricks",
            "Amazon"
        ],
        "question": "In Spark, what is the difference between a Transformation and an Action? ",
        "options": [
            "Transformations are lazy, Actions match strict execution",
            "Actions are lazy, Transformations trigger execution",
            "They are the same",
            "Transformations save to disk, Actions read from disk"
        ],
        "answer": "Transformations are lazy, Actions match strict execution",
        "explanation": "Transformations (like map, filter) build the DAG but do not execute. Actions (like count, collect, save) trigger the actual computation.",
        "frequency_score": 6
    },
    {
        "id": 586,
        "topic": "Data Structures",
        "companies": [
            "Google",
            "Amazon",
            "Microsoft",
            "Facebook"
        ],
        "question": "You need to implement a look-up service that checks if a user ID exists in a set of 1 billion users with O(1) average time complexity. Which data structure is best? ",
        "options": [
            "Hash Table / HashSet",
            "Binary Search Tree",
            "Linked List",
            "Array"
        ],
        "answer": "Hash Table / HashSet",
        "explanation": "Hash Tables provide O(1) average case lookup. BST is O(log n).",
        "frequency_score": 8
    },
    {
        "id": 587,
        "topic": "Bigtable",
        "companies": [
            "Google",
            "Spotify"
        ],
        "question": "You are designing a Bigtable schema for financial transactions. Queries will primarily be retrieve latest events for a specific entity. Which row key design is optimal? ",
        "options": [
            "DeviceID#Date",
            "Date#DeviceID",
            "ReverseTimestamp#DeviceID",
            "Random#DeviceID"
        ],
        "answer": "DeviceID#Date",
        "explanation": "Avoid starting with timestamp to prevent hotspots. Use EntityID first for entity-lookup queries. Use ReverseTimestamp for 'latest items' queries globally.",
        "frequency_score": 7
    },
    {
        "id": 588,
        "topic": "Apache Kafka",
        "companies": [
            "Google",
            "LinkedIn",
            "Uber",
            "Netflix"
        ],
        "question": "You need to ensure strict ordering of messages in Kafka for a specific Transaction ID. How should you configure the producer? ",
        "options": [
            "Use the Transaction ID as the partition key",
            "Use a single partition for the entire topic",
            "Enable idempotent producer",
            "Increase replication factor"
        ],
        "answer": "Use the Transaction ID as the partition key",
        "explanation": "Kafka guarantees ordering WITHIN a partition. Using the Entity ID as the key ensures all messages for that entity go to the same partition.",
        "frequency_score": 6
    },
    {
        "id": 589,
        "topic": "Apache Kafka",
        "companies": [
            "Google",
            "LinkedIn"
        ],
        "question": "What happens if a Kafka Consumer Group has more consumers than partitions in the topic? ",
        "options": [
            "Some consumers will be idle",
            "Throughput increases linearly",
            "Kafka automatically creates more partitions",
            "The extra consumers duplicate the data"
        ],
        "answer": "Some consumers will be idle",
        "explanation": "A partition can be consumed by only one consumer within a group at a time. Extra consumers stay idle.",
        "frequency_score": 6
    },
    {
        "id": 590,
        "topic": "Bigtable",
        "companies": [
            "Google",
            "Spotify"
        ],
        "question": "You are designing a Bigtable schema for financial transactions. Queries will primarily be retrieve most recent events globally. Which row key design is optimal? ",
        "options": [
            "UserID#Timestamp",
            "Timestamp#UserID",
            "ReverseTimestamp#UserID",
            "Random#UserID"
        ],
        "answer": "ReverseTimestamp#UserID",
        "explanation": "Avoid starting with timestamp to prevent hotspots. Use EntityID first for entity-lookup queries. Use ReverseTimestamp for 'latest items' queries globally.",
        "frequency_score": 7
    },
    {
        "id": 591,
        "topic": "Cloud Storage",
        "companies": [
            "Google",
            "Snapchat"
        ],
        "question": "You are designing a storage solution for profile pictures. The requirement is access once a year. What storage class should you use? ",
        "options": [
            "Standard",
            "Nearline",
            "Coldline",
            "Archive"
        ],
        "answer": "Archive",
        "explanation": "Standard for hot data. Nearline < 1/month. Coldline < 1/quarter. Archive < 1/year.",
        "frequency_score": 6
    },
    {
        "id": 592,
        "topic": "Data Structures",
        "companies": [
            "Google",
            "Amazon",
            "Microsoft",
            "Facebook"
        ],
        "question": "You need to implement a look-up service that checks if a user ID exists in a set of 1 billion users with O(log n) average time complexity. Which data structure is best? ",
        "options": [
            "Hash Table / HashSet",
            "Binary Search Tree",
            "Linked List",
            "Array"
        ],
        "answer": "Binary Search Tree",
        "explanation": "Hash Tables provide O(1) average case lookup. BST is O(log n).",
        "frequency_score": 8
    },
    {
        "id": 593,
        "topic": "Data Structures",
        "companies": [
            "Google",
            "Amazon",
            "Microsoft",
            "Facebook"
        ],
        "question": "You need to implement a look-up service that checks if a user ID exists in a set of 1 billion users with O(1) average time complexity. Which data structure is best? ",
        "options": [
            "Hash Table / HashSet",
            "Binary Search Tree",
            "Linked List",
            "Array"
        ],
        "answer": "Hash Table / HashSet",
        "explanation": "Hash Tables provide O(1) average case lookup. BST is O(log n).",
        "frequency_score": 8
    },
    {
        "id": 594,
        "topic": "Bigtable",
        "companies": [
            "Google",
            "Spotify"
        ],
        "question": "You are designing a Bigtable schema for IoT events. Queries will primarily be retrieve most recent events globally. Which row key design is optimal? ",
        "options": [
            "DeviceID#Date",
            "Date#DeviceID",
            "ReverseTimestamp#DeviceID",
            "Random#DeviceID"
        ],
        "answer": "ReverseTimestamp#DeviceID",
        "explanation": "Avoid starting with timestamp to prevent hotspots. Use EntityID first for entity-lookup queries. Use ReverseTimestamp for 'latest items' queries globally.",
        "frequency_score": 7
    },
    {
        "id": 595,
        "topic": "Apache Kafka",
        "companies": [
            "Google",
            "LinkedIn",
            "Uber",
            "Netflix"
        ],
        "question": "You need to ensure strict ordering of messages in Kafka for a specific Device ID. How should you configure the producer? ",
        "options": [
            "Use the Device ID as the partition key",
            "Use a single partition for the entire topic",
            "Enable idempotent producer",
            "Increase replication factor"
        ],
        "answer": "Use the Device ID as the partition key",
        "explanation": "Kafka guarantees ordering WITHIN a partition. Using the Entity ID as the key ensures all messages for that entity go to the same partition.",
        "frequency_score": 6
    },
    {
        "id": 596,
        "topic": "Cloud Storage",
        "companies": [
            "Google",
            "Snapchat"
        ],
        "question": "You are designing a storage solution for regulatory archives. The requirement is access once a month. What storage class should you use? ",
        "options": [
            "Standard",
            "Nearline",
            "Coldline",
            "Archive"
        ],
        "answer": "Nearline",
        "explanation": "Standard for hot data. Nearline < 1/month. Coldline < 1/quarter. Archive < 1/year.",
        "frequency_score": 6
    },
    {
        "id": 597,
        "topic": "Pub/Sub",
        "companies": [
            "Google",
            "Uber"
        ],
        "question": "Your application publishes high throughput messages to Pub/Sub. You observe increased end-to-end latency and growing backlog. What is the most likely cause? ",
        "options": [
            "Subscribers are too slow (backlog)",
            "Publisher quota exceeded",
            "Message size too large",
            "Ordering keys are causing hotspots"
        ],
        "answer": "Subscribers are too slow (backlog)",
        "explanation": "If using ordering keys, high throughput on a single key can limit scalability (1MB/s limit per key). Slow subscribers cause increased backlog.",
        "frequency_score": 7
    },
    {
        "id": 598,
        "topic": "Apache Spark",
        "companies": [
            "Google",
            "Databricks",
            "Facebook",
            "Netflix"
        ],
        "question": "You are optimizing a Spark job that is suffering from data skew. One task takes 10x longer than others during a wide transformation. Which technique is most effective? ",
        "options": [
            "Salting the key",
            "Increasing the number of executors",
            "Using a larger instance type",
            "Broadcasting the large table"
        ],
        "answer": "Salting the key",
        "explanation": "Salting adds a random prefix to the skewed key to distribute it. Broadcasting is best for Skewed Joins where one table is small.",
        "frequency_score": 6
    },
    {
        "id": 599,
        "topic": "Apache Kafka",
        "companies": [
            "Google",
            "LinkedIn",
            "Uber",
            "Netflix"
        ],
        "question": "You need to ensure strict ordering of messages in Kafka for a specific Device ID. How should you configure the producer? ",
        "options": [
            "Use the Device ID as the partition key",
            "Use a single partition for the entire topic",
            "Enable idempotent producer",
            "Increase replication factor"
        ],
        "answer": "Use the Device ID as the partition key",
        "explanation": "Kafka guarantees ordering WITHIN a partition. Using the Entity ID as the key ensures all messages for that entity go to the same partition.",
        "frequency_score": 6
    },
    {
        "id": 600,
        "topic": "Apache Spark",
        "companies": [
            "Google",
            "Databricks",
            "Amazon"
        ],
        "question": "In Spark, what is the difference between a Transformation and an Action? ",
        "options": [
            "Transformations are lazy, Actions match strict execution",
            "Actions are lazy, Transformations trigger execution",
            "They are the same",
            "Transformations save to disk, Actions read from disk"
        ],
        "answer": "Transformations are lazy, Actions match strict execution",
        "explanation": "Transformations (like map, filter) build the DAG but do not execute. Actions (like count, collect, save) trigger the actual computation.",
        "frequency_score": 6
    },
    {
        "id": 601,
        "topic": "BigQuery",
        "companies": [
            "Google",
            "Spotify",
            "Twitter"
        ],
        "question": "You need to store 1 PB of sensor metrics data in BigQuery. The data is accessed rarely (every 6 months). Which storage class fits best to minimize costs?",
        "options": [
            "Active Storage",
            "Long-term Storage",
            "Nearline Storage",
            "Coldline Storage"
        ],
        "answer": "Long-term Storage",
        "explanation": "BigQuery Long-term storage applies automatically after 90 days of no modification, reducing price by ~50%.",
        "frequency_score": 10
    },
    {
        "id": 602,
        "topic": "Algorithms",
        "companies": [
            "Google",
            "Amazon",
            "Microsoft"
        ],
        "question": "What is the time complexity of a Quick Sort algorithm in the worst case? ",
        "options": [
            "O(n log n)",
            "O(n^2)",
            "O(n)",
            "O(log n)"
        ],
        "answer": "O(n^2)",
        "explanation": "Merge Sort is O(n log n). Quick Sort is O(n^2) in worst case (though avg O(n log n)). Bubble Sort is O(n^2).",
        "frequency_score": 8
    },
    {
        "id": 603,
        "topic": "Algorithms",
        "companies": [
            "Google",
            "Amazon",
            "Microsoft"
        ],
        "question": "What is the time complexity of a Merge Sort algorithm in the worst case? ",
        "options": [
            "O(n log n)",
            "O(n^2)",
            "O(n)",
            "O(log n)"
        ],
        "answer": "O(n log n)",
        "explanation": "Merge Sort is O(n log n). Quick Sort is O(n^2) in worst case (though avg O(n log n)). Bubble Sort is O(n^2).",
        "frequency_score": 8
    },
    {
        "id": 604,
        "topic": "Pub/Sub",
        "companies": [
            "Google",
            "Uber"
        ],
        "question": "Your application publishes high throughput messages to Pub/Sub. You observe throughput limits on specific keys. What is the most likely cause? ",
        "options": [
            "Subscribers are too slow (backlog)",
            "Publisher quota exceeded",
            "Message size too large",
            "Ordering keys are causing hotspots"
        ],
        "answer": "Ordering keys are causing hotspots",
        "explanation": "If using ordering keys, high throughput on a single key can limit scalability (1MB/s limit per key). Slow subscribers cause increased backlog.",
        "frequency_score": 7
    },
    {
        "id": 605,
        "topic": "Data Structures",
        "companies": [
            "Google",
            "Amazon",
            "Microsoft",
            "Facebook"
        ],
        "question": "You need to implement a look-up service that checks if a user ID exists in a set of 1 billion users with O(1) average time complexity. Which data structure is best? ",
        "options": [
            "Hash Table / HashSet",
            "Binary Search Tree",
            "Linked List",
            "Array"
        ],
        "answer": "Hash Table / HashSet",
        "explanation": "Hash Tables provide O(1) average case lookup. BST is O(log n).",
        "frequency_score": 8
    },
    {
        "id": 606,
        "topic": "Apache Kafka",
        "companies": [
            "Google",
            "LinkedIn"
        ],
        "question": "What happens if a Kafka Consumer Group has more consumers than partitions in the topic? ",
        "options": [
            "Some consumers will be idle",
            "Throughput increases linearly",
            "Kafka automatically creates more partitions",
            "The extra consumers duplicate the data"
        ],
        "answer": "Some consumers will be idle",
        "explanation": "A partition can be consumed by only one consumer within a group at a time. Extra consumers stay idle.",
        "frequency_score": 6
    },
    {
        "id": 607,
        "topic": "Cloud Storage",
        "companies": [
            "Google",
            "Snapchat"
        ],
        "question": "You are designing a storage solution for profile pictures. The requirement is high frequency access. What storage class should you use? ",
        "options": [
            "Standard",
            "Nearline",
            "Coldline",
            "Archive"
        ],
        "answer": "Standard",
        "explanation": "Standard for hot data. Nearline < 1/month. Coldline < 1/quarter. Archive < 1/year.",
        "frequency_score": 6
    },
    {
        "id": 608,
        "topic": "Dataflow",
        "companies": [
            "Google",
            "Spotify",
            "New York Times"
        ],
        "question": "You are building a streaming pipeline to process IoT temperature sensors. You need to handle periods of user activity separated by gaps. What windowing strategy is appropriate? ",
        "options": [
            "Fixed Windows",
            "Sliding Windows",
            "Session Windows",
            "Global Windows"
        ],
        "answer": "Session Windows",
        "explanation": "Session windows gap-fill based on activity. Sliding windows overlap (e.g. every 5 min show last 1 hour). Fixed windows are tumbling.",
        "frequency_score": 9
    },
    {
        "id": 609,
        "topic": "Pub/Sub",
        "companies": [
            "Google",
            "Uber"
        ],
        "question": "Your application publishes 1 million/sec messages to Pub/Sub. You observe throughput limits on specific keys. What is the most likely cause? ",
        "options": [
            "Subscribers are too slow (backlog)",
            "Publisher quota exceeded",
            "Message size too large",
            "Ordering keys are causing hotspots"
        ],
        "answer": "Ordering keys are causing hotspots",
        "explanation": "If using ordering keys, high throughput on a single key can limit scalability (1MB/s limit per key). Slow subscribers cause increased backlog.",
        "frequency_score": 7
    },
    {
        "id": 610,
        "topic": "Algorithms",
        "companies": [
            "Google",
            "Amazon",
            "Microsoft"
        ],
        "question": "What is the time complexity of a Bubble Sort algorithm in the worst case? ",
        "options": [
            "O(n log n)",
            "O(n^2)",
            "O(n)",
            "O(log n)"
        ],
        "answer": "O(n^2)",
        "explanation": "Merge Sort is O(n log n). Quick Sort is O(n^2) in worst case (though avg O(n log n)). Bubble Sort is O(n^2).",
        "frequency_score": 8
    },
    {
        "id": 611,
        "topic": "IAM",
        "companies": [
            "Google"
        ],
        "question": "A developer needs to deploy Cloud Functions in a production project. Following the principle of least privilege, which role should you grant? ",
        "options": [
            "Viewer",
            "Editor",
            "Owner",
            "Cloud Functions Developer"
        ],
        "answer": "Cloud Functions Developer",
        "explanation": "Always prefer predefined specific roles (like BigQuery Data Viewer, Storage Object Admin) over basic roles (Viewer/Editor/Owner) to ensure least privilege.",
        "frequency_score": 9
    },
    {
        "id": 612,
        "topic": "BigQuery",
        "companies": [
            "Google",
            "Spotify",
            "Twitter"
        ],
        "question": "You need to store 2 PB of sensor metrics data in BigQuery. The data is accessed rarely (every 6 months). Which storage class fits best to minimize costs? ",
        "options": [
            "Active Storage",
            "Long-term Storage",
            "Nearline Storage",
            "Coldline Storage"
        ],
        "answer": "Long-term Storage",
        "explanation": "BigQuery Long-term storage applies automatically after 90 days of no modification, reducing price by ~50%.",
        "frequency_score": 10
    },
    {
        "id": 613,
        "topic": "Dataflow",
        "companies": [
            "Google",
            "Spotify",
            "New York Times"
        ],
        "question": "You are building a streaming pipeline to process user clickstreams. You need to handle hourly reporting. What windowing strategy is appropriate? ",
        "options": [
            "Fixed Windows",
            "Sliding Windows",
            "Session Windows",
            "Global Windows"
        ],
        "answer": "Fixed Windows",
        "explanation": "Session windows gap-fill based on activity. Sliding windows overlap (e.g. every 5 min show last 1 hour). Fixed windows are tumbling.",
        "frequency_score": 9
    },
    {
        "id": 614,
        "topic": "Algorithms",
        "companies": [
            "Google",
            "Amazon",
            "Microsoft"
        ],
        "question": "What is the time complexity of a Merge Sort algorithm in the worst case? ",
        "options": [
            "O(n log n)",
            "O(n^2)",
            "O(n)",
            "O(log n)"
        ],
        "answer": "O(n log n)",
        "explanation": "Merge Sort is O(n log n). Quick Sort is O(n^2) in worst case (though avg O(n log n)). Bubble Sort is O(n^2).",
        "frequency_score": 8
    },
    {
        "id": 615,
        "topic": "IAM",
        "companies": [
            "Google"
        ],
        "question": "A developer needs to view BigQuery datasets in a production project. Following the principle of least privilege, which role should you grant? ",
        "options": [
            "Viewer",
            "Editor",
            "Owner",
            "Cloud Functions Developer"
        ],
        "answer": "Cloud Functions Developer",
        "explanation": "Always prefer predefined specific roles (like BigQuery Data Viewer, Storage Object Admin) over basic roles (Viewer/Editor/Owner) to ensure least privilege.",
        "frequency_score": 9
    },
    {
        "id": 616,
        "topic": "Cloud Spanner",
        "companies": [
            "Google",
            "Uber",
            "Pokemon GO"
        ],
        "question": "You are designing a global banking ledger. You require strong consistency and 99.999% availability. Which database service should you choose? ",
        "options": [
            "Cloud Spanner",
            "Cloud SQL",
            "Bigtable",
            "Firestore"
        ],
        "answer": "Cloud Spanner",
        "explanation": "Cloud Spanner is the only service providing global strong consistency and horizontal scalability with relational semantics (SQL).",
        "frequency_score": 8
    },
    {
        "id": 617,
        "topic": "BigQuery",
        "companies": [
            "Google",
            "Spotify",
            "Twitter"
        ],
        "question": "You need to store 500 TB of sensor metrics data in BigQuery. The data is accessed once a quarter. Which storage class fits best to minimize costs?",
        "options": [
            "Active Storage",
            "Long-term Storage",
            "Nearline Storage",
            "Coldline Storage"
        ],
        "answer": "Active Storage",
        "explanation": "BigQuery Long-term storage applies automatically after 90 days of no modification, reducing price by ~50%.",
        "frequency_score": 10
    },
    {
        "id": 618,
        "topic": "Bigtable",
        "companies": [
            "Google",
            "Spotify"
        ],
        "question": "You are designing a Bigtable schema for IoT events. Queries will primarily be retrieve most recent events globally. Which row key design is optimal? ",
        "options": [
            "SensorID#Date",
            "Date#SensorID",
            "ReverseTimestamp#SensorID",
            "Random#SensorID"
        ],
        "answer": "ReverseTimestamp#SensorID",
        "explanation": "Avoid starting with timestamp to prevent hotspots. Use EntityID first for entity-lookup queries. Use ReverseTimestamp for 'latest items' queries globally.",
        "frequency_score": 7
    },
    {
        "id": 619,
        "topic": "BigQuery",
        "companies": [
            "Google",
            "Spotify",
            "Twitter"
        ],
        "question": "You need to store 50 TB of clickstream data data in BigQuery. The data is accessed rarely (every 6 months). Which storage class fits best to minimize costs? ",
        "options": [
            "Active Storage",
            "Long-term Storage",
            "Nearline Storage",
            "Coldline Storage"
        ],
        "answer": "Long-term Storage",
        "explanation": "BigQuery Long-term storage applies automatically after 90 days of no modification, reducing price by ~50%.",
        "frequency_score": 10
    },
    {
        "id": 620,
        "topic": "Apache Kafka",
        "companies": [
            "Google",
            "LinkedIn"
        ],
        "question": "What happens if a Kafka Consumer Group has more consumers than partitions in the topic? ",
        "options": [
            "Some consumers will be idle",
            "Throughput increases linearly",
            "Kafka automatically creates more partitions",
            "The extra consumers duplicate the data"
        ],
        "answer": "Some consumers will be idle",
        "explanation": "A partition can be consumed by only one consumer within a group at a time. Extra consumers stay idle.",
        "frequency_score": 6
    },
    {
        "id": 621,
        "topic": "Algorithms",
        "companies": [
            "Google",
            "Amazon",
            "Microsoft"
        ],
        "question": "What is the time complexity of a Merge Sort algorithm in the worst case? ",
        "options": [
            "O(n log n)",
            "O(n^2)",
            "O(n)",
            "O(log n)"
        ],
        "answer": "O(n log n)",
        "explanation": "Merge Sort is O(n log n). Quick Sort is O(n^2) in worst case (though avg O(n log n)). Bubble Sort is O(n^2).",
        "frequency_score": 8
    },
    {
        "id": 622,
        "topic": "Apache Kafka",
        "companies": [
            "Google",
            "LinkedIn"
        ],
        "question": "What happens if a Kafka Consumer Group has more consumers than partitions in the topic? ",
        "options": [
            "Some consumers will be idle",
            "Throughput increases linearly",
            "Kafka automatically creates more partitions",
            "The extra consumers duplicate the data"
        ],
        "answer": "Some consumers will be idle",
        "explanation": "A partition can be consumed by only one consumer within a group at a time. Extra consumers stay idle.",
        "frequency_score": 6
    },
    {
        "id": 623,
        "topic": "Apache Kafka",
        "companies": [
            "Google",
            "LinkedIn"
        ],
        "question": "What happens if a Kafka Consumer Group has more consumers than partitions in the topic? ",
        "options": [
            "Some consumers will be idle",
            "Throughput increases linearly",
            "Kafka automatically creates more partitions",
            "The extra consumers duplicate the data"
        ],
        "answer": "Some consumers will be idle",
        "explanation": "A partition can be consumed by only one consumer within a group at a time. Extra consumers stay idle.",
        "frequency_score": 6
    },
    {
        "id": 624,
        "topic": "Cloud Spanner",
        "companies": [
            "Google",
            "Uber",
            "Pokemon GO"
        ],
        "question": "You are designing a global banking ledger. You require strong consistency and 99.999% availability. Which database service should you choose? ",
        "options": [
            "Cloud Spanner",
            "Cloud SQL",
            "Bigtable",
            "Firestore"
        ],
        "answer": "Cloud Spanner",
        "explanation": "Cloud Spanner is the only service providing global strong consistency and horizontal scalability with relational semantics (SQL).",
        "frequency_score": 8
    },
    {
        "id": 625,
        "topic": "Dataflow",
        "companies": [
            "Google",
            "Spotify",
            "New York Times"
        ],
        "question": "You are building a streaming pipeline to process user clickstreams. You need to handle periods of user activity separated by gaps. What windowing strategy is appropriate? ",
        "options": [
            "Fixed Windows",
            "Sliding Windows",
            "Session Windows",
            "Global Windows"
        ],
        "answer": "Session Windows",
        "explanation": "Session windows gap-fill based on activity. Sliding windows overlap (e.g. every 5 min show last 1 hour). Fixed windows are tumbling.",
        "frequency_score": 9
    },
    {
        "id": 626,
        "topic": "BigQuery",
        "companies": [
            "Google",
            "Spotify",
            "Twitter"
        ],
        "question": "You need to store 500 TB of audit logs data in BigQuery. The data is accessed continuously. Which storage class fits best to minimize costs? ",
        "options": [
            "Active Storage",
            "Long-term Storage",
            "Nearline Storage",
            "Coldline Storage"
        ],
        "answer": "Active Storage",
        "explanation": "BigQuery Long-term storage applies automatically after 90 days of no modification, reducing price by ~50%.",
        "frequency_score": 10
    },
    {
        "id": 627,
        "topic": "Cloud Spanner",
        "companies": [
            "Google",
            "Uber",
            "Pokemon GO"
        ],
        "question": "You are designing a global banking ledger. You require strong consistency and horizontal scalability. Which database service should you choose? ",
        "options": [
            "Cloud Spanner",
            "Cloud SQL",
            "Bigtable",
            "Firestore"
        ],
        "answer": "Cloud Spanner",
        "explanation": "Cloud Spanner is the only service providing global strong consistency and horizontal scalability with relational semantics (SQL).",
        "frequency_score": 8
    },
    {
        "id": 628,
        "topic": "Dataflow",
        "companies": [
            "Google",
            "Spotify",
            "New York Times"
        ],
        "question": "You are building a streaming pipeline to process server logs. You need to handle rolling averages every minute for the last hour. What windowing strategy is appropriate? ",
        "options": [
            "Fixed Windows",
            "Sliding Windows",
            "Session Windows",
            "Global Windows"
        ],
        "answer": "Sliding Windows",
        "explanation": "Session windows gap-fill based on activity. Sliding windows overlap (e.g. every 5 min show last 1 hour). Fixed windows are tumbling.",
        "frequency_score": 9
    },
    {
        "id": 629,
        "topic": "Cloud Spanner",
        "companies": [
            "Google",
            "Uber",
            "Pokemon GO"
        ],
        "question": "You are designing a global banking ledger. You require strong consistency and 99.999% availability. Which database service should you choose? ",
        "options": [
            "Cloud Spanner",
            "Cloud SQL",
            "Bigtable",
            "Firestore"
        ],
        "answer": "Cloud Spanner",
        "explanation": "Cloud Spanner is the only service providing global strong consistency and horizontal scalability with relational semantics (SQL).",
        "frequency_score": 8
    },
    {
        "id": 630,
        "topic": "Dataflow",
        "companies": [
            "Google",
            "Spotify",
            "New York Times"
        ],
        "question": "You are building a streaming pipeline to process server logs. You need to handle hourly reporting. What windowing strategy is appropriate? ",
        "options": [
            "Fixed Windows",
            "Sliding Windows",
            "Session Windows",
            "Global Windows"
        ],
        "answer": "Fixed Windows",
        "explanation": "Session windows gap-fill based on activity. Sliding windows overlap (e.g. every 5 min show last 1 hour). Fixed windows are tumbling.",
        "frequency_score": 9
    },
    {
        "id": 631,
        "topic": "Cloud Spanner",
        "companies": [
            "Google",
            "Uber",
            "Pokemon GO"
        ],
        "question": "You are designing a global banking ledger. You require strong consistency and horizontal scalability. Which database service should you choose? ",
        "options": [
            "Cloud Spanner",
            "Cloud SQL",
            "Bigtable",
            "Firestore"
        ],
        "answer": "Cloud Spanner",
        "explanation": "Cloud Spanner is the only service providing global strong consistency and horizontal scalability with relational semantics (SQL).",
        "frequency_score": 8
    },
    {
        "id": 632,
        "topic": "Cloud Spanner",
        "companies": [
            "Google",
            "Uber",
            "Pokemon GO"
        ],
        "question": "You are designing a global banking ledger. You require strong consistency and horizontal scalability. Which database service should you choose? ",
        "options": [
            "Cloud Spanner",
            "Cloud SQL",
            "Bigtable",
            "Firestore"
        ],
        "answer": "Cloud Spanner",
        "explanation": "Cloud Spanner is the only service providing global strong consistency and horizontal scalability with relational semantics (SQL).",
        "frequency_score": 8
    },
    {
        "id": 633,
        "topic": "BigQuery",
        "companies": [
            "Google",
            "Spotify",
            "Twitter"
        ],
        "question": "You need to store 50 TB of transaction records data in BigQuery. The data is accessed once a quarter. Which storage class fits best to minimize costs?",
        "options": [
            "Active Storage",
            "Long-term Storage",
            "Nearline Storage",
            "Coldline Storage"
        ],
        "answer": "Active Storage",
        "explanation": "BigQuery Long-term storage applies automatically after 90 days of no modification, reducing price by ~50%.",
        "frequency_score": 10
    },
    {
        "id": 634,
        "topic": "Cloud Spanner",
        "companies": [
            "Google",
            "Uber",
            "Pokemon GO"
        ],
        "question": "You are designing a global banking ledger. You require strong consistency and 99.999% availability. Which database service should you choose? ",
        "options": [
            "Cloud Spanner",
            "Cloud SQL",
            "Bigtable",
            "Firestore"
        ],
        "answer": "Cloud Spanner",
        "explanation": "Cloud Spanner is the only service providing global strong consistency and horizontal scalability with relational semantics (SQL).",
        "frequency_score": 8
    },
    {
        "id": 635,
        "topic": "Apache Spark",
        "companies": [
            "Google",
            "Databricks",
            "Amazon"
        ],
        "question": "In Spark, what is the difference between a Transformation and an Action? ",
        "options": [
            "Transformations are lazy, Actions match strict execution",
            "Actions are lazy, Transformations trigger execution",
            "They are the same",
            "Transformations save to disk, Actions read from disk"
        ],
        "answer": "Transformations are lazy, Actions match strict execution",
        "explanation": "Transformations (like map, filter) build the DAG but do not execute. Actions (like count, collect, save) trigger the actual computation.",
        "frequency_score": 6
    },
    {
        "id": 636,
        "topic": "Pub/Sub",
        "companies": [
            "Google",
            "Uber"
        ],
        "question": "Your application publishes high throughput messages to Pub/Sub. You observe throughput limits on specific keys. What is the most likely cause? ",
        "options": [
            "Subscribers are too slow (backlog)",
            "Publisher quota exceeded",
            "Message size too large",
            "Ordering keys are causing hotspots"
        ],
        "answer": "Ordering keys are causing hotspots",
        "explanation": "If using ordering keys, high throughput on a single key can limit scalability (1MB/s limit per key). Slow subscribers cause increased backlog.",
        "frequency_score": 7
    },
    {
        "id": 637,
        "topic": "Apache Spark",
        "companies": [
            "Google",
            "Databricks",
            "Amazon"
        ],
        "question": "In Spark, what is the difference between a Transformation and an Action? ",
        "options": [
            "Transformations are lazy, Actions match strict execution",
            "Actions are lazy, Transformations trigger execution",
            "They are the same",
            "Transformations save to disk, Actions read from disk"
        ],
        "answer": "Transformations are lazy, Actions match strict execution",
        "explanation": "Transformations (like map, filter) build the DAG but do not execute. Actions (like count, collect, save) trigger the actual computation.",
        "frequency_score": 6
    },
    {
        "id": 638,
        "topic": "Algorithms",
        "companies": [
            "Google",
            "Amazon",
            "Microsoft"
        ],
        "question": "What is the time complexity of a Bubble Sort algorithm in the worst case? ",
        "options": [
            "O(n log n)",
            "O(n^2)",
            "O(n)",
            "O(log n)"
        ],
        "answer": "O(n^2)",
        "explanation": "Merge Sort is O(n log n). Quick Sort is O(n^2) in worst case (though avg O(n log n)). Bubble Sort is O(n^2).",
        "frequency_score": 8
    },
    {
        "id": 639,
        "topic": "Apache Kafka",
        "companies": [
            "Google",
            "LinkedIn"
        ],
        "question": "What happens if a Kafka Consumer Group has more consumers than partitions in the topic? ",
        "options": [
            "Some consumers will be idle",
            "Throughput increases linearly",
            "Kafka automatically creates more partitions",
            "The extra consumers duplicate the data"
        ],
        "answer": "Some consumers will be idle",
        "explanation": "A partition can be consumed by only one consumer within a group at a time. Extra consumers stay idle.",
        "frequency_score": 6
    },
    {
        "id": 640,
        "topic": "Dataflow",
        "companies": [
            "Google",
            "Spotify",
            "New York Times"
        ],
        "question": "You are building a streaming pipeline to process IoT temperature sensors. You need to handle rolling averages every minute for the last hour. What windowing strategy is appropriate? ",
        "options": [
            "Fixed Windows",
            "Sliding Windows",
            "Session Windows",
            "Global Windows"
        ],
        "answer": "Sliding Windows",
        "explanation": "Session windows gap-fill based on activity. Sliding windows overlap (e.g. every 5 min show last 1 hour). Fixed windows are tumbling.",
        "frequency_score": 9
    },
    {
        "id": 641,
        "topic": "Dataflow",
        "companies": [
            "Google",
            "Spotify",
            "New York Times"
        ],
        "question": "You are building a streaming pipeline to process server logs. You need to handle rolling averages every minute for the last hour. What windowing strategy is appropriate? ",
        "options": [
            "Fixed Windows",
            "Sliding Windows",
            "Session Windows",
            "Global Windows"
        ],
        "answer": "Sliding Windows",
        "explanation": "Session windows gap-fill based on activity. Sliding windows overlap (e.g. every 5 min show last 1 hour). Fixed windows are tumbling.",
        "frequency_score": 9
    },
    {
        "id": 642,
        "topic": "Algorithms",
        "companies": [
            "Google",
            "Amazon",
            "Microsoft"
        ],
        "question": "What is the time complexity of a Quick Sort algorithm in the worst case? ",
        "options": [
            "O(n log n)",
            "O(n^2)",
            "O(n)",
            "O(log n)"
        ],
        "answer": "O(n^2)",
        "explanation": "Merge Sort is O(n log n). Quick Sort is O(n^2) in worst case (though avg O(n log n)). Bubble Sort is O(n^2).",
        "frequency_score": 8
    },
    {
        "id": 643,
        "topic": "Algorithms",
        "companies": [
            "Google",
            "Amazon",
            "Microsoft"
        ],
        "question": "What is the time complexity of a Quick Sort algorithm in the worst case? ",
        "options": [
            "O(n log n)",
            "O(n^2)",
            "O(n)",
            "O(log n)"
        ],
        "answer": "O(n^2)",
        "explanation": "Merge Sort is O(n log n). Quick Sort is O(n^2) in worst case (though avg O(n log n)). Bubble Sort is O(n^2).",
        "frequency_score": 8
    },
    {
        "id": 644,
        "topic": "IAM",
        "companies": [
            "Google"
        ],
        "question": "A developer needs to deploy Cloud Functions in a production project. Following the principle of least privilege, which role should you grant? ",
        "options": [
            "Viewer",
            "Editor",
            "Owner",
            "Cloud Functions Developer"
        ],
        "answer": "Cloud Functions Developer",
        "explanation": "Always prefer predefined specific roles (like BigQuery Data Viewer, Storage Object Admin) over basic roles (Viewer/Editor/Owner) to ensure least privilege.",
        "frequency_score": 9
    },
    {
        "id": 645,
        "topic": "Cloud Spanner",
        "companies": [
            "Google",
            "Uber",
            "Pokemon GO"
        ],
        "question": "You are designing a global banking ledger. You require strong consistency and horizontal scalability. Which database service should you choose? ",
        "options": [
            "Cloud Spanner",
            "Cloud SQL",
            "Bigtable",
            "Firestore"
        ],
        "answer": "Cloud Spanner",
        "explanation": "Cloud Spanner is the only service providing global strong consistency and horizontal scalability with relational semantics (SQL).",
        "frequency_score": 8
    },
    {
        "id": 646,
        "topic": "Bigtable",
        "companies": [
            "Google",
            "Spotify"
        ],
        "question": "You are designing a Bigtable schema for financial transactions. Queries will primarily be retrieve latest events for a specific entity. Which row key design is optimal? ",
        "options": [
            "DeviceID#Timestamp",
            "Timestamp#DeviceID",
            "ReverseTimestamp#DeviceID",
            "Random#DeviceID"
        ],
        "answer": "DeviceID#Timestamp",
        "explanation": "Avoid starting with timestamp to prevent hotspots. Use EntityID first for entity-lookup queries. Use ReverseTimestamp for 'latest items' queries globally.",
        "frequency_score": 7
    },
    {
        "id": 647,
        "topic": "Algorithms",
        "companies": [
            "Google",
            "Amazon",
            "Microsoft"
        ],
        "question": "What is the time complexity of a Merge Sort algorithm in the worst case? ",
        "options": [
            "O(n log n)",
            "O(n^2)",
            "O(n)",
            "O(log n)"
        ],
        "answer": "O(n log n)",
        "explanation": "Merge Sort is O(n log n). Quick Sort is O(n^2) in worst case (though avg O(n log n)). Bubble Sort is O(n^2).",
        "frequency_score": 8
    },
    {
        "id": 648,
        "topic": "Dataflow",
        "companies": [
            "Google",
            "Spotify",
            "New York Times"
        ],
        "question": "You are building a streaming pipeline to process user clickstreams. You need to handle periods of user activity separated by gaps. What windowing strategy is appropriate? ",
        "options": [
            "Fixed Windows",
            "Sliding Windows",
            "Session Windows",
            "Global Windows"
        ],
        "answer": "Session Windows",
        "explanation": "Session windows gap-fill based on activity. Sliding windows overlap (e.g. every 5 min show last 1 hour). Fixed windows are tumbling.",
        "frequency_score": 9
    },
    {
        "id": 649,
        "topic": "BigQuery",
        "companies": [
            "Google",
            "Spotify",
            "Twitter"
        ],
        "question": "You need to store 50 TB of transaction records data in BigQuery. The data is accessed daily. Which storage class fits best to minimize costs?",
        "options": [
            "Active Storage",
            "Long-term Storage",
            "Nearline Storage",
            "Coldline Storage"
        ],
        "answer": "Active Storage",
        "explanation": "BigQuery Long-term storage applies automatically after 90 days of no modification, reducing price by ~50%.",
        "frequency_score": 10
    },
    {
        "id": 650,
        "topic": "Algorithms",
        "companies": [
            "Google",
            "Amazon",
            "Microsoft"
        ],
        "question": "What is the time complexity of a Quick Sort algorithm in the worst case? ",
        "options": [
            "O(n log n)",
            "O(n^2)",
            "O(n)",
            "O(log n)"
        ],
        "answer": "O(n^2)",
        "explanation": "Merge Sort is O(n log n). Quick Sort is O(n^2) in worst case (though avg O(n log n)). Bubble Sort is O(n^2).",
        "frequency_score": 8
    },
    {
        "id": 651,
        "topic": "Cloud Spanner",
        "companies": [
            "Google",
            "Uber",
            "Pokemon GO"
        ],
        "question": "You are designing a global banking ledger. You require strong consistency and horizontal scalability. Which database service should you choose? ",
        "options": [
            "Cloud Spanner",
            "Cloud SQL",
            "Bigtable",
            "Firestore"
        ],
        "answer": "Cloud Spanner",
        "explanation": "Cloud Spanner is the only service providing global strong consistency and horizontal scalability with relational semantics (SQL).",
        "frequency_score": 8
    },
    {
        "id": 652,
        "topic": "Bigtable",
        "companies": [
            "Google",
            "Spotify"
        ],
        "question": "You are designing a Bigtable schema for social media posts. Queries will primarily be retrieve most recent events globally. Which row key design is optimal? ",
        "options": [
            "DeviceID#Timestamp",
            "Timestamp#DeviceID",
            "ReverseTimestamp#DeviceID",
            "Random#DeviceID"
        ],
        "answer": "ReverseTimestamp#DeviceID",
        "explanation": "Avoid starting with timestamp to prevent hotspots. Use EntityID first for entity-lookup queries. Use ReverseTimestamp for 'latest items' queries globally.",
        "frequency_score": 7
    },
    {
        "id": 653,
        "topic": "Algorithms",
        "companies": [
            "Google",
            "Amazon",
            "Microsoft"
        ],
        "question": "What is the time complexity of a Merge Sort algorithm in the worst case? ",
        "options": [
            "O(n log n)",
            "O(n^2)",
            "O(n)",
            "O(log n)"
        ],
        "answer": "O(n log n)",
        "explanation": "Merge Sort is O(n log n). Quick Sort is O(n^2) in worst case (though avg O(n log n)). Bubble Sort is O(n^2).",
        "frequency_score": 8
    },
    {
        "id": 654,
        "topic": "Apache Spark",
        "companies": [
            "Google",
            "Databricks",
            "Facebook",
            "Netflix"
        ],
        "question": "You are optimizing a Spark job that is suffering from data skew. You are joining a large skewed table with a small reference table. Which technique is most effective? ",
        "options": [
            "Salting the key",
            "Increasing the number of executors",
            "Using a larger instance type",
            "Broadcasting the large table"
        ],
        "answer": "Salting the key",
        "explanation": "Salting adds a random prefix to the skewed key to distribute it. Broadcasting is best for Skewed Joins where one table is small.",
        "frequency_score": 6
    },
    {
        "id": 655,
        "topic": "Cloud Spanner",
        "companies": [
            "Google",
            "Uber",
            "Pokemon GO"
        ],
        "question": "You are designing a global banking ledger. You require strong consistency and horizontal scalability. Which database service should you choose? ",
        "options": [
            "Cloud Spanner",
            "Cloud SQL",
            "Bigtable",
            "Firestore"
        ],
        "answer": "Cloud Spanner",
        "explanation": "Cloud Spanner is the only service providing global strong consistency and horizontal scalability with relational semantics (SQL).",
        "frequency_score": 8
    },
    {
        "id": 656,
        "topic": "Apache Kafka",
        "companies": [
            "Google",
            "LinkedIn"
        ],
        "question": "What happens if a Kafka Consumer Group has more consumers than partitions in the topic? ",
        "options": [
            "Some consumers will be idle",
            "Throughput increases linearly",
            "Kafka automatically creates more partitions",
            "The extra consumers duplicate the data"
        ],
        "answer": "Some consumers will be idle",
        "explanation": "A partition can be consumed by only one consumer within a group at a time. Extra consumers stay idle.",
        "frequency_score": 6
    },
    {
        "id": 657,
        "topic": "Algorithms",
        "companies": [
            "Google",
            "Amazon",
            "Microsoft"
        ],
        "question": "What is the time complexity of a Merge Sort algorithm in the worst case? ",
        "options": [
            "O(n log n)",
            "O(n^2)",
            "O(n)",
            "O(log n)"
        ],
        "answer": "O(n log n)",
        "explanation": "Merge Sort is O(n log n). Quick Sort is O(n^2) in worst case (though avg O(n log n)). Bubble Sort is O(n^2).",
        "frequency_score": 8
    },
    {
        "id": 658,
        "topic": "Pub/Sub",
        "companies": [
            "Google",
            "Uber"
        ],
        "question": "Your application publishes 1 million/sec messages to Pub/Sub. You observe throughput limits on specific keys. What is the most likely cause? ",
        "options": [
            "Subscribers are too slow (backlog)",
            "Publisher quota exceeded",
            "Message size too large",
            "Ordering keys are causing hotspots"
        ],
        "answer": "Ordering keys are causing hotspots",
        "explanation": "If using ordering keys, high throughput on a single key can limit scalability (1MB/s limit per key). Slow subscribers cause increased backlog.",
        "frequency_score": 7
    },
    {
        "id": 659,
        "topic": "Algorithms",
        "companies": [
            "Google",
            "Amazon",
            "Microsoft"
        ],
        "question": "What is the time complexity of a Merge Sort algorithm in the worst case? ",
        "options": [
            "O(n log n)",
            "O(n^2)",
            "O(n)",
            "O(log n)"
        ],
        "answer": "O(n log n)",
        "explanation": "Merge Sort is O(n log n). Quick Sort is O(n^2) in worst case (though avg O(n log n)). Bubble Sort is O(n^2).",
        "frequency_score": 8
    },
    {
        "id": 660,
        "topic": "Apache Kafka",
        "companies": [
            "Google",
            "LinkedIn",
            "Uber",
            "Netflix"
        ],
        "question": "You need to ensure strict ordering of messages in Kafka for a specific Transaction ID. How should you configure the producer? ",
        "options": [
            "Use the Transaction ID as the partition key",
            "Use a single partition for the entire topic",
            "Enable idempotent producer",
            "Increase replication factor"
        ],
        "answer": "Use the Transaction ID as the partition key",
        "explanation": "Kafka guarantees ordering WITHIN a partition. Using the Entity ID as the key ensures all messages for that entity go to the same partition.",
        "frequency_score": 6
    },
    {
        "id": 661,
        "topic": "Bigtable",
        "companies": [
            "Google",
            "Spotify"
        ],
        "question": "You are designing a Bigtable schema for social media posts. Queries will primarily be retrieve latest events for a specific entity. Which row key design is optimal? ",
        "options": [
            "SensorID#Timestamp",
            "Timestamp#SensorID",
            "ReverseTimestamp#SensorID",
            "Random#SensorID"
        ],
        "answer": "SensorID#Timestamp",
        "explanation": "Avoid starting with timestamp to prevent hotspots. Use EntityID first for entity-lookup queries. Use ReverseTimestamp for 'latest items' queries globally.",
        "frequency_score": 7
    },
    {
        "id": 662,
        "topic": "Apache Kafka",
        "companies": [
            "Google",
            "LinkedIn",
            "Uber",
            "Netflix"
        ],
        "question": "You need to ensure strict ordering of messages in Kafka for a specific Transaction ID. How should you configure the producer? ",
        "options": [
            "Use the Transaction ID as the partition key",
            "Use a single partition for the entire topic",
            "Enable idempotent producer",
            "Increase replication factor"
        ],
        "answer": "Use the Transaction ID as the partition key",
        "explanation": "Kafka guarantees ordering WITHIN a partition. Using the Entity ID as the key ensures all messages for that entity go to the same partition.",
        "frequency_score": 6
    },
    {
        "id": 663,
        "topic": "Bigtable",
        "companies": [
            "Google",
            "Spotify"
        ],
        "question": "You are designing a Bigtable schema for social media posts. Queries will primarily be retrieve latest events for a specific entity. Which row key design is optimal? ",
        "options": [
            "UserID#Timestamp",
            "Timestamp#UserID",
            "ReverseTimestamp#UserID",
            "Random#UserID"
        ],
        "answer": "UserID#Timestamp",
        "explanation": "Avoid starting with timestamp to prevent hotspots. Use EntityID first for entity-lookup queries. Use ReverseTimestamp for 'latest items' queries globally.",
        "frequency_score": 7
    },
    {
        "id": 664,
        "topic": "Apache Kafka",
        "companies": [
            "Google",
            "LinkedIn"
        ],
        "question": "What happens if a Kafka Consumer Group has more consumers than partitions in the topic? ",
        "options": [
            "Some consumers will be idle",
            "Throughput increases linearly",
            "Kafka automatically creates more partitions",
            "The extra consumers duplicate the data"
        ],
        "answer": "Some consumers will be idle",
        "explanation": "A partition can be consumed by only one consumer within a group at a time. Extra consumers stay idle.",
        "frequency_score": 6
    },
    {
        "id": 665,
        "topic": "Apache Kafka",
        "companies": [
            "Google",
            "LinkedIn",
            "Uber",
            "Netflix"
        ],
        "question": "You need to ensure strict ordering of messages in Kafka for a specific Device ID. How should you configure the producer? ",
        "options": [
            "Use the Device ID as the partition key",
            "Use a single partition for the entire topic",
            "Enable idempotent producer",
            "Increase replication factor"
        ],
        "answer": "Use the Device ID as the partition key",
        "explanation": "Kafka guarantees ordering WITHIN a partition. Using the Entity ID as the key ensures all messages for that entity go to the same partition.",
        "frequency_score": 6
    },
    {
        "id": 666,
        "topic": "Apache Kafka",
        "companies": [
            "Google",
            "LinkedIn",
            "Uber",
            "Netflix"
        ],
        "question": "You need to ensure strict ordering of messages in Kafka for a specific User ID. How should you configure the producer? ",
        "options": [
            "Use the User ID as the partition key",
            "Use a single partition for the entire topic",
            "Enable idempotent producer",
            "Increase replication factor"
        ],
        "answer": "Use the User ID as the partition key",
        "explanation": "Kafka guarantees ordering WITHIN a partition. Using the Entity ID as the key ensures all messages for that entity go to the same partition.",
        "frequency_score": 6
    },
    {
        "id": 667,
        "topic": "Apache Kafka",
        "companies": [
            "Google",
            "LinkedIn",
            "Uber",
            "Netflix"
        ],
        "question": "You need to ensure strict ordering of messages in Kafka for a specific Device ID. How should you configure the producer? ",
        "options": [
            "Use the Device ID as the partition key",
            "Use a single partition for the entire topic",
            "Enable idempotent producer",
            "Increase replication factor"
        ],
        "answer": "Use the Device ID as the partition key",
        "explanation": "Kafka guarantees ordering WITHIN a partition. Using the Entity ID as the key ensures all messages for that entity go to the same partition.",
        "frequency_score": 6
    },
    {
        "id": 668,
        "topic": "IAM",
        "companies": [
            "Google"
        ],
        "question": "A developer needs to view BigQuery datasets in a production project. Following the principle of least privilege, which role should you grant? ",
        "options": [
            "Viewer",
            "Editor",
            "Owner",
            "BigQuery Data Viewer"
        ],
        "answer": "BigQuery Data Viewer",
        "explanation": "Always prefer predefined specific roles (like BigQuery Data Viewer, Storage Object Admin) over basic roles (Viewer/Editor/Owner) to ensure least privilege.",
        "frequency_score": 9
    },
    {
        "id": 669,
        "topic": "Cloud Spanner",
        "companies": [
            "Google",
            "Uber",
            "Pokemon GO"
        ],
        "question": "You are designing a global banking ledger. You require strong consistency and 99.999% availability. Which database service should you choose? ",
        "options": [
            "Cloud Spanner",
            "Cloud SQL",
            "Bigtable",
            "Firestore"
        ],
        "answer": "Cloud Spanner",
        "explanation": "Cloud Spanner is the only service providing global strong consistency and horizontal scalability with relational semantics (SQL).",
        "frequency_score": 8
    },
    {
        "id": 670,
        "topic": "Dataflow",
        "companies": [
            "Google",
            "Spotify",
            "New York Times"
        ],
        "question": "You are building a streaming pipeline to process user clickstreams. You need to handle periods of user activity separated by gaps. What windowing strategy is appropriate? ",
        "options": [
            "Fixed Windows",
            "Sliding Windows",
            "Session Windows",
            "Global Windows"
        ],
        "answer": "Session Windows",
        "explanation": "Session windows gap-fill based on activity. Sliding windows overlap (e.g. every 5 min show last 1 hour). Fixed windows are tumbling.",
        "frequency_score": 9
    },
    {
        "id": 671,
        "topic": "IAM",
        "companies": [
            "Google"
        ],
        "question": "A developer needs to deploy Cloud Functions in a production project. Following the principle of least privilege, which role should you grant? ",
        "options": [
            "Viewer",
            "Editor",
            "Owner",
            "BigQuery Data Viewer"
        ],
        "answer": "BigQuery Data Viewer",
        "explanation": "Always prefer predefined specific roles (like BigQuery Data Viewer, Storage Object Admin) over basic roles (Viewer/Editor/Owner) to ensure least privilege.",
        "frequency_score": 9
    },
    {
        "id": 672,
        "topic": "Apache Kafka",
        "companies": [
            "Google",
            "LinkedIn"
        ],
        "question": "What happens if a Kafka Consumer Group has more consumers than partitions in the topic? ",
        "options": [
            "Some consumers will be idle",
            "Throughput increases linearly",
            "Kafka automatically creates more partitions",
            "The extra consumers duplicate the data"
        ],
        "answer": "Some consumers will be idle",
        "explanation": "A partition can be consumed by only one consumer within a group at a time. Extra consumers stay idle.",
        "frequency_score": 6
    },
    {
        "id": 673,
        "topic": "Pub/Sub",
        "companies": [
            "Google",
            "Uber"
        ],
        "question": "Your application publishes high throughput messages to Pub/Sub. You observe throughput limits on specific keys. What is the most likely cause? ",
        "options": [
            "Subscribers are too slow (backlog)",
            "Publisher quota exceeded",
            "Message size too large",
            "Ordering keys are causing hotspots"
        ],
        "answer": "Ordering keys are causing hotspots",
        "explanation": "If using ordering keys, high throughput on a single key can limit scalability (1MB/s limit per key). Slow subscribers cause increased backlog.",
        "frequency_score": 7
    },
    {
        "id": 674,
        "topic": "Dataflow",
        "companies": [
            "Google",
            "Spotify",
            "New York Times"
        ],
        "question": "You are building a streaming pipeline to process IoT temperature sensors. You need to handle periods of user activity separated by gaps. What windowing strategy is appropriate? ",
        "options": [
            "Fixed Windows",
            "Sliding Windows",
            "Session Windows",
            "Global Windows"
        ],
        "answer": "Session Windows",
        "explanation": "Session windows gap-fill based on activity. Sliding windows overlap (e.g. every 5 min show last 1 hour). Fixed windows are tumbling.",
        "frequency_score": 9
    },
    {
        "id": 675,
        "topic": "Algorithms",
        "companies": [
            "Google",
            "Amazon",
            "Microsoft"
        ],
        "question": "What is the time complexity of a Merge Sort algorithm in the worst case? ",
        "options": [
            "O(n log n)",
            "O(n^2)",
            "O(n)",
            "O(log n)"
        ],
        "answer": "O(n log n)",
        "explanation": "Merge Sort is O(n log n). Quick Sort is O(n^2) in worst case (though avg O(n log n)). Bubble Sort is O(n^2).",
        "frequency_score": 8
    },
    {
        "id": 676,
        "topic": "Cloud Storage",
        "companies": [
            "Google",
            "Snapchat"
        ],
        "question": "You are designing a storage solution for profile pictures. The requirement is access once a year. What storage class should you use? ",
        "options": [
            "Standard",
            "Nearline",
            "Coldline",
            "Archive"
        ],
        "answer": "Archive",
        "explanation": "Standard for hot data. Nearline < 1/month. Coldline < 1/quarter. Archive < 1/year.",
        "frequency_score": 6
    },
    {
        "id": 677,
        "topic": "Cloud Storage",
        "companies": [
            "Google",
            "Snapchat"
        ],
        "question": "You are designing a storage solution for disaster recovery backups. The requirement is access once a year. What storage class should you use? ",
        "options": [
            "Standard",
            "Nearline",
            "Coldline",
            "Archive"
        ],
        "answer": "Archive",
        "explanation": "Standard for hot data. Nearline < 1/month. Coldline < 1/quarter. Archive < 1/year.",
        "frequency_score": 6
    },
    {
        "id": 678,
        "topic": "BigQuery",
        "companies": [
            "Google",
            "Spotify",
            "Twitter"
        ],
        "question": "You need to store 500 TB of transaction records data in BigQuery. The data is accessed daily. Which storage class fits best to minimize costs?",
        "options": [
            "Active Storage",
            "Long-term Storage",
            "Nearline Storage",
            "Coldline Storage"
        ],
        "answer": "Active Storage",
        "explanation": "BigQuery Long-term storage applies automatically after 90 days of no modification, reducing price by ~50%.",
        "frequency_score": 10
    },
    {
        "id": 679,
        "topic": "Apache Kafka",
        "companies": [
            "Google",
            "LinkedIn",
            "Uber",
            "Netflix"
        ],
        "question": "You need to ensure strict ordering of messages in Kafka for a specific User ID. How should you configure the producer? ",
        "options": [
            "Use the User ID as the partition key",
            "Use a single partition for the entire topic",
            "Enable idempotent producer",
            "Increase replication factor"
        ],
        "answer": "Use the User ID as the partition key",
        "explanation": "Kafka guarantees ordering WITHIN a partition. Using the Entity ID as the key ensures all messages for that entity go to the same partition.",
        "frequency_score": 6
    },
    {
        "id": 680,
        "topic": "Dataflow",
        "companies": [
            "Google",
            "Spotify",
            "New York Times"
        ],
        "question": "You are building a streaming pipeline to process server logs. You need to handle rolling averages every minute for the last hour. What windowing strategy is appropriate? ",
        "options": [
            "Fixed Windows",
            "Sliding Windows",
            "Session Windows",
            "Global Windows"
        ],
        "answer": "Sliding Windows",
        "explanation": "Session windows gap-fill based on activity. Sliding windows overlap (e.g. every 5 min show last 1 hour). Fixed windows are tumbling.",
        "frequency_score": 9
    },
    {
        "id": 681,
        "topic": "Apache Spark",
        "companies": [
            "Google",
            "Databricks",
            "Facebook",
            "Netflix"
        ],
        "question": "You are optimizing a Spark job that is suffering from data skew. You are joining a large skewed table with a small reference table. Which technique is most effective? ",
        "options": [
            "Salting the key",
            "Increasing the number of executors",
            "Using a larger instance type",
            "Broadcasting the large table"
        ],
        "answer": "Salting the key",
        "explanation": "Salting adds a random prefix to the skewed key to distribute it. Broadcasting is best for Skewed Joins where one table is small.",
        "frequency_score": 6
    },
    {
        "id": 682,
        "topic": "Cloud Spanner",
        "companies": [
            "Google",
            "Uber",
            "Pokemon GO"
        ],
        "question": "You are designing a global banking ledger. You require strong consistency and 99.999% availability. Which database service should you choose? ",
        "options": [
            "Cloud Spanner",
            "Cloud SQL",
            "Bigtable",
            "Firestore"
        ],
        "answer": "Cloud Spanner",
        "explanation": "Cloud Spanner is the only service providing global strong consistency and horizontal scalability with relational semantics (SQL).",
        "frequency_score": 8
    },
    {
        "id": 683,
        "topic": "Algorithms",
        "companies": [
            "Google",
            "Amazon",
            "Microsoft"
        ],
        "question": "What is the time complexity of a Bubble Sort algorithm in the worst case? ",
        "options": [
            "O(n log n)",
            "O(n^2)",
            "O(n)",
            "O(log n)"
        ],
        "answer": "O(n^2)",
        "explanation": "Merge Sort is O(n log n). Quick Sort is O(n^2) in worst case (though avg O(n log n)). Bubble Sort is O(n^2).",
        "frequency_score": 8
    },
    {
        "id": 684,
        "topic": "Data Structures",
        "companies": [
            "Google",
            "Amazon",
            "Microsoft",
            "Facebook"
        ],
        "question": "You need to implement a look-up service that checks if a user ID exists in a set of 1 billion users with O(log n) average time complexity. Which data structure is best? ",
        "options": [
            "Hash Table / HashSet",
            "Binary Search Tree",
            "Linked List",
            "Array"
        ],
        "answer": "Binary Search Tree",
        "explanation": "Hash Tables provide O(1) average case lookup. BST is O(log n).",
        "frequency_score": 8
    },
    {
        "id": 685,
        "topic": "Apache Kafka",
        "companies": [
            "Google",
            "LinkedIn"
        ],
        "question": "What happens if a Kafka Consumer Group has more consumers than partitions in the topic? ",
        "options": [
            "Some consumers will be idle",
            "Throughput increases linearly",
            "Kafka automatically creates more partitions",
            "The extra consumers duplicate the data"
        ],
        "answer": "Some consumers will be idle",
        "explanation": "A partition can be consumed by only one consumer within a group at a time. Extra consumers stay idle.",
        "frequency_score": 6
    },
    {
        "id": 686,
        "topic": "BigQuery",
        "companies": [
            "Google",
            "Spotify",
            "Twitter"
        ],
        "question": "You need to store 1 PB of transaction records data in BigQuery. The data is accessed once a quarter. Which storage class fits best to minimize costs?",
        "options": [
            "Active Storage",
            "Long-term Storage",
            "Nearline Storage",
            "Coldline Storage"
        ],
        "answer": "Active Storage",
        "explanation": "BigQuery Long-term storage applies automatically after 90 days of no modification, reducing price by ~50%.",
        "frequency_score": 10
    },
    {
        "id": 687,
        "topic": "Cloud Spanner",
        "companies": [
            "Google",
            "Uber",
            "Pokemon GO"
        ],
        "question": "You are designing a global banking ledger. You require strong consistency and horizontal scalability. Which database service should you choose? ",
        "options": [
            "Cloud Spanner",
            "Cloud SQL",
            "Bigtable",
            "Firestore"
        ],
        "answer": "Cloud Spanner",
        "explanation": "Cloud Spanner is the only service providing global strong consistency and horizontal scalability with relational semantics (SQL).",
        "frequency_score": 8
    },
    {
        "id": 688,
        "topic": "Apache Spark",
        "companies": [
            "Google",
            "Databricks",
            "Facebook",
            "Netflix"
        ],
        "question": "You are optimizing a Spark job that is suffering from data skew. You are joining a large skewed table with a small reference table. Which technique is most effective? ",
        "options": [
            "Salting the key",
            "Increasing the number of executors",
            "Using a larger instance type",
            "Broadcasting the large table"
        ],
        "answer": "Salting the key",
        "explanation": "Salting adds a random prefix to the skewed key to distribute it. Broadcasting is best for Skewed Joins where one table is small.",
        "frequency_score": 6
    },
    {
        "id": 689,
        "topic": "Pub/Sub",
        "companies": [
            "Google",
            "Uber"
        ],
        "question": "Your application publishes high throughput messages to Pub/Sub. You observe throughput limits on specific keys. What is the most likely cause? ",
        "options": [
            "Subscribers are too slow (backlog)",
            "Publisher quota exceeded",
            "Message size too large",
            "Ordering keys are causing hotspots"
        ],
        "answer": "Ordering keys are causing hotspots",
        "explanation": "If using ordering keys, high throughput on a single key can limit scalability (1MB/s limit per key). Slow subscribers cause increased backlog.",
        "frequency_score": 7
    },
    {
        "id": 690,
        "topic": "Apache Spark",
        "companies": [
            "Google",
            "Databricks",
            "Facebook",
            "Netflix"
        ],
        "question": "You are optimizing a Spark job that is suffering from data skew. You are joining a large skewed table with a small reference table. Which technique is most effective? ",
        "options": [
            "Salting the key",
            "Increasing the number of executors",
            "Using a larger instance type",
            "Broadcasting the large table"
        ],
        "answer": "Salting the key",
        "explanation": "Salting adds a random prefix to the skewed key to distribute it. Broadcasting is best for Skewed Joins where one table is small.",
        "frequency_score": 6
    },
    {
        "id": 691,
        "topic": "IAM",
        "companies": [
            "Google"
        ],
        "question": "A developer needs to view BigQuery datasets in a production project. Following the principle of least privilege, which role should you grant? ",
        "options": [
            "Viewer",
            "Editor",
            "Owner",
            "Cloud Functions Developer"
        ],
        "answer": "Cloud Functions Developer",
        "explanation": "Always prefer predefined specific roles (like BigQuery Data Viewer, Storage Object Admin) over basic roles (Viewer/Editor/Owner) to ensure least privilege.",
        "frequency_score": 9
    },
    {
        "id": 692,
        "topic": "Apache Spark",
        "companies": [
            "Google",
            "Databricks",
            "Amazon"
        ],
        "question": "In Spark, what is the difference between a Transformation and an Action? ",
        "options": [
            "Transformations are lazy, Actions match strict execution",
            "Actions are lazy, Transformations trigger execution",
            "They are the same",
            "Transformations save to disk, Actions read from disk"
        ],
        "answer": "Transformations are lazy, Actions match strict execution",
        "explanation": "Transformations (like map, filter) build the DAG but do not execute. Actions (like count, collect, save) trigger the actual computation.",
        "frequency_score": 6
    },
    {
        "id": 693,
        "topic": "Apache Kafka",
        "companies": [
            "Google",
            "LinkedIn"
        ],
        "question": "What happens if a Kafka Consumer Group has more consumers than partitions in the topic? ",
        "options": [
            "Some consumers will be idle",
            "Throughput increases linearly",
            "Kafka automatically creates more partitions",
            "The extra consumers duplicate the data"
        ],
        "answer": "Some consumers will be idle",
        "explanation": "A partition can be consumed by only one consumer within a group at a time. Extra consumers stay idle.",
        "frequency_score": 6
    },
    {
        "id": 694,
        "topic": "Data Structures",
        "companies": [
            "Google",
            "Amazon",
            "Microsoft",
            "Facebook"
        ],
        "question": "You need to implement a look-up service that checks if a user ID exists in a set of 1 billion users with O(log n) average time complexity. Which data structure is best? ",
        "options": [
            "Hash Table / HashSet",
            "Binary Search Tree",
            "Linked List",
            "Array"
        ],
        "answer": "Binary Search Tree",
        "explanation": "Hash Tables provide O(1) average case lookup. BST is O(log n).",
        "frequency_score": 8
    },
    {
        "id": 695,
        "topic": "Apache Kafka",
        "companies": [
            "Google",
            "LinkedIn",
            "Uber",
            "Netflix"
        ],
        "question": "You need to ensure strict ordering of messages in Kafka for a specific Device ID. How should you configure the producer? ",
        "options": [
            "Use the Device ID as the partition key",
            "Use a single partition for the entire topic",
            "Enable idempotent producer",
            "Increase replication factor"
        ],
        "answer": "Use the Device ID as the partition key",
        "explanation": "Kafka guarantees ordering WITHIN a partition. Using the Entity ID as the key ensures all messages for that entity go to the same partition.",
        "frequency_score": 6
    },
    {
        "id": 696,
        "topic": "Bigtable",
        "companies": [
            "Google",
            "Spotify"
        ],
        "question": "You are designing a Bigtable schema for financial transactions. Queries will primarily be retrieve latest events for a specific entity. Which row key design is optimal? ",
        "options": [
            "SensorID#Date",
            "Date#SensorID",
            "ReverseTimestamp#SensorID",
            "Random#SensorID"
        ],
        "answer": "SensorID#Date",
        "explanation": "Avoid starting with timestamp to prevent hotspots. Use EntityID first for entity-lookup queries. Use ReverseTimestamp for 'latest items' queries globally.",
        "frequency_score": 7
    },
    {
        "id": 697,
        "topic": "Apache Kafka",
        "companies": [
            "Google",
            "LinkedIn",
            "Uber",
            "Netflix"
        ],
        "question": "You need to ensure strict ordering of messages in Kafka for a specific User ID. How should you configure the producer? ",
        "options": [
            "Use the User ID as the partition key",
            "Use a single partition for the entire topic",
            "Enable idempotent producer",
            "Increase replication factor"
        ],
        "answer": "Use the User ID as the partition key",
        "explanation": "Kafka guarantees ordering WITHIN a partition. Using the Entity ID as the key ensures all messages for that entity go to the same partition.",
        "frequency_score": 6
    },
    {
        "id": 698,
        "topic": "Apache Kafka",
        "companies": [
            "Google",
            "LinkedIn"
        ],
        "question": "What happens if a Kafka Consumer Group has more consumers than partitions in the topic? ",
        "options": [
            "Some consumers will be idle",
            "Throughput increases linearly",
            "Kafka automatically creates more partitions",
            "The extra consumers duplicate the data"
        ],
        "answer": "Some consumers will be idle",
        "explanation": "A partition can be consumed by only one consumer within a group at a time. Extra consumers stay idle.",
        "frequency_score": 6
    },
    {
        "id": 699,
        "topic": "Apache Kafka",
        "companies": [
            "Google",
            "LinkedIn"
        ],
        "question": "What happens if a Kafka Consumer Group has more consumers than partitions in the topic? ",
        "options": [
            "Some consumers will be idle",
            "Throughput increases linearly",
            "Kafka automatically creates more partitions",
            "The extra consumers duplicate the data"
        ],
        "answer": "Some consumers will be idle",
        "explanation": "A partition can be consumed by only one consumer within a group at a time. Extra consumers stay idle.",
        "frequency_score": 6
    },
    {
        "id": 700,
        "topic": "Apache Spark",
        "companies": [
            "Google",
            "Databricks",
            "Amazon"
        ],
        "question": "In Spark, what is the difference between a Transformation and an Action? ",
        "options": [
            "Transformations are lazy, Actions match strict execution",
            "Actions are lazy, Transformations trigger execution",
            "They are the same",
            "Transformations save to disk, Actions read from disk"
        ],
        "answer": "Transformations are lazy, Actions match strict execution",
        "explanation": "Transformations (like map, filter) build the DAG but do not execute. Actions (like count, collect, save) trigger the actual computation.",
        "frequency_score": 6
    },
    {
        "id": 701,
        "topic": "Pub/Sub",
        "companies": [
            "Google",
            "Uber"
        ],
        "question": "Your application publishes high throughput messages to Pub/Sub. You observe increased end-to-end latency and growing backlog. What is the most likely cause? ",
        "options": [
            "Subscribers are too slow (backlog)",
            "Publisher quota exceeded",
            "Message size too large",
            "Ordering keys are causing hotspots"
        ],
        "answer": "Subscribers are too slow (backlog)",
        "explanation": "If using ordering keys, high throughput on a single key can limit scalability (1MB/s limit per key). Slow subscribers cause increased backlog.",
        "frequency_score": 7
    },
    {
        "id": 702,
        "topic": "IAM",
        "companies": [
            "Google"
        ],
        "question": "A developer needs to view BigQuery datasets in a production project. Following the principle of least privilege, which role should you grant? ",
        "options": [
            "Viewer",
            "Editor",
            "Owner",
            "Storage Object Creator"
        ],
        "answer": "Storage Object Creator",
        "explanation": "Always prefer predefined specific roles (like BigQuery Data Viewer, Storage Object Admin) over basic roles (Viewer/Editor/Owner) to ensure least privilege.",
        "frequency_score": 9
    },
    {
        "id": 703,
        "topic": "Cloud Storage",
        "companies": [
            "Google",
            "Snapchat"
        ],
        "question": "You are designing a storage solution for disaster recovery backups. The requirement is high frequency access. What storage class should you use?",
        "options": [
            "Standard",
            "Nearline",
            "Coldline",
            "Archive"
        ],
        "answer": "Standard",
        "explanation": "Standard for hot data. Nearline < 1/month. Coldline < 1/quarter. Archive < 1/year.",
        "frequency_score": 6
    },
    {
        "id": 704,
        "topic": "Pub/Sub",
        "companies": [
            "Google",
            "Uber"
        ],
        "question": "Your application publishes high throughput messages to Pub/Sub. You observe throughput limits on specific keys. What is the most likely cause? ",
        "options": [
            "Subscribers are too slow (backlog)",
            "Publisher quota exceeded",
            "Message size too large",
            "Ordering keys are causing hotspots"
        ],
        "answer": "Ordering keys are causing hotspots",
        "explanation": "If using ordering keys, high throughput on a single key can limit scalability (1MB/s limit per key). Slow subscribers cause increased backlog.",
        "frequency_score": 7
    },
    {
        "id": 705,
        "topic": "Cloud Spanner",
        "companies": [
            "Google",
            "Uber",
            "Pokemon GO"
        ],
        "question": "You are designing a global banking ledger. You require strong consistency and horizontal scalability. Which database service should you choose? ",
        "options": [
            "Cloud Spanner",
            "Cloud SQL",
            "Bigtable",
            "Firestore"
        ],
        "answer": "Cloud Spanner",
        "explanation": "Cloud Spanner is the only service providing global strong consistency and horizontal scalability with relational semantics (SQL).",
        "frequency_score": 8
    },
    {
        "id": 706,
        "topic": "IAM",
        "companies": [
            "Google"
        ],
        "question": "A developer needs to view BigQuery datasets in a production project. Following the principle of least privilege, which role should you grant? ",
        "options": [
            "Viewer",
            "Editor",
            "Owner",
            "Cloud Functions Developer"
        ],
        "answer": "Cloud Functions Developer",
        "explanation": "Always prefer predefined specific roles (like BigQuery Data Viewer, Storage Object Admin) over basic roles (Viewer/Editor/Owner) to ensure least privilege.",
        "frequency_score": 9
    },
    {
        "id": 707,
        "topic": "Cloud Spanner",
        "companies": [
            "Google",
            "Uber",
            "Pokemon GO"
        ],
        "question": "You are designing a global banking ledger. You require strong consistency and 99.999% availability. Which database service should you choose? ",
        "options": [
            "Cloud Spanner",
            "Cloud SQL",
            "Bigtable",
            "Firestore"
        ],
        "answer": "Cloud Spanner",
        "explanation": "Cloud Spanner is the only service providing global strong consistency and horizontal scalability with relational semantics (SQL).",
        "frequency_score": 8
    },
    {
        "id": 708,
        "topic": "Data Structures",
        "companies": [
            "Google",
            "Amazon",
            "Microsoft",
            "Facebook"
        ],
        "question": "You need to implement a look-up service that checks if a user ID exists in a set of 1 billion users with O(1) average time complexity. Which data structure is best? ",
        "options": [
            "Hash Table / HashSet",
            "Binary Search Tree",
            "Linked List",
            "Array"
        ],
        "answer": "Hash Table / HashSet",
        "explanation": "Hash Tables provide O(1) average case lookup. BST is O(log n).",
        "frequency_score": 8
    },
    {
        "id": 709,
        "topic": "Pub/Sub",
        "companies": [
            "Google",
            "Uber"
        ],
        "question": "Your application publishes 1 million/sec messages to Pub/Sub. You observe throughput limits on specific keys. What is the most likely cause? ",
        "options": [
            "Subscribers are too slow (backlog)",
            "Publisher quota exceeded",
            "Message size too large",
            "Ordering keys are causing hotspots"
        ],
        "answer": "Ordering keys are causing hotspots",
        "explanation": "If using ordering keys, high throughput on a single key can limit scalability (1MB/s limit per key). Slow subscribers cause increased backlog.",
        "frequency_score": 7
    },
    {
        "id": 710,
        "topic": "Dataflow",
        "companies": [
            "Google",
            "Spotify",
            "New York Times"
        ],
        "question": "You are building a streaming pipeline to process server logs. You need to handle rolling averages every minute for the last hour. What windowing strategy is appropriate? ",
        "options": [
            "Fixed Windows",
            "Sliding Windows",
            "Session Windows",
            "Global Windows"
        ],
        "answer": "Sliding Windows",
        "explanation": "Session windows gap-fill based on activity. Sliding windows overlap (e.g. every 5 min show last 1 hour). Fixed windows are tumbling.",
        "frequency_score": 9
    },
    {
        "id": 711,
        "topic": "Algorithms",
        "companies": [
            "Google",
            "Amazon",
            "Microsoft"
        ],
        "question": "What is the time complexity of a Quick Sort algorithm in the worst case? ",
        "options": [
            "O(n log n)",
            "O(n^2)",
            "O(n)",
            "O(log n)"
        ],
        "answer": "O(n^2)",
        "explanation": "Merge Sort is O(n log n). Quick Sort is O(n^2) in worst case (though avg O(n log n)). Bubble Sort is O(n^2).",
        "frequency_score": 8
    },
    {
        "id": 712,
        "topic": "IAM",
        "companies": [
            "Google"
        ],
        "question": "A developer needs to view BigQuery datasets in a production project. Following the principle of least privilege, which role should you grant? ",
        "options": [
            "Viewer",
            "Editor",
            "Owner",
            "Storage Object Creator"
        ],
        "answer": "Storage Object Creator",
        "explanation": "Always prefer predefined specific roles (like BigQuery Data Viewer, Storage Object Admin) over basic roles (Viewer/Editor/Owner) to ensure least privilege.",
        "frequency_score": 9
    },
    {
        "id": 713,
        "topic": "IAM",
        "companies": [
            "Google"
        ],
        "question": "A developer needs to upload files to a bucket in a production project. Following the principle of least privilege, which role should you grant? ",
        "options": [
            "Viewer",
            "Editor",
            "Owner",
            "Cloud Functions Developer"
        ],
        "answer": "Cloud Functions Developer",
        "explanation": "Always prefer predefined specific roles (like BigQuery Data Viewer, Storage Object Admin) over basic roles (Viewer/Editor/Owner) to ensure least privilege.",
        "frequency_score": 9
    },
    {
        "id": 714,
        "topic": "Cloud Storage",
        "companies": [
            "Google",
            "Snapchat"
        ],
        "question": "You are designing a storage solution for profile pictures. The requirement is access once a quarter. What storage class should you use? ",
        "options": [
            "Standard",
            "Nearline",
            "Coldline",
            "Archive"
        ],
        "answer": "Coldline",
        "explanation": "Standard for hot data. Nearline < 1/month. Coldline < 1/quarter. Archive < 1/year.",
        "frequency_score": 6
    },
    {
        "id": 715,
        "topic": "Apache Spark",
        "companies": [
            "Google",
            "Databricks",
            "Amazon"
        ],
        "question": "In Spark, what is the difference between a Transformation and an Action? ",
        "options": [
            "Transformations are lazy, Actions match strict execution",
            "Actions are lazy, Transformations trigger execution",
            "They are the same",
            "Transformations save to disk, Actions read from disk"
        ],
        "answer": "Transformations are lazy, Actions match strict execution",
        "explanation": "Transformations (like map, filter) build the DAG but do not execute. Actions (like count, collect, save) trigger the actual computation.",
        "frequency_score": 6
    },
    {
        "id": 716,
        "topic": "Dataflow",
        "companies": [
            "Google",
            "Spotify",
            "New York Times"
        ],
        "question": "You are building a streaming pipeline to process user clickstreams. You need to handle hourly reporting. What windowing strategy is appropriate? ",
        "options": [
            "Fixed Windows",
            "Sliding Windows",
            "Session Windows",
            "Global Windows"
        ],
        "answer": "Fixed Windows",
        "explanation": "Session windows gap-fill based on activity. Sliding windows overlap (e.g. every 5 min show last 1 hour). Fixed windows are tumbling.",
        "frequency_score": 9
    },
    {
        "id": 717,
        "topic": "IAM",
        "companies": [
            "Google"
        ],
        "question": "A developer needs to upload files to a bucket in a production project. Following the principle of least privilege, which role should you grant? ",
        "options": [
            "Viewer",
            "Editor",
            "Owner",
            "Cloud Functions Developer"
        ],
        "answer": "Cloud Functions Developer",
        "explanation": "Always prefer predefined specific roles (like BigQuery Data Viewer, Storage Object Admin) over basic roles (Viewer/Editor/Owner) to ensure least privilege.",
        "frequency_score": 9
    },
    {
        "id": 718,
        "topic": "Cloud Spanner",
        "companies": [
            "Google",
            "Uber",
            "Pokemon GO"
        ],
        "question": "You are designing a global banking ledger. You require strong consistency and 99.999% availability. Which database service should you choose? ",
        "options": [
            "Cloud Spanner",
            "Cloud SQL",
            "Bigtable",
            "Firestore"
        ],
        "answer": "Cloud Spanner",
        "explanation": "Cloud Spanner is the only service providing global strong consistency and horizontal scalability with relational semantics (SQL).",
        "frequency_score": 8
    },
    {
        "id": 719,
        "topic": "Algorithms",
        "companies": [
            "Google",
            "Amazon",
            "Microsoft"
        ],
        "question": "What is the time complexity of a Bubble Sort algorithm in the worst case? ",
        "options": [
            "O(n log n)",
            "O(n^2)",
            "O(n)",
            "O(log n)"
        ],
        "answer": "O(n^2)",
        "explanation": "Merge Sort is O(n log n). Quick Sort is O(n^2) in worst case (though avg O(n log n)). Bubble Sort is O(n^2).",
        "frequency_score": 8
    },
    {
        "id": 720,
        "topic": "Cloud Spanner",
        "companies": [
            "Google",
            "Uber",
            "Pokemon GO"
        ],
        "question": "You are designing a global banking ledger. You require strong consistency and horizontal scalability. Which database service should you choose? ",
        "options": [
            "Cloud Spanner",
            "Cloud SQL",
            "Bigtable",
            "Firestore"
        ],
        "answer": "Cloud Spanner",
        "explanation": "Cloud Spanner is the only service providing global strong consistency and horizontal scalability with relational semantics (SQL).",
        "frequency_score": 8
    },
    {
        "id": 721,
        "topic": "Cloud Storage",
        "companies": [
            "Google",
            "Snapchat"
        ],
        "question": "You are designing a storage solution for daily analytics content. The requirement is access once a quarter. What storage class should you use? ",
        "options": [
            "Standard",
            "Nearline",
            "Coldline",
            "Archive"
        ],
        "answer": "Coldline",
        "explanation": "Standard for hot data. Nearline < 1/month. Coldline < 1/quarter. Archive < 1/year.",
        "frequency_score": 6
    },
    {
        "id": 722,
        "topic": "Apache Kafka",
        "companies": [
            "Google",
            "LinkedIn",
            "Uber",
            "Netflix"
        ],
        "question": "You need to ensure strict ordering of messages in Kafka for a specific User ID. How should you configure the producer? ",
        "options": [
            "Use the User ID as the partition key",
            "Use a single partition for the entire topic",
            "Enable idempotent producer",
            "Increase replication factor"
        ],
        "answer": "Use the User ID as the partition key",
        "explanation": "Kafka guarantees ordering WITHIN a partition. Using the Entity ID as the key ensures all messages for that entity go to the same partition.",
        "frequency_score": 6
    },
    {
        "id": 723,
        "topic": "Bigtable",
        "companies": [
            "Google",
            "Spotify"
        ],
        "question": "You are designing a Bigtable schema for IoT events. Queries will primarily be retrieve latest events for a specific entity. Which row key design is optimal? ",
        "options": [
            "UserID#Timestamp",
            "Timestamp#UserID",
            "ReverseTimestamp#UserID",
            "Random#UserID"
        ],
        "answer": "UserID#Timestamp",
        "explanation": "Avoid starting with timestamp to prevent hotspots. Use EntityID first for entity-lookup queries. Use ReverseTimestamp for 'latest items' queries globally.",
        "frequency_score": 7
    },
    {
        "id": 724,
        "topic": "IAM",
        "companies": [
            "Google"
        ],
        "question": "A developer needs to deploy Cloud Functions in a production project. Following the principle of least privilege, which role should you grant? ",
        "options": [
            "Viewer",
            "Editor",
            "Owner",
            "BigQuery Data Viewer"
        ],
        "answer": "BigQuery Data Viewer",
        "explanation": "Always prefer predefined specific roles (like BigQuery Data Viewer, Storage Object Admin) over basic roles (Viewer/Editor/Owner) to ensure least privilege.",
        "frequency_score": 9
    },
    {
        "id": 725,
        "topic": "Cloud Spanner",
        "companies": [
            "Google",
            "Uber",
            "Pokemon GO"
        ],
        "question": "You are designing a global banking ledger. You require strong consistency and horizontal scalability. Which database service should you choose? ",
        "options": [
            "Cloud Spanner",
            "Cloud SQL",
            "Bigtable",
            "Firestore"
        ],
        "answer": "Cloud Spanner",
        "explanation": "Cloud Spanner is the only service providing global strong consistency and horizontal scalability with relational semantics (SQL).",
        "frequency_score": 8
    },
    {
        "id": 726,
        "topic": "Bigtable",
        "companies": [
            "Google",
            "Spotify"
        ],
        "question": "You are designing a Bigtable schema for financial transactions. Queries will primarily be retrieve most recent events globally. Which row key design is optimal? ",
        "options": [
            "UserID#Date",
            "Date#UserID",
            "ReverseTimestamp#UserID",
            "Random#UserID"
        ],
        "answer": "ReverseTimestamp#UserID",
        "explanation": "Avoid starting with timestamp to prevent hotspots. Use EntityID first for entity-lookup queries. Use ReverseTimestamp for 'latest items' queries globally.",
        "frequency_score": 7
    },
    {
        "id": 727,
        "topic": "Apache Spark",
        "companies": [
            "Google",
            "Databricks",
            "Amazon"
        ],
        "question": "In Spark, what is the difference between a Transformation and an Action? ",
        "options": [
            "Transformations are lazy, Actions match strict execution",
            "Actions are lazy, Transformations trigger execution",
            "They are the same",
            "Transformations save to disk, Actions read from disk"
        ],
        "answer": "Transformations are lazy, Actions match strict execution",
        "explanation": "Transformations (like map, filter) build the DAG but do not execute. Actions (like count, collect, save) trigger the actual computation.",
        "frequency_score": 6
    },
    {
        "id": 728,
        "topic": "Apache Spark",
        "companies": [
            "Google",
            "Databricks",
            "Facebook",
            "Netflix"
        ],
        "question": "You are optimizing a Spark job that is suffering from data skew. You are joining a large skewed table with a small reference table. Which technique is most effective? ",
        "options": [
            "Salting the key",
            "Increasing the number of executors",
            "Using a larger instance type",
            "Broadcasting the large table"
        ],
        "answer": "Salting the key",
        "explanation": "Salting adds a random prefix to the skewed key to distribute it. Broadcasting is best for Skewed Joins where one table is small.",
        "frequency_score": 6
    },
    {
        "id": 729,
        "topic": "BigQuery",
        "companies": [
            "Google",
            "Spotify",
            "Twitter"
        ],
        "question": "You need to store 2 PB of clickstream data data in BigQuery. The data is accessed daily. Which storage class fits best to minimize costs?",
        "options": [
            "Active Storage",
            "Long-term Storage",
            "Nearline Storage",
            "Coldline Storage"
        ],
        "answer": "Active Storage",
        "explanation": "BigQuery Long-term storage applies automatically after 90 days of no modification, reducing price by ~50%.",
        "frequency_score": 10
    },
    {
        "id": 730,
        "topic": "Apache Kafka",
        "companies": [
            "Google",
            "LinkedIn",
            "Uber",
            "Netflix"
        ],
        "question": "You need to ensure strict ordering of messages in Kafka for a specific Device ID. How should you configure the producer? ",
        "options": [
            "Use the Device ID as the partition key",
            "Use a single partition for the entire topic",
            "Enable idempotent producer",
            "Increase replication factor"
        ],
        "answer": "Use the Device ID as the partition key",
        "explanation": "Kafka guarantees ordering WITHIN a partition. Using the Entity ID as the key ensures all messages for that entity go to the same partition.",
        "frequency_score": 6
    },
    {
        "id": 731,
        "topic": "Apache Spark",
        "companies": [
            "Google",
            "Databricks",
            "Facebook",
            "Netflix"
        ],
        "question": "You are optimizing a Spark job that is suffering from data skew. One task takes 10x longer than others during a wide transformation. Which technique is most effective? ",
        "options": [
            "Salting the key",
            "Increasing the number of executors",
            "Using a larger instance type",
            "Broadcasting the large table"
        ],
        "answer": "Salting the key",
        "explanation": "Salting adds a random prefix to the skewed key to distribute it. Broadcasting is best for Skewed Joins where one table is small.",
        "frequency_score": 6
    },
    {
        "id": 732,
        "topic": "BigQuery",
        "companies": [
            "Google",
            "Spotify",
            "Twitter"
        ],
        "question": "You need to store 1 PB of clickstream data data in BigQuery. The data is accessed rarely (every 6 months). Which storage class fits best to minimize costs?",
        "options": [
            "Active Storage",
            "Long-term Storage",
            "Nearline Storage",
            "Coldline Storage"
        ],
        "answer": "Long-term Storage",
        "explanation": "BigQuery Long-term storage applies automatically after 90 days of no modification, reducing price by ~50%.",
        "frequency_score": 10
    },
    {
        "id": 733,
        "topic": "Algorithms",
        "companies": [
            "Google",
            "Amazon",
            "Microsoft"
        ],
        "question": "What is the time complexity of a Quick Sort algorithm in the worst case? ",
        "options": [
            "O(n log n)",
            "O(n^2)",
            "O(n)",
            "O(log n)"
        ],
        "answer": "O(n^2)",
        "explanation": "Merge Sort is O(n log n). Quick Sort is O(n^2) in worst case (though avg O(n log n)). Bubble Sort is O(n^2).",
        "frequency_score": 8
    },
    {
        "id": 734,
        "topic": "Apache Kafka",
        "companies": [
            "Google",
            "LinkedIn",
            "Uber",
            "Netflix"
        ],
        "question": "You need to ensure strict ordering of messages in Kafka for a specific User ID. How should you configure the producer? ",
        "options": [
            "Use the User ID as the partition key",
            "Use a single partition for the entire topic",
            "Enable idempotent producer",
            "Increase replication factor"
        ],
        "answer": "Use the User ID as the partition key",
        "explanation": "Kafka guarantees ordering WITHIN a partition. Using the Entity ID as the key ensures all messages for that entity go to the same partition.",
        "frequency_score": 6
    },
    {
        "id": 735,
        "topic": "Data Structures",
        "companies": [
            "Google",
            "Amazon",
            "Microsoft",
            "Facebook"
        ],
        "question": "You need to implement a look-up service that checks if a user ID exists in a set of 1 billion users with O(log n) average time complexity. Which data structure is best? ",
        "options": [
            "Hash Table / HashSet",
            "Binary Search Tree",
            "Linked List",
            "Array"
        ],
        "answer": "Binary Search Tree",
        "explanation": "Hash Tables provide O(1) average case lookup. BST is O(log n).",
        "frequency_score": 8
    },
    {
        "id": 736,
        "topic": "Data Structures",
        "companies": [
            "Google",
            "Amazon",
            "Microsoft",
            "Facebook"
        ],
        "question": "You need to implement a look-up service that checks if a user ID exists in a set of 1 billion users with O(log n) average time complexity. Which data structure is best? ",
        "options": [
            "Hash Table / HashSet",
            "Binary Search Tree",
            "Linked List",
            "Array"
        ],
        "answer": "Binary Search Tree",
        "explanation": "Hash Tables provide O(1) average case lookup. BST is O(log n).",
        "frequency_score": 8
    },
    {
        "id": 737,
        "topic": "Data Structures",
        "companies": [
            "Google",
            "Amazon",
            "Microsoft",
            "Facebook"
        ],
        "question": "You need to implement a look-up service that checks if a user ID exists in a set of 1 billion users with O(log n) average time complexity. Which data structure is best? ",
        "options": [
            "Hash Table / HashSet",
            "Binary Search Tree",
            "Linked List",
            "Array"
        ],
        "answer": "Binary Search Tree",
        "explanation": "Hash Tables provide O(1) average case lookup. BST is O(log n).",
        "frequency_score": 8
    },
    {
        "id": 738,
        "topic": "IAM",
        "companies": [
            "Google"
        ],
        "question": "A developer needs to deploy Cloud Functions in a production project. Following the principle of least privilege, which role should you grant? ",
        "options": [
            "Viewer",
            "Editor",
            "Owner",
            "Cloud Functions Developer"
        ],
        "answer": "Cloud Functions Developer",
        "explanation": "Always prefer predefined specific roles (like BigQuery Data Viewer, Storage Object Admin) over basic roles (Viewer/Editor/Owner) to ensure least privilege.",
        "frequency_score": 9
    },
    {
        "id": 739,
        "topic": "Bigtable",
        "companies": [
            "Google",
            "Spotify"
        ],
        "question": "You are designing a Bigtable schema for financial transactions. Queries will primarily be retrieve latest events for a specific entity. Which row key design is optimal? ",
        "options": [
            "UserID#Timestamp",
            "Timestamp#UserID",
            "ReverseTimestamp#UserID",
            "Random#UserID"
        ],
        "answer": "UserID#Timestamp",
        "explanation": "Avoid starting with timestamp to prevent hotspots. Use EntityID first for entity-lookup queries. Use ReverseTimestamp for 'latest items' queries globally.",
        "frequency_score": 7
    },
    {
        "id": 740,
        "topic": "IAM",
        "companies": [
            "Google"
        ],
        "question": "A developer needs to upload files to a bucket in a production project. Following the principle of least privilege, which role should you grant? ",
        "options": [
            "Viewer",
            "Editor",
            "Owner",
            "BigQuery Data Viewer"
        ],
        "answer": "BigQuery Data Viewer",
        "explanation": "Always prefer predefined specific roles (like BigQuery Data Viewer, Storage Object Admin) over basic roles (Viewer/Editor/Owner) to ensure least privilege.",
        "frequency_score": 9
    },
    {
        "id": 741,
        "topic": "Data Structures",
        "companies": [
            "Google",
            "Amazon",
            "Microsoft",
            "Facebook"
        ],
        "question": "You need to implement a look-up service that checks if a user ID exists in a set of 1 billion users with O(1) average time complexity. Which data structure is best? ",
        "options": [
            "Hash Table / HashSet",
            "Binary Search Tree",
            "Linked List",
            "Array"
        ],
        "answer": "Hash Table / HashSet",
        "explanation": "Hash Tables provide O(1) average case lookup. BST is O(log n).",
        "frequency_score": 8
    },
    {
        "id": 742,
        "topic": "Data Structures",
        "companies": [
            "Google",
            "Amazon",
            "Microsoft",
            "Facebook"
        ],
        "question": "You need to implement a look-up service that checks if a user ID exists in a set of 1 billion users with O(log n) average time complexity. Which data structure is best? ",
        "options": [
            "Hash Table / HashSet",
            "Binary Search Tree",
            "Linked List",
            "Array"
        ],
        "answer": "Binary Search Tree",
        "explanation": "Hash Tables provide O(1) average case lookup. BST is O(log n).",
        "frequency_score": 8
    },
    {
        "id": 743,
        "topic": "IAM",
        "companies": [
            "Google"
        ],
        "question": "A developer needs to view BigQuery datasets in a production project. Following the principle of least privilege, which role should you grant? ",
        "options": [
            "Viewer",
            "Editor",
            "Owner",
            "BigQuery Data Viewer"
        ],
        "answer": "BigQuery Data Viewer",
        "explanation": "Always prefer predefined specific roles (like BigQuery Data Viewer, Storage Object Admin) over basic roles (Viewer/Editor/Owner) to ensure least privilege.",
        "frequency_score": 9
    },
    {
        "id": 744,
        "topic": "Pub/Sub",
        "companies": [
            "Google",
            "Uber"
        ],
        "question": "Your application publishes high throughput messages to Pub/Sub. You observe throughput limits on specific keys. What is the most likely cause? ",
        "options": [
            "Subscribers are too slow (backlog)",
            "Publisher quota exceeded",
            "Message size too large",
            "Ordering keys are causing hotspots"
        ],
        "answer": "Ordering keys are causing hotspots",
        "explanation": "If using ordering keys, high throughput on a single key can limit scalability (1MB/s limit per key). Slow subscribers cause increased backlog.",
        "frequency_score": 7
    },
    {
        "id": 745,
        "topic": "Bigtable",
        "companies": [
            "Google",
            "Spotify"
        ],
        "question": "You are designing a Bigtable schema for social media posts. Queries will primarily be retrieve most recent events globally. Which row key design is optimal? ",
        "options": [
            "SensorID#Timestamp",
            "Timestamp#SensorID",
            "ReverseTimestamp#SensorID",
            "Random#SensorID"
        ],
        "answer": "ReverseTimestamp#SensorID",
        "explanation": "Avoid starting with timestamp to prevent hotspots. Use EntityID first for entity-lookup queries. Use ReverseTimestamp for 'latest items' queries globally.",
        "frequency_score": 7
    },
    {
        "id": 746,
        "topic": "Cloud Storage",
        "companies": [
            "Google",
            "Snapchat"
        ],
        "question": "You are designing a storage solution for regulatory archives. The requirement is high frequency access. What storage class should you use? ",
        "options": [
            "Standard",
            "Nearline",
            "Coldline",
            "Archive"
        ],
        "answer": "Standard",
        "explanation": "Standard for hot data. Nearline < 1/month. Coldline < 1/quarter. Archive < 1/year.",
        "frequency_score": 6
    },
    {
        "id": 747,
        "topic": "Bigtable",
        "companies": [
            "Google",
            "Spotify"
        ],
        "question": "You are designing a Bigtable schema for social media posts. Queries will primarily be retrieve latest events for a specific entity. Which row key design is optimal? ",
        "options": [
            "SensorID#Timestamp",
            "Timestamp#SensorID",
            "ReverseTimestamp#SensorID",
            "Random#SensorID"
        ],
        "answer": "SensorID#Timestamp",
        "explanation": "Avoid starting with timestamp to prevent hotspots. Use EntityID first for entity-lookup queries. Use ReverseTimestamp for 'latest items' queries globally.",
        "frequency_score": 7
    },
    {
        "id": 748,
        "topic": "Apache Spark",
        "companies": [
            "Google",
            "Databricks",
            "Amazon"
        ],
        "question": "In Spark, what is the difference between a Transformation and an Action? ",
        "options": [
            "Transformations are lazy, Actions match strict execution",
            "Actions are lazy, Transformations trigger execution",
            "They are the same",
            "Transformations save to disk, Actions read from disk"
        ],
        "answer": "Transformations are lazy, Actions match strict execution",
        "explanation": "Transformations (like map, filter) build the DAG but do not execute. Actions (like count, collect, save) trigger the actual computation.",
        "frequency_score": 6
    },
    {
        "id": 749,
        "topic": "Apache Spark",
        "companies": [
            "Google",
            "Databricks",
            "Amazon"
        ],
        "question": "In Spark, what is the difference between a Transformation and an Action? ",
        "options": [
            "Transformations are lazy, Actions match strict execution",
            "Actions are lazy, Transformations trigger execution",
            "They are the same",
            "Transformations save to disk, Actions read from disk"
        ],
        "answer": "Transformations are lazy, Actions match strict execution",
        "explanation": "Transformations (like map, filter) build the DAG but do not execute. Actions (like count, collect, save) trigger the actual computation.",
        "frequency_score": 6
    },
    {
        "id": 750,
        "topic": "Apache Kafka",
        "companies": [
            "Google",
            "LinkedIn"
        ],
        "question": "What happens if a Kafka Consumer Group has more consumers than partitions in the topic? ",
        "options": [
            "Some consumers will be idle",
            "Throughput increases linearly",
            "Kafka automatically creates more partitions",
            "The extra consumers duplicate the data"
        ],
        "answer": "Some consumers will be idle",
        "explanation": "A partition can be consumed by only one consumer within a group at a time. Extra consumers stay idle.",
        "frequency_score": 6
    },
    {
        "id": 751,
        "topic": "Cloud Spanner",
        "companies": [
            "Google",
            "Uber",
            "Pokemon GO"
        ],
        "question": "You are designing a global banking ledger. You require strong consistency and 99.999% availability. Which database service should you choose? ",
        "options": [
            "Cloud Spanner",
            "Cloud SQL",
            "Bigtable",
            "Firestore"
        ],
        "answer": "Cloud Spanner",
        "explanation": "Cloud Spanner is the only service providing global strong consistency and horizontal scalability with relational semantics (SQL).",
        "frequency_score": 8
    },
    {
        "id": 752,
        "topic": "Dataflow",
        "companies": [
            "Google",
            "Spotify",
            "New York Times"
        ],
        "question": "You are building a streaming pipeline to process server logs. You need to handle periods of user activity separated by gaps. What windowing strategy is appropriate? ",
        "options": [
            "Fixed Windows",
            "Sliding Windows",
            "Session Windows",
            "Global Windows"
        ],
        "answer": "Session Windows",
        "explanation": "Session windows gap-fill based on activity. Sliding windows overlap (e.g. every 5 min show last 1 hour). Fixed windows are tumbling.",
        "frequency_score": 9
    },
    {
        "id": 753,
        "topic": "BigQuery",
        "companies": [
            "Google",
            "Spotify",
            "Twitter"
        ],
        "question": "You need to store 50 TB of sensor metrics data in BigQuery. The data is accessed daily. Which storage class fits best to minimize costs?",
        "options": [
            "Active Storage",
            "Long-term Storage",
            "Nearline Storage",
            "Coldline Storage"
        ],
        "answer": "Active Storage",
        "explanation": "BigQuery Long-term storage applies automatically after 90 days of no modification, reducing price by ~50%.",
        "frequency_score": 10
    },
    {
        "id": 754,
        "topic": "Apache Kafka",
        "companies": [
            "Google",
            "LinkedIn"
        ],
        "question": "What happens if a Kafka Consumer Group has more consumers than partitions in the topic? ",
        "options": [
            "Some consumers will be idle",
            "Throughput increases linearly",
            "Kafka automatically creates more partitions",
            "The extra consumers duplicate the data"
        ],
        "answer": "Some consumers will be idle",
        "explanation": "A partition can be consumed by only one consumer within a group at a time. Extra consumers stay idle.",
        "frequency_score": 6
    },
    {
        "id": 755,
        "topic": "Pub/Sub",
        "companies": [
            "Google",
            "Uber"
        ],
        "question": "Your application publishes 1 million/sec messages to Pub/Sub. You observe throughput limits on specific keys. What is the most likely cause? ",
        "options": [
            "Subscribers are too slow (backlog)",
            "Publisher quota exceeded",
            "Message size too large",
            "Ordering keys are causing hotspots"
        ],
        "answer": "Ordering keys are causing hotspots",
        "explanation": "If using ordering keys, high throughput on a single key can limit scalability (1MB/s limit per key). Slow subscribers cause increased backlog.",
        "frequency_score": 7
    },
    {
        "id": 756,
        "topic": "Apache Kafka",
        "companies": [
            "Google",
            "LinkedIn"
        ],
        "question": "What happens if a Kafka Consumer Group has more consumers than partitions in the topic? ",
        "options": [
            "Some consumers will be idle",
            "Throughput increases linearly",
            "Kafka automatically creates more partitions",
            "The extra consumers duplicate the data"
        ],
        "answer": "Some consumers will be idle",
        "explanation": "A partition can be consumed by only one consumer within a group at a time. Extra consumers stay idle.",
        "frequency_score": 6
    },
    {
        "id": 757,
        "topic": "Data Structures",
        "companies": [
            "Google",
            "Amazon",
            "Microsoft",
            "Facebook"
        ],
        "question": "You need to implement a look-up service that checks if a user ID exists in a set of 1 billion users with O(1) average time complexity. Which data structure is best? ",
        "options": [
            "Hash Table / HashSet",
            "Binary Search Tree",
            "Linked List",
            "Array"
        ],
        "answer": "Hash Table / HashSet",
        "explanation": "Hash Tables provide O(1) average case lookup. BST is O(log n).",
        "frequency_score": 8
    },
    {
        "id": 758,
        "topic": "Cloud Spanner",
        "companies": [
            "Google",
            "Uber",
            "Pokemon GO"
        ],
        "question": "You are designing a global banking ledger. You require strong consistency and horizontal scalability. Which database service should you choose? ",
        "options": [
            "Cloud Spanner",
            "Cloud SQL",
            "Bigtable",
            "Firestore"
        ],
        "answer": "Cloud Spanner",
        "explanation": "Cloud Spanner is the only service providing global strong consistency and horizontal scalability with relational semantics (SQL).",
        "frequency_score": 8
    },
    {
        "id": 759,
        "topic": "Apache Spark",
        "companies": [
            "Google",
            "Databricks",
            "Amazon"
        ],
        "question": "In Spark, what is the difference between a Transformation and an Action? ",
        "options": [
            "Transformations are lazy, Actions match strict execution",
            "Actions are lazy, Transformations trigger execution",
            "They are the same",
            "Transformations save to disk, Actions read from disk"
        ],
        "answer": "Transformations are lazy, Actions match strict execution",
        "explanation": "Transformations (like map, filter) build the DAG but do not execute. Actions (like count, collect, save) trigger the actual computation.",
        "frequency_score": 6
    },
    {
        "id": 760,
        "topic": "Pub/Sub",
        "companies": [
            "Google",
            "Uber"
        ],
        "question": "Your application publishes 1 million/sec messages to Pub/Sub. You observe increased end-to-end latency and growing backlog. What is the most likely cause? ",
        "options": [
            "Subscribers are too slow (backlog)",
            "Publisher quota exceeded",
            "Message size too large",
            "Ordering keys are causing hotspots"
        ],
        "answer": "Subscribers are too slow (backlog)",
        "explanation": "If using ordering keys, high throughput on a single key can limit scalability (1MB/s limit per key). Slow subscribers cause increased backlog.",
        "frequency_score": 7
    },
    {
        "id": 761,
        "topic": "Apache Spark",
        "companies": [
            "Google",
            "Databricks",
            "Amazon"
        ],
        "question": "In Spark, what is the difference between a Transformation and an Action? ",
        "options": [
            "Transformations are lazy, Actions match strict execution",
            "Actions are lazy, Transformations trigger execution",
            "They are the same",
            "Transformations save to disk, Actions read from disk"
        ],
        "answer": "Transformations are lazy, Actions match strict execution",
        "explanation": "Transformations (like map, filter) build the DAG but do not execute. Actions (like count, collect, save) trigger the actual computation.",
        "frequency_score": 6
    },
    {
        "id": 762,
        "topic": "IAM",
        "companies": [
            "Google"
        ],
        "question": "A developer needs to view BigQuery datasets in a production project. Following the principle of least privilege, which role should you grant? ",
        "options": [
            "Viewer",
            "Editor",
            "Owner",
            "BigQuery Data Viewer"
        ],
        "answer": "BigQuery Data Viewer",
        "explanation": "Always prefer predefined specific roles (like BigQuery Data Viewer, Storage Object Admin) over basic roles (Viewer/Editor/Owner) to ensure least privilege.",
        "frequency_score": 9
    },
    {
        "id": 763,
        "topic": "BigQuery",
        "companies": [
            "Google",
            "Spotify",
            "Twitter"
        ],
        "question": "You need to store 2 PB of sensor metrics data in BigQuery. The data is accessed continuously. Which storage class fits best to minimize costs?",
        "options": [
            "Active Storage",
            "Long-term Storage",
            "Nearline Storage",
            "Coldline Storage"
        ],
        "answer": "Active Storage",
        "explanation": "BigQuery Long-term storage applies automatically after 90 days of no modification, reducing price by ~50%.",
        "frequency_score": 10
    },
    {
        "id": 764,
        "topic": "Bigtable",
        "companies": [
            "Google",
            "Spotify"
        ],
        "question": "You are designing a Bigtable schema for IoT events. Queries will primarily be retrieve most recent events globally. Which row key design is optimal? ",
        "options": [
            "UserID#Date",
            "Date#UserID",
            "ReverseTimestamp#UserID",
            "Random#UserID"
        ],
        "answer": "ReverseTimestamp#UserID",
        "explanation": "Avoid starting with timestamp to prevent hotspots. Use EntityID first for entity-lookup queries. Use ReverseTimestamp for 'latest items' queries globally.",
        "frequency_score": 7
    },
    {
        "id": 765,
        "topic": "Data Structures",
        "companies": [
            "Google",
            "Amazon",
            "Microsoft",
            "Facebook"
        ],
        "question": "You need to implement a look-up service that checks if a user ID exists in a set of 1 billion users with O(1) average time complexity. Which data structure is best? ",
        "options": [
            "Hash Table / HashSet",
            "Binary Search Tree",
            "Linked List",
            "Array"
        ],
        "answer": "Hash Table / HashSet",
        "explanation": "Hash Tables provide O(1) average case lookup. BST is O(log n).",
        "frequency_score": 8
    },
    {
        "id": 766,
        "topic": "Data Structures",
        "companies": [
            "Google",
            "Amazon",
            "Microsoft",
            "Facebook"
        ],
        "question": "You need to implement a look-up service that checks if a user ID exists in a set of 1 billion users with O(log n) average time complexity. Which data structure is best? ",
        "options": [
            "Hash Table / HashSet",
            "Binary Search Tree",
            "Linked List",
            "Array"
        ],
        "answer": "Binary Search Tree",
        "explanation": "Hash Tables provide O(1) average case lookup. BST is O(log n).",
        "frequency_score": 8
    },
    {
        "id": 767,
        "topic": "BigQuery",
        "companies": [
            "Google",
            "Spotify",
            "Twitter"
        ],
        "question": "You need to store 500 TB of transaction records data in BigQuery. The data is accessed once a quarter. Which storage class fits best to minimize costs? ",
        "options": [
            "Active Storage",
            "Long-term Storage",
            "Nearline Storage",
            "Coldline Storage"
        ],
        "answer": "Active Storage",
        "explanation": "BigQuery Long-term storage applies automatically after 90 days of no modification, reducing price by ~50%.",
        "frequency_score": 10
    },
    {
        "id": 768,
        "topic": "Cloud Storage",
        "companies": [
            "Google",
            "Snapchat"
        ],
        "question": "You are designing a storage solution for disaster recovery backups. The requirement is access once a year. What storage class should you use? ",
        "options": [
            "Standard",
            "Nearline",
            "Coldline",
            "Archive"
        ],
        "answer": "Archive",
        "explanation": "Standard for hot data. Nearline < 1/month. Coldline < 1/quarter. Archive < 1/year.",
        "frequency_score": 6
    },
    {
        "id": 769,
        "topic": "BigQuery",
        "companies": [
            "Google",
            "Spotify",
            "Twitter"
        ],
        "question": "You need to store 500 TB of audit logs data in BigQuery. The data is accessed rarely (every 6 months). Which storage class fits best to minimize costs?",
        "options": [
            "Active Storage",
            "Long-term Storage",
            "Nearline Storage",
            "Coldline Storage"
        ],
        "answer": "Long-term Storage",
        "explanation": "BigQuery Long-term storage applies automatically after 90 days of no modification, reducing price by ~50%.",
        "frequency_score": 10
    },
    {
        "id": 770,
        "topic": "BigQuery",
        "companies": [
            "Google",
            "Spotify",
            "Twitter"
        ],
        "question": "You need to store 1 PB of clickstream data data in BigQuery. The data is accessed daily. Which storage class fits best to minimize costs?",
        "options": [
            "Active Storage",
            "Long-term Storage",
            "Nearline Storage",
            "Coldline Storage"
        ],
        "answer": "Active Storage",
        "explanation": "BigQuery Long-term storage applies automatically after 90 days of no modification, reducing price by ~50%.",
        "frequency_score": 10
    },
    {
        "id": 771,
        "topic": "Dataflow",
        "companies": [
            "Google",
            "Spotify",
            "New York Times"
        ],
        "question": "You are building a streaming pipeline to process user clickstreams. You need to handle periods of user activity separated by gaps. What windowing strategy is appropriate? ",
        "options": [
            "Fixed Windows",
            "Sliding Windows",
            "Session Windows",
            "Global Windows"
        ],
        "answer": "Session Windows",
        "explanation": "Session windows gap-fill based on activity. Sliding windows overlap (e.g. every 5 min show last 1 hour). Fixed windows are tumbling.",
        "frequency_score": 9
    },
    {
        "id": 772,
        "topic": "Cloud Storage",
        "companies": [
            "Google",
            "Snapchat"
        ],
        "question": "You are designing a storage solution for regulatory archives. The requirement is high frequency access. What storage class should you use? ",
        "options": [
            "Standard",
            "Nearline",
            "Coldline",
            "Archive"
        ],
        "answer": "Standard",
        "explanation": "Standard for hot data. Nearline < 1/month. Coldline < 1/quarter. Archive < 1/year.",
        "frequency_score": 6
    },
    {
        "id": 773,
        "topic": "Cloud Spanner",
        "companies": [
            "Google",
            "Uber",
            "Pokemon GO"
        ],
        "question": "You are designing a global banking ledger. You require strong consistency and 99.999% availability. Which database service should you choose? ",
        "options": [
            "Cloud Spanner",
            "Cloud SQL",
            "Bigtable",
            "Firestore"
        ],
        "answer": "Cloud Spanner",
        "explanation": "Cloud Spanner is the only service providing global strong consistency and horizontal scalability with relational semantics (SQL).",
        "frequency_score": 8
    },
    {
        "id": 774,
        "topic": "Dataflow",
        "companies": [
            "Google",
            "Spotify",
            "New York Times"
        ],
        "question": "You are building a streaming pipeline to process server logs. You need to handle rolling averages every minute for the last hour. What windowing strategy is appropriate? ",
        "options": [
            "Fixed Windows",
            "Sliding Windows",
            "Session Windows",
            "Global Windows"
        ],
        "answer": "Sliding Windows",
        "explanation": "Session windows gap-fill based on activity. Sliding windows overlap (e.g. every 5 min show last 1 hour). Fixed windows are tumbling.",
        "frequency_score": 9
    },
    {
        "id": 775,
        "topic": "Pub/Sub",
        "companies": [
            "Google",
            "Uber"
        ],
        "question": "Your application publishes 1 million/sec messages to Pub/Sub. You observe increased end-to-end latency and growing backlog. What is the most likely cause? ",
        "options": [
            "Subscribers are too slow (backlog)",
            "Publisher quota exceeded",
            "Message size too large",
            "Ordering keys are causing hotspots"
        ],
        "answer": "Subscribers are too slow (backlog)",
        "explanation": "If using ordering keys, high throughput on a single key can limit scalability (1MB/s limit per key). Slow subscribers cause increased backlog.",
        "frequency_score": 7
    },
    {
        "id": 776,
        "topic": "Apache Spark",
        "companies": [
            "Google",
            "Databricks",
            "Facebook",
            "Netflix"
        ],
        "question": "You are optimizing a Spark job that is suffering from data skew. You are joining a large skewed table with a small reference table. Which technique is most effective? ",
        "options": [
            "Salting the key",
            "Increasing the number of executors",
            "Using a larger instance type",
            "Broadcasting the large table"
        ],
        "answer": "Salting the key",
        "explanation": "Salting adds a random prefix to the skewed key to distribute it. Broadcasting is best for Skewed Joins where one table is small.",
        "frequency_score": 6
    },
    {
        "id": 777,
        "topic": "Data Structures",
        "companies": [
            "Google",
            "Amazon",
            "Microsoft",
            "Facebook"
        ],
        "question": "You need to implement a look-up service that checks if a user ID exists in a set of 1 billion users with O(1) average time complexity. Which data structure is best? ",
        "options": [
            "Hash Table / HashSet",
            "Binary Search Tree",
            "Linked List",
            "Array"
        ],
        "answer": "Hash Table / HashSet",
        "explanation": "Hash Tables provide O(1) average case lookup. BST is O(log n).",
        "frequency_score": 8
    },
    {
        "id": 778,
        "topic": "Algorithms",
        "companies": [
            "Google",
            "Amazon",
            "Microsoft"
        ],
        "question": "What is the time complexity of a Merge Sort algorithm in the worst case? ",
        "options": [
            "O(n log n)",
            "O(n^2)",
            "O(n)",
            "O(log n)"
        ],
        "answer": "O(n log n)",
        "explanation": "Merge Sort is O(n log n). Quick Sort is O(n^2) in worst case (though avg O(n log n)). Bubble Sort is O(n^2).",
        "frequency_score": 8
    },
    {
        "id": 779,
        "topic": "Apache Kafka",
        "companies": [
            "Google",
            "LinkedIn"
        ],
        "question": "What happens if a Kafka Consumer Group has more consumers than partitions in the topic? ",
        "options": [
            "Some consumers will be idle",
            "Throughput increases linearly",
            "Kafka automatically creates more partitions",
            "The extra consumers duplicate the data"
        ],
        "answer": "Some consumers will be idle",
        "explanation": "A partition can be consumed by only one consumer within a group at a time. Extra consumers stay idle.",
        "frequency_score": 6
    },
    {
        "id": 780,
        "topic": "Algorithms",
        "companies": [
            "Google",
            "Amazon",
            "Microsoft"
        ],
        "question": "What is the time complexity of a Quick Sort algorithm in the worst case? ",
        "options": [
            "O(n log n)",
            "O(n^2)",
            "O(n)",
            "O(log n)"
        ],
        "answer": "O(n^2)",
        "explanation": "Merge Sort is O(n log n). Quick Sort is O(n^2) in worst case (though avg O(n log n)). Bubble Sort is O(n^2).",
        "frequency_score": 8
    },
    {
        "id": 781,
        "topic": "Cloud Spanner",
        "companies": [
            "Google",
            "Uber",
            "Pokemon GO"
        ],
        "question": "You are designing a global banking ledger. You require strong consistency and 99.999% availability. Which database service should you choose? ",
        "options": [
            "Cloud Spanner",
            "Cloud SQL",
            "Bigtable",
            "Firestore"
        ],
        "answer": "Cloud Spanner",
        "explanation": "Cloud Spanner is the only service providing global strong consistency and horizontal scalability with relational semantics (SQL).",
        "frequency_score": 8
    },
    {
        "id": 782,
        "topic": "Cloud Storage",
        "companies": [
            "Google",
            "Snapchat"
        ],
        "question": "You are designing a storage solution for disaster recovery backups. The requirement is high frequency access. What storage class should you use? ",
        "options": [
            "Standard",
            "Nearline",
            "Coldline",
            "Archive"
        ],
        "answer": "Standard",
        "explanation": "Standard for hot data. Nearline < 1/month. Coldline < 1/quarter. Archive < 1/year.",
        "frequency_score": 6
    },
    {
        "id": 783,
        "topic": "Data Structures",
        "companies": [
            "Google",
            "Amazon",
            "Microsoft",
            "Facebook"
        ],
        "question": "You need to implement a look-up service that checks if a user ID exists in a set of 1 billion users with O(log n) average time complexity. Which data structure is best? ",
        "options": [
            "Hash Table / HashSet",
            "Binary Search Tree",
            "Linked List",
            "Array"
        ],
        "answer": "Binary Search Tree",
        "explanation": "Hash Tables provide O(1) average case lookup. BST is O(log n).",
        "frequency_score": 8
    },
    {
        "id": 784,
        "topic": "Cloud Storage",
        "companies": [
            "Google",
            "Snapchat"
        ],
        "question": "You are designing a storage solution for regulatory archives. The requirement is access once a quarter. What storage class should you use? ",
        "options": [
            "Standard",
            "Nearline",
            "Coldline",
            "Archive"
        ],
        "answer": "Coldline",
        "explanation": "Standard for hot data. Nearline < 1/month. Coldline < 1/quarter. Archive < 1/year.",
        "frequency_score": 6
    },
    {
        "id": 785,
        "topic": "Cloud Storage",
        "companies": [
            "Google",
            "Snapchat"
        ],
        "question": "You are designing a storage solution for profile pictures. The requirement is access once a quarter. What storage class should you use? ",
        "options": [
            "Standard",
            "Nearline",
            "Coldline",
            "Archive"
        ],
        "answer": "Coldline",
        "explanation": "Standard for hot data. Nearline < 1/month. Coldline < 1/quarter. Archive < 1/year.",
        "frequency_score": 6
    },
    {
        "id": 786,
        "topic": "Cloud Spanner",
        "companies": [
            "Google",
            "Uber",
            "Pokemon GO"
        ],
        "question": "You are designing a global banking ledger. You require strong consistency and 99.999% availability. Which database service should you choose? ",
        "options": [
            "Cloud Spanner",
            "Cloud SQL",
            "Bigtable",
            "Firestore"
        ],
        "answer": "Cloud Spanner",
        "explanation": "Cloud Spanner is the only service providing global strong consistency and horizontal scalability with relational semantics (SQL).",
        "frequency_score": 8
    },
    {
        "id": 787,
        "topic": "Apache Spark",
        "companies": [
            "Google",
            "Databricks",
            "Amazon"
        ],
        "question": "In Spark, what is the difference between a Transformation and an Action? ",
        "options": [
            "Transformations are lazy, Actions match strict execution",
            "Actions are lazy, Transformations trigger execution",
            "They are the same",
            "Transformations save to disk, Actions read from disk"
        ],
        "answer": "Transformations are lazy, Actions match strict execution",
        "explanation": "Transformations (like map, filter) build the DAG but do not execute. Actions (like count, collect, save) trigger the actual computation.",
        "frequency_score": 6
    },
    {
        "id": 788,
        "topic": "Apache Spark",
        "companies": [
            "Google",
            "Databricks",
            "Facebook",
            "Netflix"
        ],
        "question": "You are optimizing a Spark job that is suffering from data skew. You are joining a large skewed table with a small reference table. Which technique is most effective? ",
        "options": [
            "Salting the key",
            "Increasing the number of executors",
            "Using a larger instance type",
            "Broadcasting the large table"
        ],
        "answer": "Salting the key",
        "explanation": "Salting adds a random prefix to the skewed key to distribute it. Broadcasting is best for Skewed Joins where one table is small.",
        "frequency_score": 6
    },
    {
        "id": 789,
        "topic": "Apache Kafka",
        "companies": [
            "Google",
            "LinkedIn"
        ],
        "question": "What happens if a Kafka Consumer Group has more consumers than partitions in the topic? ",
        "options": [
            "Some consumers will be idle",
            "Throughput increases linearly",
            "Kafka automatically creates more partitions",
            "The extra consumers duplicate the data"
        ],
        "answer": "Some consumers will be idle",
        "explanation": "A partition can be consumed by only one consumer within a group at a time. Extra consumers stay idle.",
        "frequency_score": 6
    },
    {
        "id": 790,
        "topic": "Bigtable",
        "companies": [
            "Google",
            "Spotify"
        ],
        "question": "You are designing a Bigtable schema for financial transactions. Queries will primarily be retrieve most recent events globally. Which row key design is optimal? ",
        "options": [
            "UserID#Date",
            "Date#UserID",
            "ReverseTimestamp#UserID",
            "Random#UserID"
        ],
        "answer": "ReverseTimestamp#UserID",
        "explanation": "Avoid starting with timestamp to prevent hotspots. Use EntityID first for entity-lookup queries. Use ReverseTimestamp for 'latest items' queries globally.",
        "frequency_score": 7
    },
    {
        "id": 791,
        "topic": "Cloud Spanner",
        "companies": [
            "Google",
            "Uber",
            "Pokemon GO"
        ],
        "question": "You are designing a global banking ledger. You require strong consistency and 99.999% availability. Which database service should you choose? ",
        "options": [
            "Cloud Spanner",
            "Cloud SQL",
            "Bigtable",
            "Firestore"
        ],
        "answer": "Cloud Spanner",
        "explanation": "Cloud Spanner is the only service providing global strong consistency and horizontal scalability with relational semantics (SQL).",
        "frequency_score": 8
    },
    {
        "id": 792,
        "topic": "Data Structures",
        "companies": [
            "Google",
            "Amazon",
            "Microsoft",
            "Facebook"
        ],
        "question": "You need to implement a look-up service that checks if a user ID exists in a set of 1 billion users with O(log n) average time complexity. Which data structure is best? ",
        "options": [
            "Hash Table / HashSet",
            "Binary Search Tree",
            "Linked List",
            "Array"
        ],
        "answer": "Binary Search Tree",
        "explanation": "Hash Tables provide O(1) average case lookup. BST is O(log n).",
        "frequency_score": 8
    },
    {
        "id": 793,
        "topic": "IAM",
        "companies": [
            "Google"
        ],
        "question": "A developer needs to upload files to a bucket in a production project. Following the principle of least privilege, which role should you grant? ",
        "options": [
            "Viewer",
            "Editor",
            "Owner",
            "Cloud Functions Developer"
        ],
        "answer": "Cloud Functions Developer",
        "explanation": "Always prefer predefined specific roles (like BigQuery Data Viewer, Storage Object Admin) over basic roles (Viewer/Editor/Owner) to ensure least privilege.",
        "frequency_score": 9
    },
    {
        "id": 794,
        "topic": "Apache Kafka",
        "companies": [
            "Google",
            "LinkedIn"
        ],
        "question": "What happens if a Kafka Consumer Group has more consumers than partitions in the topic? ",
        "options": [
            "Some consumers will be idle",
            "Throughput increases linearly",
            "Kafka automatically creates more partitions",
            "The extra consumers duplicate the data"
        ],
        "answer": "Some consumers will be idle",
        "explanation": "A partition can be consumed by only one consumer within a group at a time. Extra consumers stay idle.",
        "frequency_score": 6
    },
    {
        "id": 795,
        "topic": "Bigtable",
        "companies": [
            "Google",
            "Spotify"
        ],
        "question": "You are designing a Bigtable schema for social media posts. Queries will primarily be retrieve most recent events globally. Which row key design is optimal? ",
        "options": [
            "SensorID#Date",
            "Date#SensorID",
            "ReverseTimestamp#SensorID",
            "Random#SensorID"
        ],
        "answer": "ReverseTimestamp#SensorID",
        "explanation": "Avoid starting with timestamp to prevent hotspots. Use EntityID first for entity-lookup queries. Use ReverseTimestamp for 'latest items' queries globally.",
        "frequency_score": 7
    },
    {
        "id": 796,
        "topic": "BigQuery",
        "companies": [
            "Google",
            "Spotify",
            "Twitter"
        ],
        "question": "You need to store 1 PB of clickstream data data in BigQuery. The data is accessed rarely (every 6 months). Which storage class fits best to minimize costs? ",
        "options": [
            "Active Storage",
            "Long-term Storage",
            "Nearline Storage",
            "Coldline Storage"
        ],
        "answer": "Long-term Storage",
        "explanation": "BigQuery Long-term storage applies automatically after 90 days of no modification, reducing price by ~50%.",
        "frequency_score": 10
    },
    {
        "id": 797,
        "topic": "Dataflow",
        "companies": [
            "Google",
            "Spotify",
            "New York Times"
        ],
        "question": "You are building a streaming pipeline to process user clickstreams. You need to handle rolling averages every minute for the last hour. What windowing strategy is appropriate? ",
        "options": [
            "Fixed Windows",
            "Sliding Windows",
            "Session Windows",
            "Global Windows"
        ],
        "answer": "Sliding Windows",
        "explanation": "Session windows gap-fill based on activity. Sliding windows overlap (e.g. every 5 min show last 1 hour). Fixed windows are tumbling.",
        "frequency_score": 9
    },
    {
        "id": 798,
        "topic": "Data Structures",
        "companies": [
            "Google",
            "Amazon",
            "Microsoft",
            "Facebook"
        ],
        "question": "You need to implement a look-up service that checks if a user ID exists in a set of 1 billion users with O(log n) average time complexity. Which data structure is best? ",
        "options": [
            "Hash Table / HashSet",
            "Binary Search Tree",
            "Linked List",
            "Array"
        ],
        "answer": "Binary Search Tree",
        "explanation": "Hash Tables provide O(1) average case lookup. BST is O(log n).",
        "frequency_score": 8
    },
    {
        "id": 799,
        "topic": "Apache Spark",
        "companies": [
            "Google",
            "Databricks",
            "Facebook",
            "Netflix"
        ],
        "question": "You are optimizing a Spark job that is suffering from data skew. You are joining a large skewed table with a small reference table. Which technique is most effective? ",
        "options": [
            "Salting the key",
            "Increasing the number of executors",
            "Using a larger instance type",
            "Broadcasting the large table"
        ],
        "answer": "Salting the key",
        "explanation": "Salting adds a random prefix to the skewed key to distribute it. Broadcasting is best for Skewed Joins where one table is small.",
        "frequency_score": 6
    },
    {
        "id": 800,
        "topic": "Apache Kafka",
        "companies": [
            "Google",
            "LinkedIn",
            "Uber",
            "Netflix"
        ],
        "question": "You need to ensure strict ordering of messages in Kafka for a specific User ID. How should you configure the producer? ",
        "options": [
            "Use the User ID as the partition key",
            "Use a single partition for the entire topic",
            "Enable idempotent producer",
            "Increase replication factor"
        ],
        "answer": "Use the User ID as the partition key",
        "explanation": "Kafka guarantees ordering WITHIN a partition. Using the Entity ID as the key ensures all messages for that entity go to the same partition.",
        "frequency_score": 6
    },
    {
        "id": 801,
        "topic": "BigQuery",
        "companies": [
            "Google",
            "Spotify",
            "Twitter"
        ],
        "question": "You need to store 500 TB of sensor metrics data in BigQuery. The data is accessed rarely (every 6 months). Which storage class fits best to minimize costs?",
        "options": [
            "Active Storage",
            "Long-term Storage",
            "Nearline Storage",
            "Coldline Storage"
        ],
        "answer": "Long-term Storage",
        "explanation": "BigQuery Long-term storage applies automatically after 90 days of no modification, reducing price by ~50%.",
        "frequency_score": 10
    },
    {
        "id": 802,
        "topic": "Pub/Sub",
        "companies": [
            "Google",
            "Uber"
        ],
        "question": "Your application publishes 1 million/sec messages to Pub/Sub. You observe increased end-to-end latency and growing backlog. What is the most likely cause? ",
        "options": [
            "Subscribers are too slow (backlog)",
            "Publisher quota exceeded",
            "Message size too large",
            "Ordering keys are causing hotspots"
        ],
        "answer": "Subscribers are too slow (backlog)",
        "explanation": "If using ordering keys, high throughput on a single key can limit scalability (1MB/s limit per key). Slow subscribers cause increased backlog.",
        "frequency_score": 7
    },
    {
        "id": 803,
        "topic": "Pub/Sub",
        "companies": [
            "Google",
            "Uber"
        ],
        "question": "Your application publishes high throughput messages to Pub/Sub. You observe increased end-to-end latency and growing backlog. What is the most likely cause? ",
        "options": [
            "Subscribers are too slow (backlog)",
            "Publisher quota exceeded",
            "Message size too large",
            "Ordering keys are causing hotspots"
        ],
        "answer": "Subscribers are too slow (backlog)",
        "explanation": "If using ordering keys, high throughput on a single key can limit scalability (1MB/s limit per key). Slow subscribers cause increased backlog.",
        "frequency_score": 7
    },
    {
        "id": 804,
        "topic": "Apache Kafka",
        "companies": [
            "Google",
            "LinkedIn",
            "Uber",
            "Netflix"
        ],
        "question": "You need to ensure strict ordering of messages in Kafka for a specific User ID. How should you configure the producer? ",
        "options": [
            "Use the User ID as the partition key",
            "Use a single partition for the entire topic",
            "Enable idempotent producer",
            "Increase replication factor"
        ],
        "answer": "Use the User ID as the partition key",
        "explanation": "Kafka guarantees ordering WITHIN a partition. Using the Entity ID as the key ensures all messages for that entity go to the same partition.",
        "frequency_score": 6
    },
    {
        "id": 805,
        "topic": "Pub/Sub",
        "companies": [
            "Google",
            "Uber"
        ],
        "question": "Your application publishes 1 million/sec messages to Pub/Sub. You observe throughput limits on specific keys. What is the most likely cause? ",
        "options": [
            "Subscribers are too slow (backlog)",
            "Publisher quota exceeded",
            "Message size too large",
            "Ordering keys are causing hotspots"
        ],
        "answer": "Ordering keys are causing hotspots",
        "explanation": "If using ordering keys, high throughput on a single key can limit scalability (1MB/s limit per key). Slow subscribers cause increased backlog.",
        "frequency_score": 7
    },
    {
        "id": 806,
        "topic": "Cloud Storage",
        "companies": [
            "Google",
            "Snapchat"
        ],
        "question": "You are designing a storage solution for daily analytics content. The requirement is access once a quarter. What storage class should you use? ",
        "options": [
            "Standard",
            "Nearline",
            "Coldline",
            "Archive"
        ],
        "answer": "Coldline",
        "explanation": "Standard for hot data. Nearline < 1/month. Coldline < 1/quarter. Archive < 1/year.",
        "frequency_score": 6
    },
    {
        "id": 807,
        "topic": "Dataflow",
        "companies": [
            "Google",
            "Spotify",
            "New York Times"
        ],
        "question": "You are building a streaming pipeline to process IoT temperature sensors. You need to handle hourly reporting. What windowing strategy is appropriate? ",
        "options": [
            "Fixed Windows",
            "Sliding Windows",
            "Session Windows",
            "Global Windows"
        ],
        "answer": "Fixed Windows",
        "explanation": "Session windows gap-fill based on activity. Sliding windows overlap (e.g. every 5 min show last 1 hour). Fixed windows are tumbling.",
        "frequency_score": 9
    },
    {
        "id": 808,
        "topic": "BigQuery",
        "companies": [
            "Google",
            "Spotify",
            "Twitter"
        ],
        "question": "You need to store 1 PB of audit logs data in BigQuery. The data is accessed once a quarter. Which storage class fits best to minimize costs? ",
        "options": [
            "Active Storage",
            "Long-term Storage",
            "Nearline Storage",
            "Coldline Storage"
        ],
        "answer": "Active Storage",
        "explanation": "BigQuery Long-term storage applies automatically after 90 days of no modification, reducing price by ~50%.",
        "frequency_score": 10
    },
    {
        "id": 809,
        "topic": "Data Structures",
        "companies": [
            "Google",
            "Amazon",
            "Microsoft",
            "Facebook"
        ],
        "question": "You need to implement a look-up service that checks if a user ID exists in a set of 1 billion users with O(1) average time complexity. Which data structure is best? ",
        "options": [
            "Hash Table / HashSet",
            "Binary Search Tree",
            "Linked List",
            "Array"
        ],
        "answer": "Hash Table / HashSet",
        "explanation": "Hash Tables provide O(1) average case lookup. BST is O(log n).",
        "frequency_score": 8
    },
    {
        "id": 810,
        "topic": "BigQuery",
        "companies": [
            "Google",
            "Spotify",
            "Twitter"
        ],
        "question": "You need to store 2 PB of sensor metrics data in BigQuery. The data is accessed daily. Which storage class fits best to minimize costs? ",
        "options": [
            "Active Storage",
            "Long-term Storage",
            "Nearline Storage",
            "Coldline Storage"
        ],
        "answer": "Active Storage",
        "explanation": "BigQuery Long-term storage applies automatically after 90 days of no modification, reducing price by ~50%.",
        "frequency_score": 10
    },
    {
        "id": 811,
        "topic": "Apache Spark",
        "companies": [
            "Google",
            "Databricks",
            "Facebook",
            "Netflix"
        ],
        "question": "You are optimizing a Spark job that is suffering from data skew. One task takes 10x longer than others during a wide transformation. Which technique is most effective? ",
        "options": [
            "Salting the key",
            "Increasing the number of executors",
            "Using a larger instance type",
            "Broadcasting the large table"
        ],
        "answer": "Salting the key",
        "explanation": "Salting adds a random prefix to the skewed key to distribute it. Broadcasting is best for Skewed Joins where one table is small.",
        "frequency_score": 6
    },
    {
        "id": 812,
        "topic": "Apache Spark",
        "companies": [
            "Google",
            "Databricks",
            "Facebook",
            "Netflix"
        ],
        "question": "You are optimizing a Spark job that is suffering from data skew. One task takes 10x longer than others during a wide transformation. Which technique is most effective? ",
        "options": [
            "Salting the key",
            "Increasing the number of executors",
            "Using a larger instance type",
            "Broadcasting the large table"
        ],
        "answer": "Salting the key",
        "explanation": "Salting adds a random prefix to the skewed key to distribute it. Broadcasting is best for Skewed Joins where one table is small.",
        "frequency_score": 6
    },
    {
        "id": 813,
        "topic": "Cloud Spanner",
        "companies": [
            "Google",
            "Uber",
            "Pokemon GO"
        ],
        "question": "You are designing a global banking ledger. You require strong consistency and 99.999% availability. Which database service should you choose? ",
        "options": [
            "Cloud Spanner",
            "Cloud SQL",
            "Bigtable",
            "Firestore"
        ],
        "answer": "Cloud Spanner",
        "explanation": "Cloud Spanner is the only service providing global strong consistency and horizontal scalability with relational semantics (SQL).",
        "frequency_score": 8
    },
    {
        "id": 814,
        "topic": "Pub/Sub",
        "companies": [
            "Google",
            "Uber"
        ],
        "question": "Your application publishes high throughput messages to Pub/Sub. You observe increased end-to-end latency and growing backlog. What is the most likely cause? ",
        "options": [
            "Subscribers are too slow (backlog)",
            "Publisher quota exceeded",
            "Message size too large",
            "Ordering keys are causing hotspots"
        ],
        "answer": "Subscribers are too slow (backlog)",
        "explanation": "If using ordering keys, high throughput on a single key can limit scalability (1MB/s limit per key). Slow subscribers cause increased backlog.",
        "frequency_score": 7
    },
    {
        "id": 815,
        "topic": "Pub/Sub",
        "companies": [
            "Google",
            "Uber"
        ],
        "question": "Your application publishes 1 million/sec messages to Pub/Sub. You observe throughput limits on specific keys. What is the most likely cause? ",
        "options": [
            "Subscribers are too slow (backlog)",
            "Publisher quota exceeded",
            "Message size too large",
            "Ordering keys are causing hotspots"
        ],
        "answer": "Ordering keys are causing hotspots",
        "explanation": "If using ordering keys, high throughput on a single key can limit scalability (1MB/s limit per key). Slow subscribers cause increased backlog.",
        "frequency_score": 7
    },
    {
        "id": 816,
        "topic": "Apache Kafka",
        "companies": [
            "Google",
            "LinkedIn",
            "Uber",
            "Netflix"
        ],
        "question": "You need to ensure strict ordering of messages in Kafka for a specific Transaction ID. How should you configure the producer? ",
        "options": [
            "Use the Transaction ID as the partition key",
            "Use a single partition for the entire topic",
            "Enable idempotent producer",
            "Increase replication factor"
        ],
        "answer": "Use the Transaction ID as the partition key",
        "explanation": "Kafka guarantees ordering WITHIN a partition. Using the Entity ID as the key ensures all messages for that entity go to the same partition.",
        "frequency_score": 6
    },
    {
        "id": 817,
        "topic": "Bigtable",
        "companies": [
            "Google",
            "Spotify"
        ],
        "question": "You are designing a Bigtable schema for IoT events. Queries will primarily be retrieve latest events for a specific entity. Which row key design is optimal? ",
        "options": [
            "DeviceID#Timestamp",
            "Timestamp#DeviceID",
            "ReverseTimestamp#DeviceID",
            "Random#DeviceID"
        ],
        "answer": "DeviceID#Timestamp",
        "explanation": "Avoid starting with timestamp to prevent hotspots. Use EntityID first for entity-lookup queries. Use ReverseTimestamp for 'latest items' queries globally.",
        "frequency_score": 7
    },
    {
        "id": 818,
        "topic": "Apache Spark",
        "companies": [
            "Google",
            "Databricks",
            "Facebook",
            "Netflix"
        ],
        "question": "You are optimizing a Spark job that is suffering from data skew. One task takes 10x longer than others during a wide transformation. Which technique is most effective? ",
        "options": [
            "Salting the key",
            "Increasing the number of executors",
            "Using a larger instance type",
            "Broadcasting the large table"
        ],
        "answer": "Salting the key",
        "explanation": "Salting adds a random prefix to the skewed key to distribute it. Broadcasting is best for Skewed Joins where one table is small.",
        "frequency_score": 6
    },
    {
        "id": 819,
        "topic": "Cloud Storage",
        "companies": [
            "Google",
            "Snapchat"
        ],
        "question": "You are designing a storage solution for profile pictures. The requirement is high frequency access. What storage class should you use? ",
        "options": [
            "Standard",
            "Nearline",
            "Coldline",
            "Archive"
        ],
        "answer": "Standard",
        "explanation": "Standard for hot data. Nearline < 1/month. Coldline < 1/quarter. Archive < 1/year.",
        "frequency_score": 6
    },
    {
        "id": 820,
        "topic": "IAM",
        "companies": [
            "Google"
        ],
        "question": "A developer needs to upload files to a bucket in a production project. Following the principle of least privilege, which role should you grant? ",
        "options": [
            "Viewer",
            "Editor",
            "Owner",
            "BigQuery Data Viewer"
        ],
        "answer": "BigQuery Data Viewer",
        "explanation": "Always prefer predefined specific roles (like BigQuery Data Viewer, Storage Object Admin) over basic roles (Viewer/Editor/Owner) to ensure least privilege.",
        "frequency_score": 9
    },
    {
        "id": 821,
        "topic": "Bigtable",
        "companies": [
            "Google",
            "Spotify"
        ],
        "question": "You are designing a Bigtable schema for financial transactions. Queries will primarily be retrieve most recent events globally. Which row key design is optimal? ",
        "options": [
            "SensorID#Timestamp",
            "Timestamp#SensorID",
            "ReverseTimestamp#SensorID",
            "Random#SensorID"
        ],
        "answer": "ReverseTimestamp#SensorID",
        "explanation": "Avoid starting with timestamp to prevent hotspots. Use EntityID first for entity-lookup queries. Use ReverseTimestamp for 'latest items' queries globally.",
        "frequency_score": 7
    },
    {
        "id": 822,
        "topic": "Algorithms",
        "companies": [
            "Google",
            "Amazon",
            "Microsoft"
        ],
        "question": "What is the time complexity of a Bubble Sort algorithm in the worst case? ",
        "options": [
            "O(n log n)",
            "O(n^2)",
            "O(n)",
            "O(log n)"
        ],
        "answer": "O(n^2)",
        "explanation": "Merge Sort is O(n log n). Quick Sort is O(n^2) in worst case (though avg O(n log n)). Bubble Sort is O(n^2).",
        "frequency_score": 8
    },
    {
        "id": 823,
        "topic": "Bigtable",
        "companies": [
            "Google",
            "Spotify"
        ],
        "question": "You are designing a Bigtable schema for IoT events. Queries will primarily be retrieve most recent events globally. Which row key design is optimal? ",
        "options": [
            "SensorID#Timestamp",
            "Timestamp#SensorID",
            "ReverseTimestamp#SensorID",
            "Random#SensorID"
        ],
        "answer": "ReverseTimestamp#SensorID",
        "explanation": "Avoid starting with timestamp to prevent hotspots. Use EntityID first for entity-lookup queries. Use ReverseTimestamp for 'latest items' queries globally.",
        "frequency_score": 7
    },
    {
        "id": 824,
        "topic": "BigQuery",
        "companies": [
            "Google",
            "Spotify",
            "Twitter"
        ],
        "question": "You need to store 50 TB of transaction records data in BigQuery. The data is accessed daily. Which storage class fits best to minimize costs? ",
        "options": [
            "Active Storage",
            "Long-term Storage",
            "Nearline Storage",
            "Coldline Storage"
        ],
        "answer": "Active Storage",
        "explanation": "BigQuery Long-term storage applies automatically after 90 days of no modification, reducing price by ~50%.",
        "frequency_score": 10
    },
    {
        "id": 825,
        "topic": "Bigtable",
        "companies": [
            "Google",
            "Spotify"
        ],
        "question": "You are designing a Bigtable schema for social media posts. Queries will primarily be retrieve most recent events globally. Which row key design is optimal? ",
        "options": [
            "DeviceID#Date",
            "Date#DeviceID",
            "ReverseTimestamp#DeviceID",
            "Random#DeviceID"
        ],
        "answer": "ReverseTimestamp#DeviceID",
        "explanation": "Avoid starting with timestamp to prevent hotspots. Use EntityID first for entity-lookup queries. Use ReverseTimestamp for 'latest items' queries globally.",
        "frequency_score": 7
    },
    {
        "id": 826,
        "topic": "Algorithms",
        "companies": [
            "Google",
            "Amazon",
            "Microsoft"
        ],
        "question": "What is the time complexity of a Quick Sort algorithm in the worst case? ",
        "options": [
            "O(n log n)",
            "O(n^2)",
            "O(n)",
            "O(log n)"
        ],
        "answer": "O(n^2)",
        "explanation": "Merge Sort is O(n log n). Quick Sort is O(n^2) in worst case (though avg O(n log n)). Bubble Sort is O(n^2).",
        "frequency_score": 8
    },
    {
        "id": 827,
        "topic": "Pub/Sub",
        "companies": [
            "Google",
            "Uber"
        ],
        "question": "Your application publishes high throughput messages to Pub/Sub. You observe throughput limits on specific keys. What is the most likely cause? ",
        "options": [
            "Subscribers are too slow (backlog)",
            "Publisher quota exceeded",
            "Message size too large",
            "Ordering keys are causing hotspots"
        ],
        "answer": "Ordering keys are causing hotspots",
        "explanation": "If using ordering keys, high throughput on a single key can limit scalability (1MB/s limit per key). Slow subscribers cause increased backlog.",
        "frequency_score": 7
    },
    {
        "id": 828,
        "topic": "Cloud Storage",
        "companies": [
            "Google",
            "Snapchat"
        ],
        "question": "You are designing a storage solution for daily analytics content. The requirement is access once a month. What storage class should you use? ",
        "options": [
            "Standard",
            "Nearline",
            "Coldline",
            "Archive"
        ],
        "answer": "Nearline",
        "explanation": "Standard for hot data. Nearline < 1/month. Coldline < 1/quarter. Archive < 1/year.",
        "frequency_score": 6
    },
    {
        "id": 829,
        "topic": "Algorithms",
        "companies": [
            "Google",
            "Amazon",
            "Microsoft"
        ],
        "question": "What is the time complexity of a Bubble Sort algorithm in the worst case? ",
        "options": [
            "O(n log n)",
            "O(n^2)",
            "O(n)",
            "O(log n)"
        ],
        "answer": "O(n^2)",
        "explanation": "Merge Sort is O(n log n). Quick Sort is O(n^2) in worst case (though avg O(n log n)). Bubble Sort is O(n^2).",
        "frequency_score": 8
    },
    {
        "id": 830,
        "topic": "Dataflow",
        "companies": [
            "Google",
            "Spotify",
            "New York Times"
        ],
        "question": "You are building a streaming pipeline to process user clickstreams. You need to handle hourly reporting. What windowing strategy is appropriate? ",
        "options": [
            "Fixed Windows",
            "Sliding Windows",
            "Session Windows",
            "Global Windows"
        ],
        "answer": "Fixed Windows",
        "explanation": "Session windows gap-fill based on activity. Sliding windows overlap (e.g. every 5 min show last 1 hour). Fixed windows are tumbling.",
        "frequency_score": 9
    },
    {
        "id": 831,
        "topic": "Cloud Spanner",
        "companies": [
            "Google",
            "Uber",
            "Pokemon GO"
        ],
        "question": "You are designing a global banking ledger. You require strong consistency and 99.999% availability. Which database service should you choose? ",
        "options": [
            "Cloud Spanner",
            "Cloud SQL",
            "Bigtable",
            "Firestore"
        ],
        "answer": "Cloud Spanner",
        "explanation": "Cloud Spanner is the only service providing global strong consistency and horizontal scalability with relational semantics (SQL).",
        "frequency_score": 8
    },
    {
        "id": 832,
        "topic": "Pub/Sub",
        "companies": [
            "Google",
            "Uber"
        ],
        "question": "Your application publishes 1 million/sec messages to Pub/Sub. You observe increased end-to-end latency and growing backlog. What is the most likely cause? ",
        "options": [
            "Subscribers are too slow (backlog)",
            "Publisher quota exceeded",
            "Message size too large",
            "Ordering keys are causing hotspots"
        ],
        "answer": "Subscribers are too slow (backlog)",
        "explanation": "If using ordering keys, high throughput on a single key can limit scalability (1MB/s limit per key). Slow subscribers cause increased backlog.",
        "frequency_score": 7
    },
    {
        "id": 833,
        "topic": "Dataflow",
        "companies": [
            "Google",
            "Spotify",
            "New York Times"
        ],
        "question": "You are building a streaming pipeline to process user clickstreams. You need to handle hourly reporting. What windowing strategy is appropriate? ",
        "options": [
            "Fixed Windows",
            "Sliding Windows",
            "Session Windows",
            "Global Windows"
        ],
        "answer": "Fixed Windows",
        "explanation": "Session windows gap-fill based on activity. Sliding windows overlap (e.g. every 5 min show last 1 hour). Fixed windows are tumbling.",
        "frequency_score": 9
    },
    {
        "id": 834,
        "topic": "Apache Spark",
        "companies": [
            "Google",
            "Databricks",
            "Facebook",
            "Netflix"
        ],
        "question": "You are optimizing a Spark job that is suffering from data skew. One task takes 10x longer than others during a wide transformation. Which technique is most effective? ",
        "options": [
            "Salting the key",
            "Increasing the number of executors",
            "Using a larger instance type",
            "Broadcasting the large table"
        ],
        "answer": "Salting the key",
        "explanation": "Salting adds a random prefix to the skewed key to distribute it. Broadcasting is best for Skewed Joins where one table is small.",
        "frequency_score": 6
    },
    {
        "id": 835,
        "topic": "Pub/Sub",
        "companies": [
            "Google",
            "Uber"
        ],
        "question": "Your application publishes 1 million/sec messages to Pub/Sub. You observe increased end-to-end latency and growing backlog. What is the most likely cause? ",
        "options": [
            "Subscribers are too slow (backlog)",
            "Publisher quota exceeded",
            "Message size too large",
            "Ordering keys are causing hotspots"
        ],
        "answer": "Subscribers are too slow (backlog)",
        "explanation": "If using ordering keys, high throughput on a single key can limit scalability (1MB/s limit per key). Slow subscribers cause increased backlog.",
        "frequency_score": 7
    },
    {
        "id": 836,
        "topic": "Bigtable",
        "companies": [
            "Google",
            "Spotify"
        ],
        "question": "You are designing a Bigtable schema for financial transactions. Queries will primarily be retrieve most recent events globally. Which row key design is optimal? ",
        "options": [
            "DeviceID#Timestamp",
            "Timestamp#DeviceID",
            "ReverseTimestamp#DeviceID",
            "Random#DeviceID"
        ],
        "answer": "ReverseTimestamp#DeviceID",
        "explanation": "Avoid starting with timestamp to prevent hotspots. Use EntityID first for entity-lookup queries. Use ReverseTimestamp for 'latest items' queries globally.",
        "frequency_score": 7
    },
    {
        "id": 837,
        "topic": "Cloud Spanner",
        "companies": [
            "Google",
            "Uber",
            "Pokemon GO"
        ],
        "question": "You are designing a global banking ledger. You require strong consistency and 99.999% availability. Which database service should you choose? ",
        "options": [
            "Cloud Spanner",
            "Cloud SQL",
            "Bigtable",
            "Firestore"
        ],
        "answer": "Cloud Spanner",
        "explanation": "Cloud Spanner is the only service providing global strong consistency and horizontal scalability with relational semantics (SQL).",
        "frequency_score": 8
    },
    {
        "id": 838,
        "topic": "Apache Kafka",
        "companies": [
            "Google",
            "LinkedIn",
            "Uber",
            "Netflix"
        ],
        "question": "You need to ensure strict ordering of messages in Kafka for a specific User ID. How should you configure the producer? ",
        "options": [
            "Use the User ID as the partition key",
            "Use a single partition for the entire topic",
            "Enable idempotent producer",
            "Increase replication factor"
        ],
        "answer": "Use the User ID as the partition key",
        "explanation": "Kafka guarantees ordering WITHIN a partition. Using the Entity ID as the key ensures all messages for that entity go to the same partition.",
        "frequency_score": 6
    },
    {
        "id": 839,
        "topic": "Cloud Storage",
        "companies": [
            "Google",
            "Snapchat"
        ],
        "question": "You are designing a storage solution for disaster recovery backups. The requirement is high frequency access. What storage class should you use? ",
        "options": [
            "Standard",
            "Nearline",
            "Coldline",
            "Archive"
        ],
        "answer": "Standard",
        "explanation": "Standard for hot data. Nearline < 1/month. Coldline < 1/quarter. Archive < 1/year.",
        "frequency_score": 6
    },
    {
        "id": 840,
        "topic": "Cloud Spanner",
        "companies": [
            "Google",
            "Uber",
            "Pokemon GO"
        ],
        "question": "You are designing a global banking ledger. You require strong consistency and horizontal scalability. Which database service should you choose? ",
        "options": [
            "Cloud Spanner",
            "Cloud SQL",
            "Bigtable",
            "Firestore"
        ],
        "answer": "Cloud Spanner",
        "explanation": "Cloud Spanner is the only service providing global strong consistency and horizontal scalability with relational semantics (SQL).",
        "frequency_score": 8
    },
    {
        "id": 841,
        "topic": "IAM",
        "companies": [
            "Google"
        ],
        "question": "A developer needs to view BigQuery datasets in a production project. Following the principle of least privilege, which role should you grant? ",
        "options": [
            "Viewer",
            "Editor",
            "Owner",
            "BigQuery Data Viewer"
        ],
        "answer": "BigQuery Data Viewer",
        "explanation": "Always prefer predefined specific roles (like BigQuery Data Viewer, Storage Object Admin) over basic roles (Viewer/Editor/Owner) to ensure least privilege.",
        "frequency_score": 9
    },
    {
        "id": 842,
        "topic": "Algorithms",
        "companies": [
            "Google",
            "Amazon",
            "Microsoft"
        ],
        "question": "What is the time complexity of a Merge Sort algorithm in the worst case? ",
        "options": [
            "O(n log n)",
            "O(n^2)",
            "O(n)",
            "O(log n)"
        ],
        "answer": "O(n log n)",
        "explanation": "Merge Sort is O(n log n). Quick Sort is O(n^2) in worst case (though avg O(n log n)). Bubble Sort is O(n^2).",
        "frequency_score": 8
    },
    {
        "id": 843,
        "topic": "Data Structures",
        "companies": [
            "Google",
            "Amazon",
            "Microsoft",
            "Facebook"
        ],
        "question": "You need to implement a look-up service that checks if a user ID exists in a set of 1 billion users with O(log n) average time complexity. Which data structure is best? ",
        "options": [
            "Hash Table / HashSet",
            "Binary Search Tree",
            "Linked List",
            "Array"
        ],
        "answer": "Binary Search Tree",
        "explanation": "Hash Tables provide O(1) average case lookup. BST is O(log n).",
        "frequency_score": 8
    },
    {
        "id": 844,
        "topic": "Dataflow",
        "companies": [
            "Google",
            "Spotify",
            "New York Times"
        ],
        "question": "You are building a streaming pipeline to process user clickstreams. You need to handle periods of user activity separated by gaps. What windowing strategy is appropriate? ",
        "options": [
            "Fixed Windows",
            "Sliding Windows",
            "Session Windows",
            "Global Windows"
        ],
        "answer": "Session Windows",
        "explanation": "Session windows gap-fill based on activity. Sliding windows overlap (e.g. every 5 min show last 1 hour). Fixed windows are tumbling.",
        "frequency_score": 9
    },
    {
        "id": 845,
        "topic": "Apache Spark",
        "companies": [
            "Google",
            "Databricks",
            "Amazon"
        ],
        "question": "In Spark, what is the difference between a Transformation and an Action? ",
        "options": [
            "Transformations are lazy, Actions match strict execution",
            "Actions are lazy, Transformations trigger execution",
            "They are the same",
            "Transformations save to disk, Actions read from disk"
        ],
        "answer": "Transformations are lazy, Actions match strict execution",
        "explanation": "Transformations (like map, filter) build the DAG but do not execute. Actions (like count, collect, save) trigger the actual computation.",
        "frequency_score": 6
    },
    {
        "id": 846,
        "topic": "Apache Spark",
        "companies": [
            "Google",
            "Databricks",
            "Amazon"
        ],
        "question": "In Spark, what is the difference between a Transformation and an Action? ",
        "options": [
            "Transformations are lazy, Actions match strict execution",
            "Actions are lazy, Transformations trigger execution",
            "They are the same",
            "Transformations save to disk, Actions read from disk"
        ],
        "answer": "Transformations are lazy, Actions match strict execution",
        "explanation": "Transformations (like map, filter) build the DAG but do not execute. Actions (like count, collect, save) trigger the actual computation.",
        "frequency_score": 6
    },
    {
        "id": 847,
        "topic": "Apache Kafka",
        "companies": [
            "Google",
            "LinkedIn"
        ],
        "question": "What happens if a Kafka Consumer Group has more consumers than partitions in the topic? ",
        "options": [
            "Some consumers will be idle",
            "Throughput increases linearly",
            "Kafka automatically creates more partitions",
            "The extra consumers duplicate the data"
        ],
        "answer": "Some consumers will be idle",
        "explanation": "A partition can be consumed by only one consumer within a group at a time. Extra consumers stay idle.",
        "frequency_score": 6
    },
    {
        "id": 848,
        "topic": "Apache Kafka",
        "companies": [
            "Google",
            "LinkedIn",
            "Uber",
            "Netflix"
        ],
        "question": "You need to ensure strict ordering of messages in Kafka for a specific Transaction ID. How should you configure the producer? ",
        "options": [
            "Use the Transaction ID as the partition key",
            "Use a single partition for the entire topic",
            "Enable idempotent producer",
            "Increase replication factor"
        ],
        "answer": "Use the Transaction ID as the partition key",
        "explanation": "Kafka guarantees ordering WITHIN a partition. Using the Entity ID as the key ensures all messages for that entity go to the same partition.",
        "frequency_score": 6
    },
    {
        "id": 849,
        "topic": "Apache Spark",
        "companies": [
            "Google",
            "Databricks",
            "Facebook",
            "Netflix"
        ],
        "question": "You are optimizing a Spark job that is suffering from data skew. You are joining a large skewed table with a small reference table. Which technique is most effective? ",
        "options": [
            "Salting the key",
            "Increasing the number of executors",
            "Using a larger instance type",
            "Broadcasting the large table"
        ],
        "answer": "Salting the key",
        "explanation": "Salting adds a random prefix to the skewed key to distribute it. Broadcasting is best for Skewed Joins where one table is small.",
        "frequency_score": 6
    },
    {
        "id": 850,
        "topic": "BigQuery",
        "companies": [
            "Google",
            "Spotify",
            "Twitter"
        ],
        "question": "You need to store 50 TB of transaction records data in BigQuery. The data is accessed once a quarter. Which storage class fits best to minimize costs? ",
        "options": [
            "Active Storage",
            "Long-term Storage",
            "Nearline Storage",
            "Coldline Storage"
        ],
        "answer": "Active Storage",
        "explanation": "BigQuery Long-term storage applies automatically after 90 days of no modification, reducing price by ~50%.",
        "frequency_score": 10
    },
    {
        "id": 851,
        "topic": "Cloud Storage",
        "companies": [
            "Google",
            "Snapchat"
        ],
        "question": "You are designing a storage solution for daily analytics content. The requirement is access once a month. What storage class should you use? ",
        "options": [
            "Standard",
            "Nearline",
            "Coldline",
            "Archive"
        ],
        "answer": "Nearline",
        "explanation": "Standard for hot data. Nearline < 1/month. Coldline < 1/quarter. Archive < 1/year.",
        "frequency_score": 6
    },
    {
        "id": 852,
        "topic": "BigQuery",
        "companies": [
            "Google",
            "Spotify",
            "Twitter"
        ],
        "question": "You need to store 2 PB of audit logs data in BigQuery. The data is accessed continuously. Which storage class fits best to minimize costs? ",
        "options": [
            "Active Storage",
            "Long-term Storage",
            "Nearline Storage",
            "Coldline Storage"
        ],
        "answer": "Active Storage",
        "explanation": "BigQuery Long-term storage applies automatically after 90 days of no modification, reducing price by ~50%.",
        "frequency_score": 10
    },
    {
        "id": 853,
        "topic": "Apache Kafka",
        "companies": [
            "Google",
            "LinkedIn"
        ],
        "question": "What happens if a Kafka Consumer Group has more consumers than partitions in the topic? ",
        "options": [
            "Some consumers will be idle",
            "Throughput increases linearly",
            "Kafka automatically creates more partitions",
            "The extra consumers duplicate the data"
        ],
        "answer": "Some consumers will be idle",
        "explanation": "A partition can be consumed by only one consumer within a group at a time. Extra consumers stay idle.",
        "frequency_score": 6
    },
    {
        "id": 854,
        "topic": "Apache Spark",
        "companies": [
            "Google",
            "Databricks",
            "Facebook",
            "Netflix"
        ],
        "question": "You are optimizing a Spark job that is suffering from data skew. One task takes 10x longer than others during a wide transformation. Which technique is most effective? ",
        "options": [
            "Salting the key",
            "Increasing the number of executors",
            "Using a larger instance type",
            "Broadcasting the large table"
        ],
        "answer": "Salting the key",
        "explanation": "Salting adds a random prefix to the skewed key to distribute it. Broadcasting is best for Skewed Joins where one table is small.",
        "frequency_score": 6
    },
    {
        "id": 855,
        "topic": "Apache Spark",
        "companies": [
            "Google",
            "Databricks",
            "Facebook",
            "Netflix"
        ],
        "question": "You are optimizing a Spark job that is suffering from data skew. You are joining a large skewed table with a small reference table. Which technique is most effective? ",
        "options": [
            "Salting the key",
            "Increasing the number of executors",
            "Using a larger instance type",
            "Broadcasting the large table"
        ],
        "answer": "Salting the key",
        "explanation": "Salting adds a random prefix to the skewed key to distribute it. Broadcasting is best for Skewed Joins where one table is small.",
        "frequency_score": 6
    },
    {
        "id": 856,
        "topic": "Apache Kafka",
        "companies": [
            "Google",
            "LinkedIn"
        ],
        "question": "What happens if a Kafka Consumer Group has more consumers than partitions in the topic? ",
        "options": [
            "Some consumers will be idle",
            "Throughput increases linearly",
            "Kafka automatically creates more partitions",
            "The extra consumers duplicate the data"
        ],
        "answer": "Some consumers will be idle",
        "explanation": "A partition can be consumed by only one consumer within a group at a time. Extra consumers stay idle.",
        "frequency_score": 6
    },
    {
        "id": 857,
        "topic": "Apache Spark",
        "companies": [
            "Google",
            "Databricks",
            "Amazon"
        ],
        "question": "In Spark, what is the difference between a Transformation and an Action? ",
        "options": [
            "Transformations are lazy, Actions match strict execution",
            "Actions are lazy, Transformations trigger execution",
            "They are the same",
            "Transformations save to disk, Actions read from disk"
        ],
        "answer": "Transformations are lazy, Actions match strict execution",
        "explanation": "Transformations (like map, filter) build the DAG but do not execute. Actions (like count, collect, save) trigger the actual computation.",
        "frequency_score": 6
    },
    {
        "id": 858,
        "topic": "Cloud Spanner",
        "companies": [
            "Google",
            "Uber",
            "Pokemon GO"
        ],
        "question": "You are designing a global banking ledger. You require strong consistency and horizontal scalability. Which database service should you choose? ",
        "options": [
            "Cloud Spanner",
            "Cloud SQL",
            "Bigtable",
            "Firestore"
        ],
        "answer": "Cloud Spanner",
        "explanation": "Cloud Spanner is the only service providing global strong consistency and horizontal scalability with relational semantics (SQL).",
        "frequency_score": 8
    },
    {
        "id": 859,
        "topic": "Apache Spark",
        "companies": [
            "Google",
            "Databricks",
            "Facebook",
            "Netflix"
        ],
        "question": "You are optimizing a Spark job that is suffering from data skew. One task takes 10x longer than others during a wide transformation. Which technique is most effective? ",
        "options": [
            "Salting the key",
            "Increasing the number of executors",
            "Using a larger instance type",
            "Broadcasting the large table"
        ],
        "answer": "Salting the key",
        "explanation": "Salting adds a random prefix to the skewed key to distribute it. Broadcasting is best for Skewed Joins where one table is small.",
        "frequency_score": 6
    },
    {
        "id": 860,
        "topic": "Cloud Spanner",
        "companies": [
            "Google",
            "Uber",
            "Pokemon GO"
        ],
        "question": "You are designing a global banking ledger. You require strong consistency and horizontal scalability. Which database service should you choose? ",
        "options": [
            "Cloud Spanner",
            "Cloud SQL",
            "Bigtable",
            "Firestore"
        ],
        "answer": "Cloud Spanner",
        "explanation": "Cloud Spanner is the only service providing global strong consistency and horizontal scalability with relational semantics (SQL).",
        "frequency_score": 8
    },
    {
        "id": 861,
        "topic": "Cloud Storage",
        "companies": [
            "Google",
            "Snapchat"
        ],
        "question": "You are designing a storage solution for profile pictures. The requirement is access once a year. What storage class should you use? ",
        "options": [
            "Standard",
            "Nearline",
            "Coldline",
            "Archive"
        ],
        "answer": "Archive",
        "explanation": "Standard for hot data. Nearline < 1/month. Coldline < 1/quarter. Archive < 1/year.",
        "frequency_score": 6
    },
    {
        "id": 862,
        "topic": "Apache Kafka",
        "companies": [
            "Google",
            "LinkedIn"
        ],
        "question": "What happens if a Kafka Consumer Group has more consumers than partitions in the topic? ",
        "options": [
            "Some consumers will be idle",
            "Throughput increases linearly",
            "Kafka automatically creates more partitions",
            "The extra consumers duplicate the data"
        ],
        "answer": "Some consumers will be idle",
        "explanation": "A partition can be consumed by only one consumer within a group at a time. Extra consumers stay idle.",
        "frequency_score": 6
    },
    {
        "id": 863,
        "topic": "Dataflow",
        "companies": [
            "Google",
            "Spotify",
            "New York Times"
        ],
        "question": "You are building a streaming pipeline to process server logs. You need to handle rolling averages every minute for the last hour. What windowing strategy is appropriate? ",
        "options": [
            "Fixed Windows",
            "Sliding Windows",
            "Session Windows",
            "Global Windows"
        ],
        "answer": "Sliding Windows",
        "explanation": "Session windows gap-fill based on activity. Sliding windows overlap (e.g. every 5 min show last 1 hour). Fixed windows are tumbling.",
        "frequency_score": 9
    },
    {
        "id": 864,
        "topic": "Apache Spark",
        "companies": [
            "Google",
            "Databricks",
            "Facebook",
            "Netflix"
        ],
        "question": "You are optimizing a Spark job that is suffering from data skew. One task takes 10x longer than others during a wide transformation. Which technique is most effective? ",
        "options": [
            "Salting the key",
            "Increasing the number of executors",
            "Using a larger instance type",
            "Broadcasting the large table"
        ],
        "answer": "Salting the key",
        "explanation": "Salting adds a random prefix to the skewed key to distribute it. Broadcasting is best for Skewed Joins where one table is small.",
        "frequency_score": 6
    },
    {
        "id": 865,
        "topic": "Apache Kafka",
        "companies": [
            "Google",
            "LinkedIn",
            "Uber",
            "Netflix"
        ],
        "question": "You need to ensure strict ordering of messages in Kafka for a specific Transaction ID. How should you configure the producer? ",
        "options": [
            "Use the Transaction ID as the partition key",
            "Use a single partition for the entire topic",
            "Enable idempotent producer",
            "Increase replication factor"
        ],
        "answer": "Use the Transaction ID as the partition key",
        "explanation": "Kafka guarantees ordering WITHIN a partition. Using the Entity ID as the key ensures all messages for that entity go to the same partition.",
        "frequency_score": 6
    },
    {
        "id": 866,
        "topic": "IAM",
        "companies": [
            "Google"
        ],
        "question": "A developer needs to deploy Cloud Functions in a production project. Following the principle of least privilege, which role should you grant? ",
        "options": [
            "Viewer",
            "Editor",
            "Owner",
            "Storage Object Creator"
        ],
        "answer": "Storage Object Creator",
        "explanation": "Always prefer predefined specific roles (like BigQuery Data Viewer, Storage Object Admin) over basic roles (Viewer/Editor/Owner) to ensure least privilege.",
        "frequency_score": 9
    },
    {
        "id": 867,
        "topic": "Apache Spark",
        "companies": [
            "Google",
            "Databricks",
            "Amazon"
        ],
        "question": "In Spark, what is the difference between a Transformation and an Action? ",
        "options": [
            "Transformations are lazy, Actions match strict execution",
            "Actions are lazy, Transformations trigger execution",
            "They are the same",
            "Transformations save to disk, Actions read from disk"
        ],
        "answer": "Transformations are lazy, Actions match strict execution",
        "explanation": "Transformations (like map, filter) build the DAG but do not execute. Actions (like count, collect, save) trigger the actual computation.",
        "frequency_score": 6
    },
    {
        "id": 868,
        "topic": "BigQuery",
        "companies": [
            "Google",
            "Spotify",
            "Twitter"
        ],
        "question": "You need to store 50 TB of audit logs data in BigQuery. The data is accessed rarely (every 6 months). Which storage class fits best to minimize costs?",
        "options": [
            "Active Storage",
            "Long-term Storage",
            "Nearline Storage",
            "Coldline Storage"
        ],
        "answer": "Long-term Storage",
        "explanation": "BigQuery Long-term storage applies automatically after 90 days of no modification, reducing price by ~50%.",
        "frequency_score": 10
    },
    {
        "id": 869,
        "topic": "Cloud Spanner",
        "companies": [
            "Google",
            "Uber",
            "Pokemon GO"
        ],
        "question": "You are designing a global banking ledger. You require strong consistency and horizontal scalability. Which database service should you choose? ",
        "options": [
            "Cloud Spanner",
            "Cloud SQL",
            "Bigtable",
            "Firestore"
        ],
        "answer": "Cloud Spanner",
        "explanation": "Cloud Spanner is the only service providing global strong consistency and horizontal scalability with relational semantics (SQL).",
        "frequency_score": 8
    },
    {
        "id": 870,
        "topic": "Apache Kafka",
        "companies": [
            "Google",
            "LinkedIn"
        ],
        "question": "What happens if a Kafka Consumer Group has more consumers than partitions in the topic? ",
        "options": [
            "Some consumers will be idle",
            "Throughput increases linearly",
            "Kafka automatically creates more partitions",
            "The extra consumers duplicate the data"
        ],
        "answer": "Some consumers will be idle",
        "explanation": "A partition can be consumed by only one consumer within a group at a time. Extra consumers stay idle.",
        "frequency_score": 6
    },
    {
        "id": 871,
        "topic": "Apache Spark",
        "companies": [
            "Google",
            "Databricks",
            "Facebook",
            "Netflix"
        ],
        "question": "You are optimizing a Spark job that is suffering from data skew. You are joining a large skewed table with a small reference table. Which technique is most effective? ",
        "options": [
            "Salting the key",
            "Increasing the number of executors",
            "Using a larger instance type",
            "Broadcasting the large table"
        ],
        "answer": "Salting the key",
        "explanation": "Salting adds a random prefix to the skewed key to distribute it. Broadcasting is best for Skewed Joins where one table is small.",
        "frequency_score": 6
    },
    {
        "id": 872,
        "topic": "Cloud Storage",
        "companies": [
            "Google",
            "Snapchat"
        ],
        "question": "You are designing a storage solution for regulatory archives. The requirement is high frequency access. What storage class should you use? ",
        "options": [
            "Standard",
            "Nearline",
            "Coldline",
            "Archive"
        ],
        "answer": "Standard",
        "explanation": "Standard for hot data. Nearline < 1/month. Coldline < 1/quarter. Archive < 1/year.",
        "frequency_score": 6
    },
    {
        "id": 873,
        "topic": "Apache Kafka",
        "companies": [
            "Google",
            "LinkedIn",
            "Uber",
            "Netflix"
        ],
        "question": "You need to ensure strict ordering of messages in Kafka for a specific User ID. How should you configure the producer? ",
        "options": [
            "Use the User ID as the partition key",
            "Use a single partition for the entire topic",
            "Enable idempotent producer",
            "Increase replication factor"
        ],
        "answer": "Use the User ID as the partition key",
        "explanation": "Kafka guarantees ordering WITHIN a partition. Using the Entity ID as the key ensures all messages for that entity go to the same partition.",
        "frequency_score": 6
    },
    {
        "id": 874,
        "topic": "Apache Spark",
        "companies": [
            "Google",
            "Databricks",
            "Facebook",
            "Netflix"
        ],
        "question": "You are optimizing a Spark job that is suffering from data skew. You are joining a large skewed table with a small reference table. Which technique is most effective? ",
        "options": [
            "Salting the key",
            "Increasing the number of executors",
            "Using a larger instance type",
            "Broadcasting the large table"
        ],
        "answer": "Salting the key",
        "explanation": "Salting adds a random prefix to the skewed key to distribute it. Broadcasting is best for Skewed Joins where one table is small.",
        "frequency_score": 6
    },
    {
        "id": 875,
        "topic": "Apache Kafka",
        "companies": [
            "Google",
            "LinkedIn"
        ],
        "question": "What happens if a Kafka Consumer Group has more consumers than partitions in the topic? ",
        "options": [
            "Some consumers will be idle",
            "Throughput increases linearly",
            "Kafka automatically creates more partitions",
            "The extra consumers duplicate the data"
        ],
        "answer": "Some consumers will be idle",
        "explanation": "A partition can be consumed by only one consumer within a group at a time. Extra consumers stay idle.",
        "frequency_score": 6
    },
    {
        "id": 876,
        "topic": "Algorithms",
        "companies": [
            "Google",
            "Amazon",
            "Microsoft"
        ],
        "question": "What is the time complexity of a Bubble Sort algorithm in the worst case? ",
        "options": [
            "O(n log n)",
            "O(n^2)",
            "O(n)",
            "O(log n)"
        ],
        "answer": "O(n^2)",
        "explanation": "Merge Sort is O(n log n). Quick Sort is O(n^2) in worst case (though avg O(n log n)). Bubble Sort is O(n^2).",
        "frequency_score": 8
    },
    {
        "id": 877,
        "topic": "Apache Spark",
        "companies": [
            "Google",
            "Databricks",
            "Facebook",
            "Netflix"
        ],
        "question": "You are optimizing a Spark job that is suffering from data skew. You are joining a large skewed table with a small reference table. Which technique is most effective? ",
        "options": [
            "Salting the key",
            "Increasing the number of executors",
            "Using a larger instance type",
            "Broadcasting the large table"
        ],
        "answer": "Salting the key",
        "explanation": "Salting adds a random prefix to the skewed key to distribute it. Broadcasting is best for Skewed Joins where one table is small.",
        "frequency_score": 6
    },
    {
        "id": 878,
        "topic": "Bigtable",
        "companies": [
            "Google",
            "Spotify"
        ],
        "question": "You are designing a Bigtable schema for IoT events. Queries will primarily be retrieve most recent events globally. Which row key design is optimal? ",
        "options": [
            "SensorID#Timestamp",
            "Timestamp#SensorID",
            "ReverseTimestamp#SensorID",
            "Random#SensorID"
        ],
        "answer": "ReverseTimestamp#SensorID",
        "explanation": "Avoid starting with timestamp to prevent hotspots. Use EntityID first for entity-lookup queries. Use ReverseTimestamp for 'latest items' queries globally.",
        "frequency_score": 7
    },
    {
        "id": 879,
        "topic": "Data Structures",
        "companies": [
            "Google",
            "Amazon",
            "Microsoft",
            "Facebook"
        ],
        "question": "You need to implement a look-up service that checks if a user ID exists in a set of 1 billion users with O(log n) average time complexity. Which data structure is best? ",
        "options": [
            "Hash Table / HashSet",
            "Binary Search Tree",
            "Linked List",
            "Array"
        ],
        "answer": "Binary Search Tree",
        "explanation": "Hash Tables provide O(1) average case lookup. BST is O(log n).",
        "frequency_score": 8
    },
    {
        "id": 880,
        "topic": "Dataflow",
        "companies": [
            "Google",
            "Spotify",
            "New York Times"
        ],
        "question": "You are building a streaming pipeline to process server logs. You need to handle hourly reporting. What windowing strategy is appropriate? ",
        "options": [
            "Fixed Windows",
            "Sliding Windows",
            "Session Windows",
            "Global Windows"
        ],
        "answer": "Fixed Windows",
        "explanation": "Session windows gap-fill based on activity. Sliding windows overlap (e.g. every 5 min show last 1 hour). Fixed windows are tumbling.",
        "frequency_score": 9
    },
    {
        "id": 881,
        "topic": "Apache Kafka",
        "companies": [
            "Google",
            "LinkedIn",
            "Uber",
            "Netflix"
        ],
        "question": "You need to ensure strict ordering of messages in Kafka for a specific User ID. How should you configure the producer? ",
        "options": [
            "Use the User ID as the partition key",
            "Use a single partition for the entire topic",
            "Enable idempotent producer",
            "Increase replication factor"
        ],
        "answer": "Use the User ID as the partition key",
        "explanation": "Kafka guarantees ordering WITHIN a partition. Using the Entity ID as the key ensures all messages for that entity go to the same partition.",
        "frequency_score": 6
    },
    {
        "id": 882,
        "topic": "Data Structures",
        "companies": [
            "Google",
            "Amazon",
            "Microsoft",
            "Facebook"
        ],
        "question": "You need to implement a look-up service that checks if a user ID exists in a set of 1 billion users with O(1) average time complexity. Which data structure is best? ",
        "options": [
            "Hash Table / HashSet",
            "Binary Search Tree",
            "Linked List",
            "Array"
        ],
        "answer": "Hash Table / HashSet",
        "explanation": "Hash Tables provide O(1) average case lookup. BST is O(log n).",
        "frequency_score": 8
    },
    {
        "id": 883,
        "topic": "Apache Kafka",
        "companies": [
            "Google",
            "LinkedIn",
            "Uber",
            "Netflix"
        ],
        "question": "You need to ensure strict ordering of messages in Kafka for a specific Device ID. How should you configure the producer? ",
        "options": [
            "Use the Device ID as the partition key",
            "Use a single partition for the entire topic",
            "Enable idempotent producer",
            "Increase replication factor"
        ],
        "answer": "Use the Device ID as the partition key",
        "explanation": "Kafka guarantees ordering WITHIN a partition. Using the Entity ID as the key ensures all messages for that entity go to the same partition.",
        "frequency_score": 6
    },
    {
        "id": 884,
        "topic": "Apache Kafka",
        "companies": [
            "Google",
            "LinkedIn"
        ],
        "question": "What happens if a Kafka Consumer Group has more consumers than partitions in the topic? ",
        "options": [
            "Some consumers will be idle",
            "Throughput increases linearly",
            "Kafka automatically creates more partitions",
            "The extra consumers duplicate the data"
        ],
        "answer": "Some consumers will be idle",
        "explanation": "A partition can be consumed by only one consumer within a group at a time. Extra consumers stay idle.",
        "frequency_score": 6
    },
    {
        "id": 885,
        "topic": "Apache Spark",
        "companies": [
            "Google",
            "Databricks",
            "Amazon"
        ],
        "question": "In Spark, what is the difference between a Transformation and an Action? ",
        "options": [
            "Transformations are lazy, Actions match strict execution",
            "Actions are lazy, Transformations trigger execution",
            "They are the same",
            "Transformations save to disk, Actions read from disk"
        ],
        "answer": "Transformations are lazy, Actions match strict execution",
        "explanation": "Transformations (like map, filter) build the DAG but do not execute. Actions (like count, collect, save) trigger the actual computation.",
        "frequency_score": 6
    },
    {
        "id": 886,
        "topic": "Pub/Sub",
        "companies": [
            "Google",
            "Uber"
        ],
        "question": "Your application publishes high throughput messages to Pub/Sub. You observe increased end-to-end latency and growing backlog. What is the most likely cause? ",
        "options": [
            "Subscribers are too slow (backlog)",
            "Publisher quota exceeded",
            "Message size too large",
            "Ordering keys are causing hotspots"
        ],
        "answer": "Subscribers are too slow (backlog)",
        "explanation": "If using ordering keys, high throughput on a single key can limit scalability (1MB/s limit per key). Slow subscribers cause increased backlog.",
        "frequency_score": 7
    },
    {
        "id": 887,
        "topic": "Data Structures",
        "companies": [
            "Google",
            "Amazon",
            "Microsoft",
            "Facebook"
        ],
        "question": "You need to implement a look-up service that checks if a user ID exists in a set of 1 billion users with O(log n) average time complexity. Which data structure is best? ",
        "options": [
            "Hash Table / HashSet",
            "Binary Search Tree",
            "Linked List",
            "Array"
        ],
        "answer": "Binary Search Tree",
        "explanation": "Hash Tables provide O(1) average case lookup. BST is O(log n).",
        "frequency_score": 8
    },
    {
        "id": 888,
        "topic": "Bigtable",
        "companies": [
            "Google",
            "Spotify"
        ],
        "question": "You are designing a Bigtable schema for IoT events. Queries will primarily be retrieve most recent events globally. Which row key design is optimal? ",
        "options": [
            "SensorID#Date",
            "Date#SensorID",
            "ReverseTimestamp#SensorID",
            "Random#SensorID"
        ],
        "answer": "ReverseTimestamp#SensorID",
        "explanation": "Avoid starting with timestamp to prevent hotspots. Use EntityID first for entity-lookup queries. Use ReverseTimestamp for 'latest items' queries globally.",
        "frequency_score": 7
    },
    {
        "id": 889,
        "topic": "Dataflow",
        "companies": [
            "Google",
            "Spotify",
            "New York Times"
        ],
        "question": "You are building a streaming pipeline to process user clickstreams. You need to handle hourly reporting. What windowing strategy is appropriate? ",
        "options": [
            "Fixed Windows",
            "Sliding Windows",
            "Session Windows",
            "Global Windows"
        ],
        "answer": "Fixed Windows",
        "explanation": "Session windows gap-fill based on activity. Sliding windows overlap (e.g. every 5 min show last 1 hour). Fixed windows are tumbling.",
        "frequency_score": 9
    },
    {
        "id": 890,
        "topic": "Apache Spark",
        "companies": [
            "Google",
            "Databricks",
            "Facebook",
            "Netflix"
        ],
        "question": "You are optimizing a Spark job that is suffering from data skew. One task takes 10x longer than others during a wide transformation. Which technique is most effective? ",
        "options": [
            "Salting the key",
            "Increasing the number of executors",
            "Using a larger instance type",
            "Broadcasting the large table"
        ],
        "answer": "Salting the key",
        "explanation": "Salting adds a random prefix to the skewed key to distribute it. Broadcasting is best for Skewed Joins where one table is small.",
        "frequency_score": 6
    },
    {
        "id": 891,
        "topic": "Dataflow",
        "companies": [
            "Google",
            "Spotify",
            "New York Times"
        ],
        "question": "You are building a streaming pipeline to process user clickstreams. You need to handle periods of user activity separated by gaps. What windowing strategy is appropriate? ",
        "options": [
            "Fixed Windows",
            "Sliding Windows",
            "Session Windows",
            "Global Windows"
        ],
        "answer": "Session Windows",
        "explanation": "Session windows gap-fill based on activity. Sliding windows overlap (e.g. every 5 min show last 1 hour). Fixed windows are tumbling.",
        "frequency_score": 9
    },
    {
        "id": 892,
        "topic": "Apache Spark",
        "companies": [
            "Google",
            "Databricks",
            "Amazon"
        ],
        "question": "In Spark, what is the difference between a Transformation and an Action? ",
        "options": [
            "Transformations are lazy, Actions match strict execution",
            "Actions are lazy, Transformations trigger execution",
            "They are the same",
            "Transformations save to disk, Actions read from disk"
        ],
        "answer": "Transformations are lazy, Actions match strict execution",
        "explanation": "Transformations (like map, filter) build the DAG but do not execute. Actions (like count, collect, save) trigger the actual computation.",
        "frequency_score": 6
    },
    {
        "id": 893,
        "topic": "Algorithms",
        "companies": [
            "Google",
            "Amazon",
            "Microsoft"
        ],
        "question": "What is the time complexity of a Bubble Sort algorithm in the worst case? ",
        "options": [
            "O(n log n)",
            "O(n^2)",
            "O(n)",
            "O(log n)"
        ],
        "answer": "O(n^2)",
        "explanation": "Merge Sort is O(n log n). Quick Sort is O(n^2) in worst case (though avg O(n log n)). Bubble Sort is O(n^2).",
        "frequency_score": 8
    },
    {
        "id": 894,
        "topic": "Bigtable",
        "companies": [
            "Google",
            "Spotify"
        ],
        "question": "You are designing a Bigtable schema for financial transactions. Queries will primarily be retrieve latest events for a specific entity. Which row key design is optimal? ",
        "options": [
            "UserID#Date",
            "Date#UserID",
            "ReverseTimestamp#UserID",
            "Random#UserID"
        ],
        "answer": "UserID#Date",
        "explanation": "Avoid starting with timestamp to prevent hotspots. Use EntityID first for entity-lookup queries. Use ReverseTimestamp for 'latest items' queries globally.",
        "frequency_score": 7
    },
    {
        "id": 895,
        "topic": "Apache Spark",
        "companies": [
            "Google",
            "Databricks",
            "Amazon"
        ],
        "question": "In Spark, what is the difference between a Transformation and an Action? ",
        "options": [
            "Transformations are lazy, Actions match strict execution",
            "Actions are lazy, Transformations trigger execution",
            "They are the same",
            "Transformations save to disk, Actions read from disk"
        ],
        "answer": "Transformations are lazy, Actions match strict execution",
        "explanation": "Transformations (like map, filter) build the DAG but do not execute. Actions (like count, collect, save) trigger the actual computation.",
        "frequency_score": 6
    },
    {
        "id": 896,
        "topic": "Apache Kafka",
        "companies": [
            "Google",
            "LinkedIn",
            "Uber",
            "Netflix"
        ],
        "question": "You need to ensure strict ordering of messages in Kafka for a specific User ID. How should you configure the producer? ",
        "options": [
            "Use the User ID as the partition key",
            "Use a single partition for the entire topic",
            "Enable idempotent producer",
            "Increase replication factor"
        ],
        "answer": "Use the User ID as the partition key",
        "explanation": "Kafka guarantees ordering WITHIN a partition. Using the Entity ID as the key ensures all messages for that entity go to the same partition.",
        "frequency_score": 6
    },
    {
        "id": 897,
        "topic": "Apache Kafka",
        "companies": [
            "Google",
            "LinkedIn"
        ],
        "question": "What happens if a Kafka Consumer Group has more consumers than partitions in the topic? ",
        "options": [
            "Some consumers will be idle",
            "Throughput increases linearly",
            "Kafka automatically creates more partitions",
            "The extra consumers duplicate the data"
        ],
        "answer": "Some consumers will be idle",
        "explanation": "A partition can be consumed by only one consumer within a group at a time. Extra consumers stay idle.",
        "frequency_score": 6
    },
    {
        "id": 898,
        "topic": "Cloud Spanner",
        "companies": [
            "Google",
            "Uber",
            "Pokemon GO"
        ],
        "question": "You are designing a global banking ledger. You require strong consistency and horizontal scalability. Which database service should you choose? ",
        "options": [
            "Cloud Spanner",
            "Cloud SQL",
            "Bigtable",
            "Firestore"
        ],
        "answer": "Cloud Spanner",
        "explanation": "Cloud Spanner is the only service providing global strong consistency and horizontal scalability with relational semantics (SQL).",
        "frequency_score": 8
    },
    {
        "id": 899,
        "topic": "Apache Kafka",
        "companies": [
            "Google",
            "LinkedIn",
            "Uber",
            "Netflix"
        ],
        "question": "You need to ensure strict ordering of messages in Kafka for a specific Device ID. How should you configure the producer? ",
        "options": [
            "Use the Device ID as the partition key",
            "Use a single partition for the entire topic",
            "Enable idempotent producer",
            "Increase replication factor"
        ],
        "answer": "Use the Device ID as the partition key",
        "explanation": "Kafka guarantees ordering WITHIN a partition. Using the Entity ID as the key ensures all messages for that entity go to the same partition.",
        "frequency_score": 6
    },
    {
        "id": 900,
        "topic": "Algorithms",
        "companies": [
            "Google",
            "Amazon",
            "Microsoft"
        ],
        "question": "What is the time complexity of a Bubble Sort algorithm in the worst case? ",
        "options": [
            "O(n log n)",
            "O(n^2)",
            "O(n)",
            "O(log n)"
        ],
        "answer": "O(n^2)",
        "explanation": "Merge Sort is O(n log n). Quick Sort is O(n^2) in worst case (though avg O(n log n)). Bubble Sort is O(n^2).",
        "frequency_score": 8
    },
    {
        "id": 901,
        "topic": "Apache Kafka",
        "companies": [
            "Google",
            "LinkedIn"
        ],
        "question": "What happens if a Kafka Consumer Group has more consumers than partitions in the topic? ",
        "options": [
            "Some consumers will be idle",
            "Throughput increases linearly",
            "Kafka automatically creates more partitions",
            "The extra consumers duplicate the data"
        ],
        "answer": "Some consumers will be idle",
        "explanation": "A partition can be consumed by only one consumer within a group at a time. Extra consumers stay idle.",
        "frequency_score": 6
    },
    {
        "id": 902,
        "topic": "Cloud Storage",
        "companies": [
            "Google",
            "Snapchat"
        ],
        "question": "You are designing a storage solution for profile pictures. The requirement is high frequency access. What storage class should you use? ",
        "options": [
            "Standard",
            "Nearline",
            "Coldline",
            "Archive"
        ],
        "answer": "Standard",
        "explanation": "Standard for hot data. Nearline < 1/month. Coldline < 1/quarter. Archive < 1/year.",
        "frequency_score": 6
    },
    {
        "id": 903,
        "topic": "Apache Spark",
        "companies": [
            "Google",
            "Databricks",
            "Amazon"
        ],
        "question": "In Spark, what is the difference between a Transformation and an Action? ",
        "options": [
            "Transformations are lazy, Actions match strict execution",
            "Actions are lazy, Transformations trigger execution",
            "They are the same",
            "Transformations save to disk, Actions read from disk"
        ],
        "answer": "Transformations are lazy, Actions match strict execution",
        "explanation": "Transformations (like map, filter) build the DAG but do not execute. Actions (like count, collect, save) trigger the actual computation.",
        "frequency_score": 6
    },
    {
        "id": 904,
        "topic": "Apache Spark",
        "companies": [
            "Google",
            "Databricks",
            "Facebook",
            "Netflix"
        ],
        "question": "You are optimizing a Spark job that is suffering from data skew. One task takes 10x longer than others during a wide transformation. Which technique is most effective? ",
        "options": [
            "Salting the key",
            "Increasing the number of executors",
            "Using a larger instance type",
            "Broadcasting the large table"
        ],
        "answer": "Salting the key",
        "explanation": "Salting adds a random prefix to the skewed key to distribute it. Broadcasting is best for Skewed Joins where one table is small.",
        "frequency_score": 6
    },
    {
        "id": 905,
        "topic": "Pub/Sub",
        "companies": [
            "Google",
            "Uber"
        ],
        "question": "Your application publishes high throughput messages to Pub/Sub. You observe throughput limits on specific keys. What is the most likely cause? ",
        "options": [
            "Subscribers are too slow (backlog)",
            "Publisher quota exceeded",
            "Message size too large",
            "Ordering keys are causing hotspots"
        ],
        "answer": "Ordering keys are causing hotspots",
        "explanation": "If using ordering keys, high throughput on a single key can limit scalability (1MB/s limit per key). Slow subscribers cause increased backlog.",
        "frequency_score": 7
    },
    {
        "id": 906,
        "topic": "Apache Spark",
        "companies": [
            "Google",
            "Databricks",
            "Facebook",
            "Netflix"
        ],
        "question": "You are optimizing a Spark job that is suffering from data skew. One task takes 10x longer than others during a wide transformation. Which technique is most effective? ",
        "options": [
            "Salting the key",
            "Increasing the number of executors",
            "Using a larger instance type",
            "Broadcasting the large table"
        ],
        "answer": "Salting the key",
        "explanation": "Salting adds a random prefix to the skewed key to distribute it. Broadcasting is best for Skewed Joins where one table is small.",
        "frequency_score": 6
    },
    {
        "id": 907,
        "topic": "Apache Kafka",
        "companies": [
            "Google",
            "LinkedIn"
        ],
        "question": "What happens if a Kafka Consumer Group has more consumers than partitions in the topic? ",
        "options": [
            "Some consumers will be idle",
            "Throughput increases linearly",
            "Kafka automatically creates more partitions",
            "The extra consumers duplicate the data"
        ],
        "answer": "Some consumers will be idle",
        "explanation": "A partition can be consumed by only one consumer within a group at a time. Extra consumers stay idle.",
        "frequency_score": 6
    },
    {
        "id": 908,
        "topic": "Apache Kafka",
        "companies": [
            "Google",
            "LinkedIn"
        ],
        "question": "What happens if a Kafka Consumer Group has more consumers than partitions in the topic? ",
        "options": [
            "Some consumers will be idle",
            "Throughput increases linearly",
            "Kafka automatically creates more partitions",
            "The extra consumers duplicate the data"
        ],
        "answer": "Some consumers will be idle",
        "explanation": "A partition can be consumed by only one consumer within a group at a time. Extra consumers stay idle.",
        "frequency_score": 6
    },
    {
        "id": 909,
        "topic": "Dataflow",
        "companies": [
            "Google",
            "Spotify",
            "New York Times"
        ],
        "question": "You are building a streaming pipeline to process user clickstreams. You need to handle periods of user activity separated by gaps. What windowing strategy is appropriate? ",
        "options": [
            "Fixed Windows",
            "Sliding Windows",
            "Session Windows",
            "Global Windows"
        ],
        "answer": "Session Windows",
        "explanation": "Session windows gap-fill based on activity. Sliding windows overlap (e.g. every 5 min show last 1 hour). Fixed windows are tumbling.",
        "frequency_score": 9
    },
    {
        "id": 910,
        "topic": "BigQuery",
        "companies": [
            "Google",
            "Spotify",
            "Twitter"
        ],
        "question": "You need to store 2 PB of audit logs data in BigQuery. The data is accessed rarely (every 6 months). Which storage class fits best to minimize costs? ",
        "options": [
            "Active Storage",
            "Long-term Storage",
            "Nearline Storage",
            "Coldline Storage"
        ],
        "answer": "Long-term Storage",
        "explanation": "BigQuery Long-term storage applies automatically after 90 days of no modification, reducing price by ~50%.",
        "frequency_score": 10
    },
    {
        "id": 911,
        "topic": "Apache Spark",
        "companies": [
            "Google",
            "Databricks",
            "Facebook",
            "Netflix"
        ],
        "question": "You are optimizing a Spark job that is suffering from data skew. You are joining a large skewed table with a small reference table. Which technique is most effective? ",
        "options": [
            "Salting the key",
            "Increasing the number of executors",
            "Using a larger instance type",
            "Broadcasting the large table"
        ],
        "answer": "Salting the key",
        "explanation": "Salting adds a random prefix to the skewed key to distribute it. Broadcasting is best for Skewed Joins where one table is small.",
        "frequency_score": 6
    },
    {
        "id": 912,
        "topic": "IAM",
        "companies": [
            "Google"
        ],
        "question": "A developer needs to upload files to a bucket in a production project. Following the principle of least privilege, which role should you grant? ",
        "options": [
            "Viewer",
            "Editor",
            "Owner",
            "BigQuery Data Viewer"
        ],
        "answer": "BigQuery Data Viewer",
        "explanation": "Always prefer predefined specific roles (like BigQuery Data Viewer, Storage Object Admin) over basic roles (Viewer/Editor/Owner) to ensure least privilege.",
        "frequency_score": 9
    },
    {
        "id": 913,
        "topic": "Apache Kafka",
        "companies": [
            "Google",
            "LinkedIn"
        ],
        "question": "What happens if a Kafka Consumer Group has more consumers than partitions in the topic? ",
        "options": [
            "Some consumers will be idle",
            "Throughput increases linearly",
            "Kafka automatically creates more partitions",
            "The extra consumers duplicate the data"
        ],
        "answer": "Some consumers will be idle",
        "explanation": "A partition can be consumed by only one consumer within a group at a time. Extra consumers stay idle.",
        "frequency_score": 6
    },
    {
        "id": 914,
        "topic": "Cloud Spanner",
        "companies": [
            "Google",
            "Uber",
            "Pokemon GO"
        ],
        "question": "You are designing a global banking ledger. You require strong consistency and 99.999% availability. Which database service should you choose? ",
        "options": [
            "Cloud Spanner",
            "Cloud SQL",
            "Bigtable",
            "Firestore"
        ],
        "answer": "Cloud Spanner",
        "explanation": "Cloud Spanner is the only service providing global strong consistency and horizontal scalability with relational semantics (SQL).",
        "frequency_score": 8
    },
    {
        "id": 915,
        "topic": "Algorithms",
        "companies": [
            "Google",
            "Amazon",
            "Microsoft"
        ],
        "question": "What is the time complexity of a Merge Sort algorithm in the worst case? ",
        "options": [
            "O(n log n)",
            "O(n^2)",
            "O(n)",
            "O(log n)"
        ],
        "answer": "O(n log n)",
        "explanation": "Merge Sort is O(n log n). Quick Sort is O(n^2) in worst case (though avg O(n log n)). Bubble Sort is O(n^2).",
        "frequency_score": 8
    },
    {
        "id": 916,
        "topic": "Cloud Spanner",
        "companies": [
            "Google",
            "Uber",
            "Pokemon GO"
        ],
        "question": "You are designing a global banking ledger. You require strong consistency and 99.999% availability. Which database service should you choose? ",
        "options": [
            "Cloud Spanner",
            "Cloud SQL",
            "Bigtable",
            "Firestore"
        ],
        "answer": "Cloud Spanner",
        "explanation": "Cloud Spanner is the only service providing global strong consistency and horizontal scalability with relational semantics (SQL).",
        "frequency_score": 8
    },
    {
        "id": 917,
        "topic": "Pub/Sub",
        "companies": [
            "Google",
            "Uber"
        ],
        "question": "Your application publishes 1 million/sec messages to Pub/Sub. You observe throughput limits on specific keys. What is the most likely cause? ",
        "options": [
            "Subscribers are too slow (backlog)",
            "Publisher quota exceeded",
            "Message size too large",
            "Ordering keys are causing hotspots"
        ],
        "answer": "Ordering keys are causing hotspots",
        "explanation": "If using ordering keys, high throughput on a single key can limit scalability (1MB/s limit per key). Slow subscribers cause increased backlog.",
        "frequency_score": 7
    },
    {
        "id": 918,
        "topic": "Cloud Spanner",
        "companies": [
            "Google",
            "Uber",
            "Pokemon GO"
        ],
        "question": "You are designing a global banking ledger. You require strong consistency and 99.999% availability. Which database service should you choose? ",
        "options": [
            "Cloud Spanner",
            "Cloud SQL",
            "Bigtable",
            "Firestore"
        ],
        "answer": "Cloud Spanner",
        "explanation": "Cloud Spanner is the only service providing global strong consistency and horizontal scalability with relational semantics (SQL).",
        "frequency_score": 8
    },
    {
        "id": 919,
        "topic": "Apache Spark",
        "companies": [
            "Google",
            "Databricks",
            "Facebook",
            "Netflix"
        ],
        "question": "You are optimizing a Spark job that is suffering from data skew. You are joining a large skewed table with a small reference table. Which technique is most effective? ",
        "options": [
            "Salting the key",
            "Increasing the number of executors",
            "Using a larger instance type",
            "Broadcasting the large table"
        ],
        "answer": "Salting the key",
        "explanation": "Salting adds a random prefix to the skewed key to distribute it. Broadcasting is best for Skewed Joins where one table is small.",
        "frequency_score": 6
    },
    {
        "id": 920,
        "topic": "BigQuery",
        "companies": [
            "Google",
            "Spotify",
            "Twitter"
        ],
        "question": "You need to store 50 TB of clickstream data data in BigQuery. The data is accessed once a quarter. Which storage class fits best to minimize costs? ",
        "options": [
            "Active Storage",
            "Long-term Storage",
            "Nearline Storage",
            "Coldline Storage"
        ],
        "answer": "Active Storage",
        "explanation": "BigQuery Long-term storage applies automatically after 90 days of no modification, reducing price by ~50%.",
        "frequency_score": 10
    },
    {
        "id": 921,
        "topic": "Apache Kafka",
        "companies": [
            "Google",
            "LinkedIn"
        ],
        "question": "What happens if a Kafka Consumer Group has more consumers than partitions in the topic? ",
        "options": [
            "Some consumers will be idle",
            "Throughput increases linearly",
            "Kafka automatically creates more partitions",
            "The extra consumers duplicate the data"
        ],
        "answer": "Some consumers will be idle",
        "explanation": "A partition can be consumed by only one consumer within a group at a time. Extra consumers stay idle.",
        "frequency_score": 6
    },
    {
        "id": 922,
        "topic": "Apache Kafka",
        "companies": [
            "Google",
            "LinkedIn"
        ],
        "question": "What happens if a Kafka Consumer Group has more consumers than partitions in the topic? ",
        "options": [
            "Some consumers will be idle",
            "Throughput increases linearly",
            "Kafka automatically creates more partitions",
            "The extra consumers duplicate the data"
        ],
        "answer": "Some consumers will be idle",
        "explanation": "A partition can be consumed by only one consumer within a group at a time. Extra consumers stay idle.",
        "frequency_score": 6
    },
    {
        "id": 923,
        "topic": "Dataflow",
        "companies": [
            "Google",
            "Spotify",
            "New York Times"
        ],
        "question": "You are building a streaming pipeline to process IoT temperature sensors. You need to handle periods of user activity separated by gaps. What windowing strategy is appropriate? ",
        "options": [
            "Fixed Windows",
            "Sliding Windows",
            "Session Windows",
            "Global Windows"
        ],
        "answer": "Session Windows",
        "explanation": "Session windows gap-fill based on activity. Sliding windows overlap (e.g. every 5 min show last 1 hour). Fixed windows are tumbling.",
        "frequency_score": 9
    },
    {
        "id": 924,
        "topic": "BigQuery",
        "companies": [
            "Google",
            "Spotify",
            "Twitter"
        ],
        "question": "You need to store 500 TB of sensor metrics data in BigQuery. The data is accessed continuously. Which storage class fits best to minimize costs? ",
        "options": [
            "Active Storage",
            "Long-term Storage",
            "Nearline Storage",
            "Coldline Storage"
        ],
        "answer": "Active Storage",
        "explanation": "BigQuery Long-term storage applies automatically after 90 days of no modification, reducing price by ~50%.",
        "frequency_score": 10
    },
    {
        "id": 925,
        "topic": "IAM",
        "companies": [
            "Google"
        ],
        "question": "A developer needs to deploy Cloud Functions in a production project. Following the principle of least privilege, which role should you grant? ",
        "options": [
            "Viewer",
            "Editor",
            "Owner",
            "Storage Object Creator"
        ],
        "answer": "Storage Object Creator",
        "explanation": "Always prefer predefined specific roles (like BigQuery Data Viewer, Storage Object Admin) over basic roles (Viewer/Editor/Owner) to ensure least privilege.",
        "frequency_score": 9
    },
    {
        "id": 926,
        "topic": "Pub/Sub",
        "companies": [
            "Google",
            "Uber"
        ],
        "question": "Your application publishes 1 million/sec messages to Pub/Sub. You observe throughput limits on specific keys. What is the most likely cause? ",
        "options": [
            "Subscribers are too slow (backlog)",
            "Publisher quota exceeded",
            "Message size too large",
            "Ordering keys are causing hotspots"
        ],
        "answer": "Ordering keys are causing hotspots",
        "explanation": "If using ordering keys, high throughput on a single key can limit scalability (1MB/s limit per key). Slow subscribers cause increased backlog.",
        "frequency_score": 7
    },
    {
        "id": 927,
        "topic": "Bigtable",
        "companies": [
            "Google",
            "Spotify"
        ],
        "question": "You are designing a Bigtable schema for financial transactions. Queries will primarily be retrieve latest events for a specific entity. Which row key design is optimal? ",
        "options": [
            "SensorID#Timestamp",
            "Timestamp#SensorID",
            "ReverseTimestamp#SensorID",
            "Random#SensorID"
        ],
        "answer": "SensorID#Timestamp",
        "explanation": "Avoid starting with timestamp to prevent hotspots. Use EntityID first for entity-lookup queries. Use ReverseTimestamp for 'latest items' queries globally.",
        "frequency_score": 7
    },
    {
        "id": 928,
        "topic": "Apache Spark",
        "companies": [
            "Google",
            "Databricks",
            "Amazon"
        ],
        "question": "In Spark, what is the difference between a Transformation and an Action? ",
        "options": [
            "Transformations are lazy, Actions match strict execution",
            "Actions are lazy, Transformations trigger execution",
            "They are the same",
            "Transformations save to disk, Actions read from disk"
        ],
        "answer": "Transformations are lazy, Actions match strict execution",
        "explanation": "Transformations (like map, filter) build the DAG but do not execute. Actions (like count, collect, save) trigger the actual computation.",
        "frequency_score": 6
    },
    {
        "id": 929,
        "topic": "Apache Spark",
        "companies": [
            "Google",
            "Databricks",
            "Facebook",
            "Netflix"
        ],
        "question": "You are optimizing a Spark job that is suffering from data skew. You are joining a large skewed table with a small reference table. Which technique is most effective? ",
        "options": [
            "Salting the key",
            "Increasing the number of executors",
            "Using a larger instance type",
            "Broadcasting the large table"
        ],
        "answer": "Salting the key",
        "explanation": "Salting adds a random prefix to the skewed key to distribute it. Broadcasting is best for Skewed Joins where one table is small.",
        "frequency_score": 6
    },
    {
        "id": 930,
        "topic": "Pub/Sub",
        "companies": [
            "Google",
            "Uber"
        ],
        "question": "Your application publishes 1 million/sec messages to Pub/Sub. You observe increased end-to-end latency and growing backlog. What is the most likely cause? ",
        "options": [
            "Subscribers are too slow (backlog)",
            "Publisher quota exceeded",
            "Message size too large",
            "Ordering keys are causing hotspots"
        ],
        "answer": "Subscribers are too slow (backlog)",
        "explanation": "If using ordering keys, high throughput on a single key can limit scalability (1MB/s limit per key). Slow subscribers cause increased backlog.",
        "frequency_score": 7
    },
    {
        "id": 931,
        "topic": "Bigtable",
        "companies": [
            "Google",
            "Spotify"
        ],
        "question": "You are designing a Bigtable schema for social media posts. Queries will primarily be retrieve latest events for a specific entity. Which row key design is optimal? ",
        "options": [
            "UserID#Timestamp",
            "Timestamp#UserID",
            "ReverseTimestamp#UserID",
            "Random#UserID"
        ],
        "answer": "UserID#Timestamp",
        "explanation": "Avoid starting with timestamp to prevent hotspots. Use EntityID first for entity-lookup queries. Use ReverseTimestamp for 'latest items' queries globally.",
        "frequency_score": 7
    },
    {
        "id": 932,
        "topic": "Cloud Storage",
        "companies": [
            "Google",
            "Snapchat"
        ],
        "question": "You are designing a storage solution for disaster recovery backups. The requirement is access once a quarter. What storage class should you use? ",
        "options": [
            "Standard",
            "Nearline",
            "Coldline",
            "Archive"
        ],
        "answer": "Coldline",
        "explanation": "Standard for hot data. Nearline < 1/month. Coldline < 1/quarter. Archive < 1/year.",
        "frequency_score": 6
    },
    {
        "id": 933,
        "topic": "BigQuery",
        "companies": [
            "Google",
            "Spotify",
            "Twitter"
        ],
        "question": "You need to store 1 PB of transaction records data in BigQuery. The data is accessed rarely (every 6 months). Which storage class fits best to minimize costs?",
        "options": [
            "Active Storage",
            "Long-term Storage",
            "Nearline Storage",
            "Coldline Storage"
        ],
        "answer": "Long-term Storage",
        "explanation": "BigQuery Long-term storage applies automatically after 90 days of no modification, reducing price by ~50%.",
        "frequency_score": 10
    },
    {
        "id": 934,
        "topic": "Pub/Sub",
        "companies": [
            "Google",
            "Uber"
        ],
        "question": "Your application publishes 1 million/sec messages to Pub/Sub. You observe throughput limits on specific keys. What is the most likely cause? ",
        "options": [
            "Subscribers are too slow (backlog)",
            "Publisher quota exceeded",
            "Message size too large",
            "Ordering keys are causing hotspots"
        ],
        "answer": "Ordering keys are causing hotspots",
        "explanation": "If using ordering keys, high throughput on a single key can limit scalability (1MB/s limit per key). Slow subscribers cause increased backlog.",
        "frequency_score": 7
    },
    {
        "id": 935,
        "topic": "Cloud Storage",
        "companies": [
            "Google",
            "Snapchat"
        ],
        "question": "You are designing a storage solution for daily analytics content. The requirement is access once a year. What storage class should you use? ",
        "options": [
            "Standard",
            "Nearline",
            "Coldline",
            "Archive"
        ],
        "answer": "Archive",
        "explanation": "Standard for hot data. Nearline < 1/month. Coldline < 1/quarter. Archive < 1/year.",
        "frequency_score": 6
    },
    {
        "id": 936,
        "topic": "BigQuery",
        "companies": [
            "Google",
            "Spotify",
            "Twitter"
        ],
        "question": "You need to store 500 TB of transaction records data in BigQuery. The data is accessed continuously. Which storage class fits best to minimize costs?",
        "options": [
            "Active Storage",
            "Long-term Storage",
            "Nearline Storage",
            "Coldline Storage"
        ],
        "answer": "Active Storage",
        "explanation": "BigQuery Long-term storage applies automatically after 90 days of no modification, reducing price by ~50%.",
        "frequency_score": 10
    },
    {
        "id": 937,
        "topic": "BigQuery",
        "companies": [
            "Google",
            "Spotify",
            "Twitter"
        ],
        "question": "You need to store 2 PB of transaction records data in BigQuery. The data is accessed continuously. Which storage class fits best to minimize costs?",
        "options": [
            "Active Storage",
            "Long-term Storage",
            "Nearline Storage",
            "Coldline Storage"
        ],
        "answer": "Active Storage",
        "explanation": "BigQuery Long-term storage applies automatically after 90 days of no modification, reducing price by ~50%.",
        "frequency_score": 10
    },
    {
        "id": 938,
        "topic": "Pub/Sub",
        "companies": [
            "Google",
            "Uber"
        ],
        "question": "Your application publishes high throughput messages to Pub/Sub. You observe increased end-to-end latency and growing backlog. What is the most likely cause? ",
        "options": [
            "Subscribers are too slow (backlog)",
            "Publisher quota exceeded",
            "Message size too large",
            "Ordering keys are causing hotspots"
        ],
        "answer": "Subscribers are too slow (backlog)",
        "explanation": "If using ordering keys, high throughput on a single key can limit scalability (1MB/s limit per key). Slow subscribers cause increased backlog.",
        "frequency_score": 7
    },
    {
        "id": 939,
        "topic": "Algorithms",
        "companies": [
            "Google",
            "Amazon",
            "Microsoft"
        ],
        "question": "What is the time complexity of a Quick Sort algorithm in the worst case? ",
        "options": [
            "O(n log n)",
            "O(n^2)",
            "O(n)",
            "O(log n)"
        ],
        "answer": "O(n^2)",
        "explanation": "Merge Sort is O(n log n). Quick Sort is O(n^2) in worst case (though avg O(n log n)). Bubble Sort is O(n^2).",
        "frequency_score": 8
    },
    {
        "id": 940,
        "topic": "Apache Spark",
        "companies": [
            "Google",
            "Databricks",
            "Amazon"
        ],
        "question": "In Spark, what is the difference between a Transformation and an Action? ",
        "options": [
            "Transformations are lazy, Actions match strict execution",
            "Actions are lazy, Transformations trigger execution",
            "They are the same",
            "Transformations save to disk, Actions read from disk"
        ],
        "answer": "Transformations are lazy, Actions match strict execution",
        "explanation": "Transformations (like map, filter) build the DAG but do not execute. Actions (like count, collect, save) trigger the actual computation.",
        "frequency_score": 6
    },
    {
        "id": 941,
        "topic": "BigQuery",
        "companies": [
            "Google",
            "Spotify",
            "Twitter"
        ],
        "question": "You need to store 500 TB of transaction records data in BigQuery. The data is accessed continuously. Which storage class fits best to minimize costs? ",
        "options": [
            "Active Storage",
            "Long-term Storage",
            "Nearline Storage",
            "Coldline Storage"
        ],
        "answer": "Active Storage",
        "explanation": "BigQuery Long-term storage applies automatically after 90 days of no modification, reducing price by ~50%.",
        "frequency_score": 10
    },
    {
        "id": 942,
        "topic": "Cloud Spanner",
        "companies": [
            "Google",
            "Uber",
            "Pokemon GO"
        ],
        "question": "You are designing a global banking ledger. You require strong consistency and horizontal scalability. Which database service should you choose? ",
        "options": [
            "Cloud Spanner",
            "Cloud SQL",
            "Bigtable",
            "Firestore"
        ],
        "answer": "Cloud Spanner",
        "explanation": "Cloud Spanner is the only service providing global strong consistency and horizontal scalability with relational semantics (SQL).",
        "frequency_score": 8
    },
    {
        "id": 943,
        "topic": "Data Structures",
        "companies": [
            "Google",
            "Amazon",
            "Microsoft",
            "Facebook"
        ],
        "question": "You need to implement a look-up service that checks if a user ID exists in a set of 1 billion users with O(log n) average time complexity. Which data structure is best? ",
        "options": [
            "Hash Table / HashSet",
            "Binary Search Tree",
            "Linked List",
            "Array"
        ],
        "answer": "Binary Search Tree",
        "explanation": "Hash Tables provide O(1) average case lookup. BST is O(log n).",
        "frequency_score": 8
    },
    {
        "id": 944,
        "topic": "Cloud Storage",
        "companies": [
            "Google",
            "Snapchat"
        ],
        "question": "You are designing a storage solution for regulatory archives. The requirement is access once a month. What storage class should you use? ",
        "options": [
            "Standard",
            "Nearline",
            "Coldline",
            "Archive"
        ],
        "answer": "Nearline",
        "explanation": "Standard for hot data. Nearline < 1/month. Coldline < 1/quarter. Archive < 1/year.",
        "frequency_score": 6
    },
    {
        "id": 945,
        "topic": "Bigtable",
        "companies": [
            "Google",
            "Spotify"
        ],
        "question": "You are designing a Bigtable schema for financial transactions. Queries will primarily be retrieve most recent events globally. Which row key design is optimal? ",
        "options": [
            "DeviceID#Timestamp",
            "Timestamp#DeviceID",
            "ReverseTimestamp#DeviceID",
            "Random#DeviceID"
        ],
        "answer": "ReverseTimestamp#DeviceID",
        "explanation": "Avoid starting with timestamp to prevent hotspots. Use EntityID first for entity-lookup queries. Use ReverseTimestamp for 'latest items' queries globally.",
        "frequency_score": 7
    },
    {
        "id": 946,
        "topic": "BigQuery",
        "companies": [
            "Google",
            "Spotify",
            "Twitter"
        ],
        "question": "You need to store 50 TB of transaction records data in BigQuery. The data is accessed rarely (every 6 months). Which storage class fits best to minimize costs? ",
        "options": [
            "Active Storage",
            "Long-term Storage",
            "Nearline Storage",
            "Coldline Storage"
        ],
        "answer": "Long-term Storage",
        "explanation": "BigQuery Long-term storage applies automatically after 90 days of no modification, reducing price by ~50%.",
        "frequency_score": 10
    },
    {
        "id": 947,
        "topic": "Cloud Storage",
        "companies": [
            "Google",
            "Snapchat"
        ],
        "question": "You are designing a storage solution for daily analytics content. The requirement is access once a month. What storage class should you use? ",
        "options": [
            "Standard",
            "Nearline",
            "Coldline",
            "Archive"
        ],
        "answer": "Nearline",
        "explanation": "Standard for hot data. Nearline < 1/month. Coldline < 1/quarter. Archive < 1/year.",
        "frequency_score": 6
    },
    {
        "id": 948,
        "topic": "Apache Kafka",
        "companies": [
            "Google",
            "LinkedIn"
        ],
        "question": "What happens if a Kafka Consumer Group has more consumers than partitions in the topic? ",
        "options": [
            "Some consumers will be idle",
            "Throughput increases linearly",
            "Kafka automatically creates more partitions",
            "The extra consumers duplicate the data"
        ],
        "answer": "Some consumers will be idle",
        "explanation": "A partition can be consumed by only one consumer within a group at a time. Extra consumers stay idle.",
        "frequency_score": 6
    },
    {
        "id": 949,
        "topic": "Cloud Spanner",
        "companies": [
            "Google",
            "Uber",
            "Pokemon GO"
        ],
        "question": "You are designing a global banking ledger. You require strong consistency and 99.999% availability. Which database service should you choose? ",
        "options": [
            "Cloud Spanner",
            "Cloud SQL",
            "Bigtable",
            "Firestore"
        ],
        "answer": "Cloud Spanner",
        "explanation": "Cloud Spanner is the only service providing global strong consistency and horizontal scalability with relational semantics (SQL).",
        "frequency_score": 8
    },
    {
        "id": 950,
        "topic": "Bigtable",
        "companies": [
            "Google",
            "Spotify"
        ],
        "question": "You are designing a Bigtable schema for IoT events. Queries will primarily be retrieve most recent events globally. Which row key design is optimal? ",
        "options": [
            "SensorID#Timestamp",
            "Timestamp#SensorID",
            "ReverseTimestamp#SensorID",
            "Random#SensorID"
        ],
        "answer": "ReverseTimestamp#SensorID",
        "explanation": "Avoid starting with timestamp to prevent hotspots. Use EntityID first for entity-lookup queries. Use ReverseTimestamp for 'latest items' queries globally.",
        "frequency_score": 7
    },
    {
        "id": 951,
        "topic": "Dataflow",
        "companies": [
            "Google",
            "Spotify",
            "New York Times"
        ],
        "question": "You are building a streaming pipeline to process user clickstreams. You need to handle hourly reporting. What windowing strategy is appropriate? ",
        "options": [
            "Fixed Windows",
            "Sliding Windows",
            "Session Windows",
            "Global Windows"
        ],
        "answer": "Fixed Windows",
        "explanation": "Session windows gap-fill based on activity. Sliding windows overlap (e.g. every 5 min show last 1 hour). Fixed windows are tumbling.",
        "frequency_score": 9
    },
    {
        "id": 952,
        "topic": "Bigtable",
        "companies": [
            "Google",
            "Spotify"
        ],
        "question": "You are designing a Bigtable schema for social media posts. Queries will primarily be retrieve most recent events globally. Which row key design is optimal? ",
        "options": [
            "UserID#Date",
            "Date#UserID",
            "ReverseTimestamp#UserID",
            "Random#UserID"
        ],
        "answer": "ReverseTimestamp#UserID",
        "explanation": "Avoid starting with timestamp to prevent hotspots. Use EntityID first for entity-lookup queries. Use ReverseTimestamp for 'latest items' queries globally.",
        "frequency_score": 7
    },
    {
        "id": 953,
        "topic": "Dataflow",
        "companies": [
            "Google",
            "Spotify",
            "New York Times"
        ],
        "question": "You are building a streaming pipeline to process IoT temperature sensors. You need to handle hourly reporting. What windowing strategy is appropriate? ",
        "options": [
            "Fixed Windows",
            "Sliding Windows",
            "Session Windows",
            "Global Windows"
        ],
        "answer": "Fixed Windows",
        "explanation": "Session windows gap-fill based on activity. Sliding windows overlap (e.g. every 5 min show last 1 hour). Fixed windows are tumbling.",
        "frequency_score": 9
    },
    {
        "id": 954,
        "topic": "Apache Kafka",
        "companies": [
            "Google",
            "LinkedIn",
            "Uber",
            "Netflix"
        ],
        "question": "You need to ensure strict ordering of messages in Kafka for a specific Device ID. How should you configure the producer? ",
        "options": [
            "Use the Device ID as the partition key",
            "Use a single partition for the entire topic",
            "Enable idempotent producer",
            "Increase replication factor"
        ],
        "answer": "Use the Device ID as the partition key",
        "explanation": "Kafka guarantees ordering WITHIN a partition. Using the Entity ID as the key ensures all messages for that entity go to the same partition.",
        "frequency_score": 6
    },
    {
        "id": 955,
        "topic": "Bigtable",
        "companies": [
            "Google",
            "Spotify"
        ],
        "question": "You are designing a Bigtable schema for social media posts. Queries will primarily be retrieve latest events for a specific entity. Which row key design is optimal? ",
        "options": [
            "UserID#Date",
            "Date#UserID",
            "ReverseTimestamp#UserID",
            "Random#UserID"
        ],
        "answer": "UserID#Date",
        "explanation": "Avoid starting with timestamp to prevent hotspots. Use EntityID first for entity-lookup queries. Use ReverseTimestamp for 'latest items' queries globally.",
        "frequency_score": 7
    },
    {
        "id": 956,
        "topic": "Apache Kafka",
        "companies": [
            "Google",
            "LinkedIn",
            "Uber",
            "Netflix"
        ],
        "question": "You need to ensure strict ordering of messages in Kafka for a specific User ID. How should you configure the producer? ",
        "options": [
            "Use the User ID as the partition key",
            "Use a single partition for the entire topic",
            "Enable idempotent producer",
            "Increase replication factor"
        ],
        "answer": "Use the User ID as the partition key",
        "explanation": "Kafka guarantees ordering WITHIN a partition. Using the Entity ID as the key ensures all messages for that entity go to the same partition.",
        "frequency_score": 6
    },
    {
        "id": 957,
        "topic": "Algorithms",
        "companies": [
            "Google",
            "Amazon",
            "Microsoft"
        ],
        "question": "What is the time complexity of a Merge Sort algorithm in the worst case? ",
        "options": [
            "O(n log n)",
            "O(n^2)",
            "O(n)",
            "O(log n)"
        ],
        "answer": "O(n log n)",
        "explanation": "Merge Sort is O(n log n). Quick Sort is O(n^2) in worst case (though avg O(n log n)). Bubble Sort is O(n^2).",
        "frequency_score": 8
    },
    {
        "id": 958,
        "topic": "Cloud Spanner",
        "companies": [
            "Google",
            "Uber",
            "Pokemon GO"
        ],
        "question": "You are designing a global banking ledger. You require strong consistency and 99.999% availability. Which database service should you choose? ",
        "options": [
            "Cloud Spanner",
            "Cloud SQL",
            "Bigtable",
            "Firestore"
        ],
        "answer": "Cloud Spanner",
        "explanation": "Cloud Spanner is the only service providing global strong consistency and horizontal scalability with relational semantics (SQL).",
        "frequency_score": 8
    },
    {
        "id": 959,
        "topic": "Apache Kafka",
        "companies": [
            "Google",
            "LinkedIn",
            "Uber",
            "Netflix"
        ],
        "question": "You need to ensure strict ordering of messages in Kafka for a specific Device ID. How should you configure the producer? ",
        "options": [
            "Use the Device ID as the partition key",
            "Use a single partition for the entire topic",
            "Enable idempotent producer",
            "Increase replication factor"
        ],
        "answer": "Use the Device ID as the partition key",
        "explanation": "Kafka guarantees ordering WITHIN a partition. Using the Entity ID as the key ensures all messages for that entity go to the same partition.",
        "frequency_score": 6
    },
    {
        "id": 960,
        "topic": "Apache Spark",
        "companies": [
            "Google",
            "Databricks",
            "Facebook",
            "Netflix"
        ],
        "question": "You are optimizing a Spark job that is suffering from data skew. You are joining a large skewed table with a small reference table. Which technique is most effective? ",
        "options": [
            "Salting the key",
            "Increasing the number of executors",
            "Using a larger instance type",
            "Broadcasting the large table"
        ],
        "answer": "Salting the key",
        "explanation": "Salting adds a random prefix to the skewed key to distribute it. Broadcasting is best for Skewed Joins where one table is small.",
        "frequency_score": 6
    },
    {
        "id": 961,
        "topic": "IAM",
        "companies": [
            "Google"
        ],
        "question": "A developer needs to upload files to a bucket in a production project. Following the principle of least privilege, which role should you grant? ",
        "options": [
            "Viewer",
            "Editor",
            "Owner",
            "Storage Object Creator"
        ],
        "answer": "Storage Object Creator",
        "explanation": "Always prefer predefined specific roles (like BigQuery Data Viewer, Storage Object Admin) over basic roles (Viewer/Editor/Owner) to ensure least privilege.",
        "frequency_score": 9
    },
    {
        "id": 962,
        "topic": "Cloud Storage",
        "companies": [
            "Google",
            "Snapchat"
        ],
        "question": "You are designing a storage solution for disaster recovery backups. The requirement is access once a quarter. What storage class should you use? ",
        "options": [
            "Standard",
            "Nearline",
            "Coldline",
            "Archive"
        ],
        "answer": "Coldline",
        "explanation": "Standard for hot data. Nearline < 1/month. Coldline < 1/quarter. Archive < 1/year.",
        "frequency_score": 6
    },
    {
        "id": 963,
        "topic": "Dataflow",
        "companies": [
            "Google",
            "Spotify",
            "New York Times"
        ],
        "question": "You are building a streaming pipeline to process IoT temperature sensors. You need to handle rolling averages every minute for the last hour. What windowing strategy is appropriate? ",
        "options": [
            "Fixed Windows",
            "Sliding Windows",
            "Session Windows",
            "Global Windows"
        ],
        "answer": "Sliding Windows",
        "explanation": "Session windows gap-fill based on activity. Sliding windows overlap (e.g. every 5 min show last 1 hour). Fixed windows are tumbling.",
        "frequency_score": 9
    },
    {
        "id": 964,
        "topic": "Algorithms",
        "companies": [
            "Google",
            "Amazon",
            "Microsoft"
        ],
        "question": "What is the time complexity of a Quick Sort algorithm in the worst case? ",
        "options": [
            "O(n log n)",
            "O(n^2)",
            "O(n)",
            "O(log n)"
        ],
        "answer": "O(n^2)",
        "explanation": "Merge Sort is O(n log n). Quick Sort is O(n^2) in worst case (though avg O(n log n)). Bubble Sort is O(n^2).",
        "frequency_score": 8
    },
    {
        "id": 965,
        "topic": "Cloud Storage",
        "companies": [
            "Google",
            "Snapchat"
        ],
        "question": "You are designing a storage solution for regulatory archives. The requirement is access once a year. What storage class should you use? ",
        "options": [
            "Standard",
            "Nearline",
            "Coldline",
            "Archive"
        ],
        "answer": "Archive",
        "explanation": "Standard for hot data. Nearline < 1/month. Coldline < 1/quarter. Archive < 1/year.",
        "frequency_score": 6
    },
    {
        "id": 966,
        "topic": "Cloud Spanner",
        "companies": [
            "Google",
            "Uber",
            "Pokemon GO"
        ],
        "question": "You are designing a global banking ledger. You require strong consistency and 99.999% availability. Which database service should you choose? ",
        "options": [
            "Cloud Spanner",
            "Cloud SQL",
            "Bigtable",
            "Firestore"
        ],
        "answer": "Cloud Spanner",
        "explanation": "Cloud Spanner is the only service providing global strong consistency and horizontal scalability with relational semantics (SQL).",
        "frequency_score": 8
    },
    {
        "id": 967,
        "topic": "BigQuery",
        "companies": [
            "Google",
            "Spotify",
            "Twitter"
        ],
        "question": "You need to store 2 PB of clickstream data data in BigQuery. The data is accessed continuously. Which storage class fits best to minimize costs?",
        "options": [
            "Active Storage",
            "Long-term Storage",
            "Nearline Storage",
            "Coldline Storage"
        ],
        "answer": "Active Storage",
        "explanation": "BigQuery Long-term storage applies automatically after 90 days of no modification, reducing price by ~50%.",
        "frequency_score": 10
    },
    {
        "id": 968,
        "topic": "Cloud Spanner",
        "companies": [
            "Google",
            "Uber",
            "Pokemon GO"
        ],
        "question": "You are designing a global banking ledger. You require strong consistency and horizontal scalability. Which database service should you choose? ",
        "options": [
            "Cloud Spanner",
            "Cloud SQL",
            "Bigtable",
            "Firestore"
        ],
        "answer": "Cloud Spanner",
        "explanation": "Cloud Spanner is the only service providing global strong consistency and horizontal scalability with relational semantics (SQL).",
        "frequency_score": 8
    },
    {
        "id": 969,
        "topic": "Apache Kafka",
        "companies": [
            "Google",
            "LinkedIn",
            "Uber",
            "Netflix"
        ],
        "question": "You need to ensure strict ordering of messages in Kafka for a specific Transaction ID. How should you configure the producer? ",
        "options": [
            "Use the Transaction ID as the partition key",
            "Use a single partition for the entire topic",
            "Enable idempotent producer",
            "Increase replication factor"
        ],
        "answer": "Use the Transaction ID as the partition key",
        "explanation": "Kafka guarantees ordering WITHIN a partition. Using the Entity ID as the key ensures all messages for that entity go to the same partition.",
        "frequency_score": 6
    },
    {
        "id": 970,
        "topic": "Data Structures",
        "companies": [
            "Google",
            "Amazon",
            "Microsoft",
            "Facebook"
        ],
        "question": "You need to implement a look-up service that checks if a user ID exists in a set of 1 billion users with O(1) average time complexity. Which data structure is best? ",
        "options": [
            "Hash Table / HashSet",
            "Binary Search Tree",
            "Linked List",
            "Array"
        ],
        "answer": "Hash Table / HashSet",
        "explanation": "Hash Tables provide O(1) average case lookup. BST is O(log n).",
        "frequency_score": 8
    },
    {
        "id": 971,
        "topic": "Data Structures",
        "companies": [
            "Google",
            "Amazon",
            "Microsoft",
            "Facebook"
        ],
        "question": "You need to implement a look-up service that checks if a user ID exists in a set of 1 billion users with O(log n) average time complexity. Which data structure is best? ",
        "options": [
            "Hash Table / HashSet",
            "Binary Search Tree",
            "Linked List",
            "Array"
        ],
        "answer": "Binary Search Tree",
        "explanation": "Hash Tables provide O(1) average case lookup. BST is O(log n).",
        "frequency_score": 8
    },
    {
        "id": 972,
        "topic": "Apache Spark",
        "companies": [
            "Google",
            "Databricks",
            "Amazon"
        ],
        "question": "In Spark, what is the difference between a Transformation and an Action? ",
        "options": [
            "Transformations are lazy, Actions match strict execution",
            "Actions are lazy, Transformations trigger execution",
            "They are the same",
            "Transformations save to disk, Actions read from disk"
        ],
        "answer": "Transformations are lazy, Actions match strict execution",
        "explanation": "Transformations (like map, filter) build the DAG but do not execute. Actions (like count, collect, save) trigger the actual computation.",
        "frequency_score": 6
    },
    {
        "id": 973,
        "topic": "IAM",
        "companies": [
            "Google"
        ],
        "question": "A developer needs to upload files to a bucket in a production project. Following the principle of least privilege, which role should you grant? ",
        "options": [
            "Viewer",
            "Editor",
            "Owner",
            "BigQuery Data Viewer"
        ],
        "answer": "BigQuery Data Viewer",
        "explanation": "Always prefer predefined specific roles (like BigQuery Data Viewer, Storage Object Admin) over basic roles (Viewer/Editor/Owner) to ensure least privilege.",
        "frequency_score": 9
    },
    {
        "id": 974,
        "topic": "BigQuery",
        "companies": [
            "Google",
            "Spotify",
            "Twitter"
        ],
        "question": "You need to store 1 PB of sensor metrics data in BigQuery. The data is accessed daily. Which storage class fits best to minimize costs? ",
        "options": [
            "Active Storage",
            "Long-term Storage",
            "Nearline Storage",
            "Coldline Storage"
        ],
        "answer": "Active Storage",
        "explanation": "BigQuery Long-term storage applies automatically after 90 days of no modification, reducing price by ~50%.",
        "frequency_score": 10
    },
    {
        "id": 975,
        "topic": "Dataflow",
        "companies": [
            "Google",
            "Spotify",
            "New York Times"
        ],
        "question": "You are building a streaming pipeline to process IoT temperature sensors. You need to handle rolling averages every minute for the last hour. What windowing strategy is appropriate? ",
        "options": [
            "Fixed Windows",
            "Sliding Windows",
            "Session Windows",
            "Global Windows"
        ],
        "answer": "Sliding Windows",
        "explanation": "Session windows gap-fill based on activity. Sliding windows overlap (e.g. every 5 min show last 1 hour). Fixed windows are tumbling.",
        "frequency_score": 9
    },
    {
        "id": 976,
        "topic": "Apache Kafka",
        "companies": [
            "Google",
            "LinkedIn",
            "Uber",
            "Netflix"
        ],
        "question": "You need to ensure strict ordering of messages in Kafka for a specific Transaction ID. How should you configure the producer? ",
        "options": [
            "Use the Transaction ID as the partition key",
            "Use a single partition for the entire topic",
            "Enable idempotent producer",
            "Increase replication factor"
        ],
        "answer": "Use the Transaction ID as the partition key",
        "explanation": "Kafka guarantees ordering WITHIN a partition. Using the Entity ID as the key ensures all messages for that entity go to the same partition.",
        "frequency_score": 6
    },
    {
        "id": 977,
        "topic": "Apache Kafka",
        "companies": [
            "Google",
            "LinkedIn"
        ],
        "question": "What happens if a Kafka Consumer Group has more consumers than partitions in the topic? ",
        "options": [
            "Some consumers will be idle",
            "Throughput increases linearly",
            "Kafka automatically creates more partitions",
            "The extra consumers duplicate the data"
        ],
        "answer": "Some consumers will be idle",
        "explanation": "A partition can be consumed by only one consumer within a group at a time. Extra consumers stay idle.",
        "frequency_score": 6
    },
    {
        "id": 978,
        "topic": "Apache Spark",
        "companies": [
            "Google",
            "Databricks",
            "Facebook",
            "Netflix"
        ],
        "question": "You are optimizing a Spark job that is suffering from data skew. You are joining a large skewed table with a small reference table. Which technique is most effective? ",
        "options": [
            "Salting the key",
            "Increasing the number of executors",
            "Using a larger instance type",
            "Broadcasting the large table"
        ],
        "answer": "Salting the key",
        "explanation": "Salting adds a random prefix to the skewed key to distribute it. Broadcasting is best for Skewed Joins where one table is small.",
        "frequency_score": 6
    },
    {
        "id": 979,
        "topic": "Dataflow",
        "companies": [
            "Google",
            "Spotify",
            "New York Times"
        ],
        "question": "You are building a streaming pipeline to process IoT temperature sensors. You need to handle periods of user activity separated by gaps. What windowing strategy is appropriate? ",
        "options": [
            "Fixed Windows",
            "Sliding Windows",
            "Session Windows",
            "Global Windows"
        ],
        "answer": "Session Windows",
        "explanation": "Session windows gap-fill based on activity. Sliding windows overlap (e.g. every 5 min show last 1 hour). Fixed windows are tumbling.",
        "frequency_score": 9
    },
    {
        "id": 980,
        "topic": "Algorithms",
        "companies": [
            "Google",
            "Amazon",
            "Microsoft"
        ],
        "question": "What is the time complexity of a Quick Sort algorithm in the worst case? ",
        "options": [
            "O(n log n)",
            "O(n^2)",
            "O(n)",
            "O(log n)"
        ],
        "answer": "O(n^2)",
        "explanation": "Merge Sort is O(n log n). Quick Sort is O(n^2) in worst case (though avg O(n log n)). Bubble Sort is O(n^2).",
        "frequency_score": 8
    },
    {
        "id": 981,
        "topic": "Algorithms",
        "companies": [
            "Google",
            "Amazon",
            "Microsoft"
        ],
        "question": "What is the time complexity of a Bubble Sort algorithm in the worst case? ",
        "options": [
            "O(n log n)",
            "O(n^2)",
            "O(n)",
            "O(log n)"
        ],
        "answer": "O(n^2)",
        "explanation": "Merge Sort is O(n log n). Quick Sort is O(n^2) in worst case (though avg O(n log n)). Bubble Sort is O(n^2).",
        "frequency_score": 8
    },
    {
        "id": 982,
        "topic": "BigQuery",
        "companies": [
            "Google",
            "Spotify",
            "Twitter"
        ],
        "question": "You need to store 2 PB of clickstream data data in BigQuery. The data is accessed once a quarter. Which storage class fits best to minimize costs?",
        "options": [
            "Active Storage",
            "Long-term Storage",
            "Nearline Storage",
            "Coldline Storage"
        ],
        "answer": "Active Storage",
        "explanation": "BigQuery Long-term storage applies automatically after 90 days of no modification, reducing price by ~50%.",
        "frequency_score": 10
    },
    {
        "id": 983,
        "topic": "IAM",
        "companies": [
            "Google"
        ],
        "question": "A developer needs to view BigQuery datasets in a production project. Following the principle of least privilege, which role should you grant? ",
        "options": [
            "Viewer",
            "Editor",
            "Owner",
            "BigQuery Data Viewer"
        ],
        "answer": "BigQuery Data Viewer",
        "explanation": "Always prefer predefined specific roles (like BigQuery Data Viewer, Storage Object Admin) over basic roles (Viewer/Editor/Owner) to ensure least privilege.",
        "frequency_score": 9
    },
    {
        "id": 984,
        "topic": "Cloud Spanner",
        "companies": [
            "Google",
            "Uber",
            "Pokemon GO"
        ],
        "question": "You are designing a global banking ledger. You require strong consistency and 99.999% availability. Which database service should you choose? ",
        "options": [
            "Cloud Spanner",
            "Cloud SQL",
            "Bigtable",
            "Firestore"
        ],
        "answer": "Cloud Spanner",
        "explanation": "Cloud Spanner is the only service providing global strong consistency and horizontal scalability with relational semantics (SQL).",
        "frequency_score": 8
    },
    {
        "id": 985,
        "topic": "Cloud Storage",
        "companies": [
            "Google",
            "Snapchat"
        ],
        "question": "You are designing a storage solution for regulatory archives. The requirement is access once a year. What storage class should you use? ",
        "options": [
            "Standard",
            "Nearline",
            "Coldline",
            "Archive"
        ],
        "answer": "Archive",
        "explanation": "Standard for hot data. Nearline < 1/month. Coldline < 1/quarter. Archive < 1/year.",
        "frequency_score": 6
    },
    {
        "id": 986,
        "topic": "Apache Kafka",
        "companies": [
            "Google",
            "LinkedIn"
        ],
        "question": "What happens if a Kafka Consumer Group has more consumers than partitions in the topic? ",
        "options": [
            "Some consumers will be idle",
            "Throughput increases linearly",
            "Kafka automatically creates more partitions",
            "The extra consumers duplicate the data"
        ],
        "answer": "Some consumers will be idle",
        "explanation": "A partition can be consumed by only one consumer within a group at a time. Extra consumers stay idle.",
        "frequency_score": 6
    },
    {
        "id": 987,
        "topic": "Algorithms",
        "companies": [
            "Google",
            "Amazon",
            "Microsoft"
        ],
        "question": "What is the time complexity of a Bubble Sort algorithm in the worst case? ",
        "options": [
            "O(n log n)",
            "O(n^2)",
            "O(n)",
            "O(log n)"
        ],
        "answer": "O(n^2)",
        "explanation": "Merge Sort is O(n log n). Quick Sort is O(n^2) in worst case (though avg O(n log n)). Bubble Sort is O(n^2).",
        "frequency_score": 8
    },
    {
        "id": 988,
        "topic": "Apache Spark",
        "companies": [
            "Google",
            "Databricks",
            "Amazon"
        ],
        "question": "In Spark, what is the difference between a Transformation and an Action? ",
        "options": [
            "Transformations are lazy, Actions match strict execution",
            "Actions are lazy, Transformations trigger execution",
            "They are the same",
            "Transformations save to disk, Actions read from disk"
        ],
        "answer": "Transformations are lazy, Actions match strict execution",
        "explanation": "Transformations (like map, filter) build the DAG but do not execute. Actions (like count, collect, save) trigger the actual computation.",
        "frequency_score": 6
    },
    {
        "id": 989,
        "topic": "Algorithms",
        "companies": [
            "Google",
            "Amazon",
            "Microsoft"
        ],
        "question": "What is the time complexity of a Quick Sort algorithm in the worst case? ",
        "options": [
            "O(n log n)",
            "O(n^2)",
            "O(n)",
            "O(log n)"
        ],
        "answer": "O(n^2)",
        "explanation": "Merge Sort is O(n log n). Quick Sort is O(n^2) in worst case (though avg O(n log n)). Bubble Sort is O(n^2).",
        "frequency_score": 8
    },
    {
        "id": 990,
        "topic": "Cloud Spanner",
        "companies": [
            "Google",
            "Uber",
            "Pokemon GO"
        ],
        "question": "You are designing a global banking ledger. You require strong consistency and 99.999% availability. Which database service should you choose? ",
        "options": [
            "Cloud Spanner",
            "Cloud SQL",
            "Bigtable",
            "Firestore"
        ],
        "answer": "Cloud Spanner",
        "explanation": "Cloud Spanner is the only service providing global strong consistency and horizontal scalability with relational semantics (SQL).",
        "frequency_score": 8
    },
    {
        "id": 991,
        "topic": "Bigtable",
        "companies": [
            "Google",
            "Spotify"
        ],
        "question": "You are designing a Bigtable schema for IoT events. Queries will primarily be retrieve latest events for a specific entity. Which row key design is optimal? ",
        "options": [
            "DeviceID#Date",
            "Date#DeviceID",
            "ReverseTimestamp#DeviceID",
            "Random#DeviceID"
        ],
        "answer": "DeviceID#Date",
        "explanation": "Avoid starting with timestamp to prevent hotspots. Use EntityID first for entity-lookup queries. Use ReverseTimestamp for 'latest items' queries globally.",
        "frequency_score": 7
    },
    {
        "id": 992,
        "topic": "Cloud Storage",
        "companies": [
            "Google",
            "Snapchat"
        ],
        "question": "You are designing a storage solution for regulatory archives. The requirement is access once a month. What storage class should you use? ",
        "options": [
            "Standard",
            "Nearline",
            "Coldline",
            "Archive"
        ],
        "answer": "Nearline",
        "explanation": "Standard for hot data. Nearline < 1/month. Coldline < 1/quarter. Archive < 1/year.",
        "frequency_score": 6
    },
    {
        "id": 993,
        "topic": "Cloud Storage",
        "companies": [
            "Google",
            "Snapchat"
        ],
        "question": "You are designing a storage solution for regulatory archives. The requirement is access once a month. What storage class should you use? ",
        "options": [
            "Standard",
            "Nearline",
            "Coldline",
            "Archive"
        ],
        "answer": "Nearline",
        "explanation": "Standard for hot data. Nearline < 1/month. Coldline < 1/quarter. Archive < 1/year.",
        "frequency_score": 6
    },
    {
        "id": 994,
        "topic": "BigQuery",
        "companies": [
            "Google",
            "Spotify",
            "Twitter"
        ],
        "question": "You need to store 50 TB of transaction records data in BigQuery. The data is accessed daily. Which storage class fits best to minimize costs? ",
        "options": [
            "Active Storage",
            "Long-term Storage",
            "Nearline Storage",
            "Coldline Storage"
        ],
        "answer": "Active Storage",
        "explanation": "BigQuery Long-term storage applies automatically after 90 days of no modification, reducing price by ~50%.",
        "frequency_score": 10
    },
    {
        "id": 995,
        "topic": "Apache Kafka",
        "companies": [
            "Google",
            "LinkedIn",
            "Uber",
            "Netflix"
        ],
        "question": "You need to ensure strict ordering of messages in Kafka for a specific Transaction ID. How should you configure the producer? ",
        "options": [
            "Use the Transaction ID as the partition key",
            "Use a single partition for the entire topic",
            "Enable idempotent producer",
            "Increase replication factor"
        ],
        "answer": "Use the Transaction ID as the partition key",
        "explanation": "Kafka guarantees ordering WITHIN a partition. Using the Entity ID as the key ensures all messages for that entity go to the same partition.",
        "frequency_score": 6
    },
    {
        "id": 996,
        "topic": "BigQuery",
        "companies": [
            "Google",
            "Spotify",
            "Twitter"
        ],
        "question": "You need to store 1 PB of clickstream data data in BigQuery. The data is accessed once a quarter. Which storage class fits best to minimize costs?",
        "options": [
            "Active Storage",
            "Long-term Storage",
            "Nearline Storage",
            "Coldline Storage"
        ],
        "answer": "Active Storage",
        "explanation": "BigQuery Long-term storage applies automatically after 90 days of no modification, reducing price by ~50%.",
        "frequency_score": 10
    },
    {
        "id": 997,
        "topic": "Data Structures",
        "companies": [
            "Google",
            "Amazon",
            "Microsoft",
            "Facebook"
        ],
        "question": "You need to implement a look-up service that checks if a user ID exists in a set of 1 billion users with O(1) average time complexity. Which data structure is best? ",
        "options": [
            "Hash Table / HashSet",
            "Binary Search Tree",
            "Linked List",
            "Array"
        ],
        "answer": "Hash Table / HashSet",
        "explanation": "Hash Tables provide O(1) average case lookup. BST is O(log n).",
        "frequency_score": 8
    },
    {
        "id": 998,
        "topic": "Apache Kafka",
        "companies": [
            "Google",
            "LinkedIn"
        ],
        "question": "What happens if a Kafka Consumer Group has more consumers than partitions in the topic? ",
        "options": [
            "Some consumers will be idle",
            "Throughput increases linearly",
            "Kafka automatically creates more partitions",
            "The extra consumers duplicate the data"
        ],
        "answer": "Some consumers will be idle",
        "explanation": "A partition can be consumed by only one consumer within a group at a time. Extra consumers stay idle.",
        "frequency_score": 6
    },
    {
        "id": 999,
        "topic": "Cloud Storage",
        "companies": [
            "Google",
            "Snapchat"
        ],
        "question": "You are designing a storage solution for disaster recovery backups. The requirement is access once a year. What storage class should you use? ",
        "options": [
            "Standard",
            "Nearline",
            "Coldline",
            "Archive"
        ],
        "answer": "Archive",
        "explanation": "Standard for hot data. Nearline < 1/month. Coldline < 1/quarter. Archive < 1/year.",
        "frequency_score": 6
    },
    {
        "id": 1000,
        "topic": "Apache Kafka",
        "companies": [
            "Google",
            "LinkedIn"
        ],
        "question": "What happens if a Kafka Consumer Group has more consumers than partitions in the topic? ",
        "options": [
            "Some consumers will be idle",
            "Throughput increases linearly",
            "Kafka automatically creates more partitions",
            "The extra consumers duplicate the data"
        ],
        "answer": "Some consumers will be idle",
        "explanation": "A partition can be consumed by only one consumer within a group at a time. Extra consumers stay idle.",
        "frequency_score": 6
    },
    {
        "id": 1001,
        "topic": "Data Structures",
        "companies": [
            "Google",
            "Amazon",
            "Microsoft",
            "Facebook"
        ],
        "question": "You need to implement a look-up service that checks if a user ID exists in a set of 1 billion users with O(log n) average time complexity. Which data structure is best? ",
        "options": [
            "Hash Table / HashSet",
            "Binary Search Tree",
            "Linked List",
            "Array"
        ],
        "answer": "Binary Search Tree",
        "explanation": "Hash Tables provide O(1) average case lookup. BST is O(log n).",
        "frequency_score": 8
    },
    {
        "id": 1002,
        "topic": "Algorithms",
        "companies": [
            "Google",
            "Amazon",
            "Microsoft"
        ],
        "question": "What is the time complexity of a Bubble Sort algorithm in the worst case? ",
        "options": [
            "O(n log n)",
            "O(n^2)",
            "O(n)",
            "O(log n)"
        ],
        "answer": "O(n^2)",
        "explanation": "Merge Sort is O(n log n). Quick Sort is O(n^2) in worst case (though avg O(n log n)). Bubble Sort is O(n^2).",
        "frequency_score": 8
    },
    {
        "id": 1003,
        "topic": "Distributed Systems",
        "companies": [
            "Google",
            "Uber"
        ],
        "question": "You need to update data across two separate microservices (e.g., Payment and Order) transactionally. Traditional 2PC (Two-Phase Commit) is too slow/blocking. What is the modern alternative?",
        "options": [
            "Saga Pattern",
            "3PC",
            "Write-Ahead Logging",
            "Stored Procedures"
        ],
        "answer": "Saga Pattern",
        "explanation": "The Saga pattern manages distributed transactions as a sequence of local transactions, with compensating actions (undo operations) to handle failures without long locks.",
        "frequency_score": 9
    },
    {
        "id": 1004,
        "topic": "Apache Kafka",
        "companies": [
            "Google",
            "LinkedIn"
        ],
        "question": "What happens if a Kafka Consumer Group has more consumers than partitions in the topic? ",
        "options": [
            "Some consumers will be idle",
            "Throughput increases linearly",
            "Kafka automatically creates more partitions",
            "The extra consumers duplicate the data"
        ],
        "answer": "Some consumers will be idle",
        "explanation": "A partition can be consumed by only one consumer within a group at a time. Extra consumers stay idle.",
        "frequency_score": 6
    },
    {
        "id": 1005,
        "topic": "System Design",
        "companies": [
            "Google",
            "Discord"
        ],
        "question": "You need to distribute a massive dataset across 1000 nodes. Nodes frequently join and leave. Which partitioning strategy minimizes data movement when the cluster resizes?",
        "options": [
            "Consistent Hashing",
            "Round-Robin Partitioning",
            "Range Partitioning",
            "Modulo Hashing (Key % N)"
        ],
        "answer": "Consistent Hashing",
        "explanation": "Consistent Hashing maps both data and nodes to a ring. When a node is added/removed, only 1/k keys need to be remapped (neighbors), vs nearly all keys with Modulo Hashing.",
        "frequency_score": 10
    },
    {
        "id": 1006,
        "topic": "System Design",
        "companies": [
            "Google",
            "YouTube",
            "TikTok"
        ],
        "question": "You are building a video recommendation engine. The 'Candidate Generation' phase filters millions of videos down to hundreds. Which approach is valid for this phase?",
        "options": [
            "Collaborative Filtering / Two-Tower Neural Network",
            "Heavy learning-to-rank model",
            "A/B Testing",
            "Linear Regression"
        ],
        "answer": "Collaborative Filtering / Two-Tower Neural Network",
        "explanation": "Candidate generation must be fast and lightweight (high recall). Complex ranking models (high precision) are used only on the smaller subset of candidates.",
        "frequency_score": 10
    },
    {
        "id": 1007,
        "topic": "BigQuery",
        "companies": [
            "Google",
            "Spotify",
            "Twitter"
        ],
        "question": "You need to store 500 TB of transaction records data in BigQuery. The data is accessed once a quarter. Which storage class fits best to minimize costs? ",
        "options": [
            "Active Storage",
            "Long-term Storage",
            "Nearline Storage",
            "Coldline Storage"
        ],
        "answer": "Active Storage",
        "explanation": "BigQuery Long-term storage applies automatically after 90 days of no modification, reducing price by ~50%.",
        "frequency_score": 10
    },
    {
        "id": 1008,
        "topic": "System Design",
        "companies": [
            "Google",
            "Pinterest"
        ],
        "question": "You are designing a predictive search engine (like Google Search Autocomplete). You need sub-100ms latency for prefix lookups on billions of queries. Which data structure is optimal?",
        "options": [
            "Trie (Prefix Tree) stored in memory",
            "B-Tree on disk",
            "Bloom Filter",
            "Inverted Index"
        ],
        "answer": "Trie (Prefix Tree) stored in memory",
        "explanation": "Tries are optimized for prefix lookups. Storing the top variations in memory (or using a distributed cache like Redis) ensures low latency.",
        "frequency_score": 10
    },
    {
        "id": 1009,
        "topic": "BigQuery",
        "companies": [
            "Google",
            "Spotify",
            "Twitter"
        ],
        "question": "You need to store 500 TB of transaction records data in BigQuery. The data is accessed rarely (every 6 months). Which storage class fits best to minimize costs? ",
        "options": [
            "Active Storage",
            "Long-term Storage",
            "Nearline Storage",
            "Coldline Storage"
        ],
        "answer": "Long-term Storage",
        "explanation": "BigQuery Long-term storage applies automatically after 90 days of no modification, reducing price by ~50%.",
        "frequency_score": 10
    },
    {
        "id": 1010,
        "topic": "Data Quality",
        "companies": [
            "Google",
            "Netflix",
            "Airbnb"
        ],
        "question": "You use the 'Write-Audit-Publish' (WAP) pattern for data quality. Where does the data go immediately after transformation but BEFORE it is visible to users?",
        "options": [
            "A hidden 'stage' partition or snapshot",
            "The production table directly",
            "A temporary CSV file",
            "The Dead Letter Queue"
        ],
        "answer": "A hidden 'stage' partition or snapshot",
        "explanation": "In WAP, data is written to a staging area. Audits (queries) run against this area. If pass, the partition is swapped/published to production atomically.",
        "frequency_score": 8
    },
    {
        "id": 1011,
        "topic": "Dataflow",
        "companies": [
            "Google",
            "Spotify",
            "New York Times"
        ],
        "question": "You are building a streaming pipeline to process user clickstreams. You need to handle rolling averages every minute for the last hour. What windowing strategy is appropriate? ",
        "options": [
            "Fixed Windows",
            "Sliding Windows",
            "Session Windows",
            "Global Windows"
        ],
        "answer": "Sliding Windows",
        "explanation": "Session windows gap-fill based on activity. Sliding windows overlap (e.g. every 5 min show last 1 hour). Fixed windows are tumbling.",
        "frequency_score": 9
    },
    {
        "id": 1012,
        "topic": "Bigtable",
        "companies": [
            "Google",
            "Spotify"
        ],
        "question": "You are designing a Bigtable schema for social media posts. Queries will primarily be retrieve most recent events globally. Which row key design is optimal? ",
        "options": [
            "UserID#Timestamp",
            "Timestamp#UserID",
            "ReverseTimestamp#UserID",
            "Random#UserID"
        ],
        "answer": "ReverseTimestamp#UserID",
        "explanation": "Avoid starting with timestamp to prevent hotspots. Use EntityID first for entity-lookup queries. Use ReverseTimestamp for 'latest items' queries globally.",
        "frequency_score": 7
    },
    {
        "id": 1013,
        "topic": "Distributed Systems",
        "companies": [
            "Google",
            "Uber"
        ],
        "question": "You need to update data across two separate microservices (e.g., Payment and Order) transactionally. Traditional 2PC (Two-Phase Commit) is too slow/blocking. What is the modern alternative? ",
        "options": [
            "Saga Pattern",
            "3PC",
            "Write-Ahead Logging",
            "Stored Procedures"
        ],
        "answer": "Saga Pattern",
        "explanation": "The Saga pattern manages distributed transactions as a sequence of local transactions, with compensating actions (undo operations) to handle failures without long locks.",
        "frequency_score": 9
    },
    {
        "id": 1014,
        "topic": "Distributed Systems",
        "companies": [
            "Google",
            "Facebook",
            "Amazon"
        ],
        "question": "You are designing a distributed counter. You need strict consistency (Linearizability) so every read returns the latest write. What is the trade-off according to the CAP theorem?",
        "options": [
            "Availability must be sacrificed during partitions",
            "Partition Tolerance can be ignored",
            "Latency will decrease",
            "Consistency is free"
        ],
        "answer": "Availability must be sacrificed during partitions",
        "explanation": "In a CP (Consistent + Partition Tolerant) system, if a partition occurs, the system must refuse requests (unavailable) to ensure it doesn't return stale data.",
        "frequency_score": 9
    },
    {
        "id": 1015,
        "topic": "Apache Spark",
        "companies": [
            "Google",
            "Databricks",
            "Facebook",
            "Netflix"
        ],
        "question": "You are optimizing a Spark job that is suffering from data skew. You are joining a large skewed table with a small reference table. Which technique is most effective? ",
        "options": [
            "Salting the key",
            "Increasing the number of executors",
            "Using a larger instance type",
            "Broadcasting the large table"
        ],
        "answer": "Salting the key",
        "explanation": "Salting adds a random prefix to the skewed key to distribute it. Broadcasting is best for Skewed Joins where one table is small.",
        "frequency_score": 6
    },
    {
        "id": 1016,
        "topic": "Apache Spark",
        "companies": [
            "Google",
            "Databricks",
            "Facebook",
            "Netflix"
        ],
        "question": "You are optimizing a Spark job that is suffering from data skew. One task takes 10x longer than others during a wide transformation. Which technique is most effective? ",
        "options": [
            "Salting the key",
            "Increasing the number of executors",
            "Using a larger instance type",
            "Broadcasting the large table"
        ],
        "answer": "Salting the key",
        "explanation": "Salting adds a random prefix to the skewed key to distribute it. Broadcasting is best for Skewed Joins where one table is small.",
        "frequency_score": 6
    },
    {
        "id": 1017,
        "topic": "Distributed Systems",
        "companies": [
            "Google",
            "Uber"
        ],
        "question": "You need to update data across two separate microservices (e.g., Payment and Order) transactionally. Traditional 2PC (Two-Phase Commit) is too slow/blocking. What is the modern alternative? ",
        "options": [
            "Saga Pattern",
            "3PC",
            "Write-Ahead Logging",
            "Stored Procedures"
        ],
        "answer": "Saga Pattern",
        "explanation": "The Saga pattern manages distributed transactions as a sequence of local transactions, with compensating actions (undo operations) to handle failures without long locks.",
        "frequency_score": 9
    },
    {
        "id": 1018,
        "topic": "Cloud Storage",
        "companies": [
            "Google",
            "Snapchat"
        ],
        "question": "You are designing a storage solution for disaster recovery backups. The requirement is high frequency access. What storage class should you use? ",
        "options": [
            "Standard",
            "Nearline",
            "Coldline",
            "Archive"
        ],
        "answer": "Standard",
        "explanation": "Standard for hot data. Nearline < 1/month. Coldline < 1/quarter. Archive < 1/year.",
        "frequency_score": 6
    },
    {
        "id": 1019,
        "topic": "Bigtable",
        "companies": [
            "Google",
            "Spotify"
        ],
        "question": "You are designing a Bigtable schema for social media posts. Queries will primarily be retrieve most recent events globally. Which row key design is optimal? ",
        "options": [
            "SensorID#Date",
            "Date#SensorID",
            "ReverseTimestamp#SensorID",
            "Random#SensorID"
        ],
        "answer": "ReverseTimestamp#SensorID",
        "explanation": "Avoid starting with timestamp to prevent hotspots. Use EntityID first for entity-lookup queries. Use ReverseTimestamp for 'latest items' queries globally.",
        "frequency_score": 7
    },
    {
        "id": 1020,
        "topic": "System Design",
        "companies": [
            "Google",
            "Discord"
        ],
        "question": "You need to distribute a massive dataset across 1000 nodes. Nodes frequently join and leave. Which partitioning strategy minimizes data movement when the cluster resizes? ",
        "options": [
            "Consistent Hashing",
            "Round-Robin Partitioning",
            "Range Partitioning",
            "Modulo Hashing (Key % N)"
        ],
        "answer": "Consistent Hashing",
        "explanation": "Consistent Hashing maps both data and nodes to a ring. When a node is added/removed, only 1/k keys need to be remapped (neighbors), vs nearly all keys with Modulo Hashing.",
        "frequency_score": 10
    },
    {
        "id": 1021,
        "topic": "Bigtable",
        "companies": [
            "Google",
            "Spotify"
        ],
        "question": "You are designing a Bigtable schema for financial transactions. Queries will primarily be retrieve latest events for a specific entity. Which row key design is optimal? ",
        "options": [
            "SensorID#Date",
            "Date#SensorID",
            "ReverseTimestamp#SensorID",
            "Random#SensorID"
        ],
        "answer": "SensorID#Date",
        "explanation": "Avoid starting with timestamp to prevent hotspots. Use EntityID first for entity-lookup queries. Use ReverseTimestamp for 'latest items' queries globally.",
        "frequency_score": 7
    },
    {
        "id": 1022,
        "topic": "Distributed Systems",
        "companies": [
            "Google",
            "LinkedIn"
        ],
        "question": "Which replication strategy allows multiple nodes to accept writes, increasing write throughput but introducing potential update conflicts?",
        "options": [
            "Multi-Leader (Master-Master) Replication",
            "Single-Leader Replication",
            "Leaderless Replication (Dynamo-style)",
            "Read Replicas only"
        ],
        "answer": "Multi-Leader (Master-Master) Replication",
        "explanation": "Multi-Leader replication allows writes at multiple datacenters/nodes. It improves performance and local availability but requires conflict resolution logic (e.g., Last Write Wins).",
        "frequency_score": 9
    },
    {
        "id": 1023,
        "topic": "Dataflow",
        "companies": [
            "Google",
            "Spotify",
            "New York Times"
        ],
        "question": "You are building a streaming pipeline to process IoT temperature sensors. You need to handle hourly reporting. What windowing strategy is appropriate? ",
        "options": [
            "Fixed Windows",
            "Sliding Windows",
            "Session Windows",
            "Global Windows"
        ],
        "answer": "Fixed Windows",
        "explanation": "Session windows gap-fill based on activity. Sliding windows overlap (e.g. every 5 min show last 1 hour). Fixed windows are tumbling.",
        "frequency_score": 9
    },
    {
        "id": 1024,
        "topic": "Bigtable",
        "companies": [
            "Google",
            "Spotify"
        ],
        "question": "You are designing a Bigtable schema for social media posts. Queries will primarily be retrieve most recent events globally. Which row key design is optimal? ",
        "options": [
            "DeviceID#Date",
            "Date#DeviceID",
            "ReverseTimestamp#DeviceID",
            "Random#DeviceID"
        ],
        "answer": "ReverseTimestamp#DeviceID",
        "explanation": "Avoid starting with timestamp to prevent hotspots. Use EntityID first for entity-lookup queries. Use ReverseTimestamp for 'latest items' queries globally.",
        "frequency_score": 7
    },
    {
        "id": 1025,
        "topic": "System Design",
        "companies": [
            "Google",
            "Pinterest"
        ],
        "question": "You are designing a predictive search engine (like Google Search Autocomplete). You need sub-100ms latency for prefix lookups on billions of queries. Which data structure is optimal? ",
        "options": [
            "Trie (Prefix Tree) stored in memory",
            "B-Tree on disk",
            "Bloom Filter",
            "Inverted Index"
        ],
        "answer": "Trie (Prefix Tree) stored in memory",
        "explanation": "Tries are optimized for prefix lookups. Storing the top variations in memory (or using a distributed cache like Redis) ensures low latency.",
        "frequency_score": 10
    },
    {
        "id": 1026,
        "topic": "Apache Spark",
        "companies": [
            "Google",
            "Databricks",
            "Amazon"
        ],
        "question": "In Spark, what is the difference between a Transformation and an Action? ",
        "options": [
            "Transformations are lazy, Actions match strict execution",
            "Actions are lazy, Transformations trigger execution",
            "They are the same",
            "Transformations save to disk, Actions read from disk"
        ],
        "answer": "Transformations are lazy, Actions match strict execution",
        "explanation": "Transformations (like map, filter) build the DAG but do not execute. Actions (like count, collect, save) trigger the actual computation.",
        "frequency_score": 6
    },
    {
        "id": 1027,
        "topic": "Apache Kafka",
        "companies": [
            "Google",
            "LinkedIn",
            "Uber",
            "Netflix"
        ],
        "question": "You need to ensure strict ordering of messages in Kafka for a specific User ID. How should you configure the producer? ",
        "options": [
            "Use the User ID as the partition key",
            "Use a single partition for the entire topic",
            "Enable idempotent producer",
            "Increase replication factor"
        ],
        "answer": "Use the User ID as the partition key",
        "explanation": "Kafka guarantees ordering WITHIN a partition. Using the Entity ID as the key ensures all messages for that entity go to the same partition.",
        "frequency_score": 6
    },
    {
        "id": 1028,
        "topic": "Cloud Storage",
        "companies": [
            "Google",
            "Snapchat"
        ],
        "question": "You are designing a storage solution for regulatory archives. The requirement is high frequency access. What storage class should you use? ",
        "options": [
            "Standard",
            "Nearline",
            "Coldline",
            "Archive"
        ],
        "answer": "Standard",
        "explanation": "Standard for hot data. Nearline < 1/month. Coldline < 1/quarter. Archive < 1/year.",
        "frequency_score": 6
    },
    {
        "id": 1029,
        "topic": "Cloud Storage",
        "companies": [
            "Google",
            "Snapchat"
        ],
        "question": "You are designing a storage solution for daily analytics content. The requirement is high frequency access. What storage class should you use? ",
        "options": [
            "Standard",
            "Nearline",
            "Coldline",
            "Archive"
        ],
        "answer": "Standard",
        "explanation": "Standard for hot data. Nearline < 1/month. Coldline < 1/quarter. Archive < 1/year.",
        "frequency_score": 6
    },
    {
        "id": 1030,
        "topic": "System Design",
        "companies": [
            "Google"
        ],
        "question": "You need to store unstructured images and videos for ML training, but also need rich metadata (tags, unexpected attributes) for querying. What architecture fits?",
        "options": [
            "Object Store (GCS) for blobs + NoSQL (Firestore) for metadata",
            "BigQuery for everything",
            "Bigtable for blobs",
            "MySQL for everything"
        ],
        "answer": "Object Store (GCS) for blobs + NoSQL (Firestore) for metadata",
        "explanation": "Store heavy blobs in Object Storage (GCS) for cost/performance. Store flexible, schemaless metadata in a NoSQL document store (Firestore/Datastore) for fast querying.",
        "frequency_score": 10
    },
    {
        "id": 1031,
        "topic": "Apache Spark",
        "companies": [
            "Google",
            "Databricks",
            "Facebook",
            "Netflix"
        ],
        "question": "You are optimizing a Spark job that is suffering from data skew. One task takes 10x longer than others during a wide transformation. Which technique is most effective? ",
        "options": [
            "Salting the key",
            "Increasing the number of executors",
            "Using a larger instance type",
            "Broadcasting the large table"
        ],
        "answer": "Salting the key",
        "explanation": "Salting adds a random prefix to the skewed key to distribute it. Broadcasting is best for Skewed Joins where one table is small.",
        "frequency_score": 6
    },
    {
        "id": 1032,
        "topic": "Data Structures",
        "companies": [
            "Google",
            "Amazon",
            "Microsoft",
            "Facebook"
        ],
        "question": "You need to implement a look-up service that checks if a user ID exists in a set of 1 billion users with O(log n) average time complexity. Which data structure is best? ",
        "options": [
            "Hash Table / HashSet",
            "Binary Search Tree",
            "Linked List",
            "Array"
        ],
        "answer": "Binary Search Tree",
        "explanation": "Hash Tables provide O(1) average case lookup. BST is O(log n).",
        "frequency_score": 8
    },
    {
        "id": 1033,
        "topic": "Apache Kafka",
        "companies": [
            "Google",
            "LinkedIn"
        ],
        "question": "What happens if a Kafka Consumer Group has more consumers than partitions in the topic? ",
        "options": [
            "Some consumers will be idle",
            "Throughput increases linearly",
            "Kafka automatically creates more partitions",
            "The extra consumers duplicate the data"
        ],
        "answer": "Some consumers will be idle",
        "explanation": "A partition can be consumed by only one consumer within a group at a time. Extra consumers stay idle.",
        "frequency_score": 6
    },
    {
        "id": 1034,
        "topic": "Algorithms",
        "companies": [
            "Google",
            "Amazon",
            "Microsoft"
        ],
        "question": "What is the time complexity of a Bubble Sort algorithm in the worst case? ",
        "options": [
            "O(n log n)",
            "O(n^2)",
            "O(n)",
            "O(log n)"
        ],
        "answer": "O(n^2)",
        "explanation": "Merge Sort is O(n log n). Quick Sort is O(n^2) in worst case (though avg O(n log n)). Bubble Sort is O(n^2).",
        "frequency_score": 8
    },
    {
        "id": 1035,
        "topic": "Data Structures",
        "companies": [
            "Google",
            "Amazon",
            "Microsoft",
            "Facebook"
        ],
        "question": "You need to implement a look-up service that checks if a user ID exists in a set of 1 billion users with O(1) average time complexity. Which data structure is best? ",
        "options": [
            "Hash Table / HashSet",
            "Binary Search Tree",
            "Linked List",
            "Array"
        ],
        "answer": "Hash Table / HashSet",
        "explanation": "Hash Tables provide O(1) average case lookup. BST is O(log n).",
        "frequency_score": 8
    },
    {
        "id": 1036,
        "topic": "Data Structures",
        "companies": [
            "Google",
            "Amazon",
            "Microsoft",
            "Facebook"
        ],
        "question": "You need to implement a look-up service that checks if a user ID exists in a set of 1 billion users with O(1) average time complexity. Which data structure is best? ",
        "options": [
            "Hash Table / HashSet",
            "Binary Search Tree",
            "Linked List",
            "Array"
        ],
        "answer": "Hash Table / HashSet",
        "explanation": "Hash Tables provide O(1) average case lookup. BST is O(log n).",
        "frequency_score": 8
    },
    {
        "id": 1037,
        "topic": "System Design",
        "companies": [
            "Google",
            "Pinterest"
        ],
        "question": "You are designing a predictive search engine (like Google Search Autocomplete). You need sub-100ms latency for prefix lookups on billions of queries. Which data structure is optimal? ",
        "options": [
            "Trie (Prefix Tree) stored in memory",
            "B-Tree on disk",
            "Bloom Filter",
            "Inverted Index"
        ],
        "answer": "Trie (Prefix Tree) stored in memory",
        "explanation": "Tries are optimized for prefix lookups. Storing the top variations in memory (or using a distributed cache like Redis) ensures low latency.",
        "frequency_score": 10
    },
    {
        "id": 1038,
        "topic": "System Design",
        "companies": [
            "Google"
        ],
        "question": "You need to store unstructured images and videos for ML training, but also need rich metadata (tags, unexpected attributes) for querying. What architecture fits? ",
        "options": [
            "Object Store (GCS) for blobs + NoSQL (Firestore) for metadata",
            "BigQuery for everything",
            "Bigtable for blobs",
            "MySQL for everything"
        ],
        "answer": "Object Store (GCS) for blobs + NoSQL (Firestore) for metadata",
        "explanation": "Store heavy blobs in Object Storage (GCS) for cost/performance. Store flexible, schemaless metadata in a NoSQL document store (Firestore/Datastore) for fast querying.",
        "frequency_score": 10
    },
    {
        "id": 1039,
        "topic": "Apache Kafka",
        "companies": [
            "Google",
            "LinkedIn",
            "Uber",
            "Netflix"
        ],
        "question": "You need to ensure strict ordering of messages in Kafka for a specific Transaction ID. How should you configure the producer? ",
        "options": [
            "Use the Transaction ID as the partition key",
            "Use a single partition for the entire topic",
            "Enable idempotent producer",
            "Increase replication factor"
        ],
        "answer": "Use the Transaction ID as the partition key",
        "explanation": "Kafka guarantees ordering WITHIN a partition. Using the Entity ID as the key ensures all messages for that entity go to the same partition.",
        "frequency_score": 6
    },
    {
        "id": 1040,
        "topic": "Apache Kafka",
        "companies": [
            "Google",
            "LinkedIn",
            "Uber",
            "Netflix"
        ],
        "question": "You need to ensure strict ordering of messages in Kafka for a specific Transaction ID. How should you configure the producer? ",
        "options": [
            "Use the Transaction ID as the partition key",
            "Use a single partition for the entire topic",
            "Enable idempotent producer",
            "Increase replication factor"
        ],
        "answer": "Use the Transaction ID as the partition key",
        "explanation": "Kafka guarantees ordering WITHIN a partition. Using the Entity ID as the key ensures all messages for that entity go to the same partition.",
        "frequency_score": 6
    },
    {
        "id": 1041,
        "topic": "System Design",
        "companies": [
            "Google",
            "Pinterest"
        ],
        "question": "You are designing a predictive search engine (like Google Search Autocomplete). You need sub-100ms latency for prefix lookups on billions of queries. Which data structure is optimal? ",
        "options": [
            "Trie (Prefix Tree) stored in memory",
            "B-Tree on disk",
            "Bloom Filter",
            "Inverted Index"
        ],
        "answer": "Trie (Prefix Tree) stored in memory",
        "explanation": "Tries are optimized for prefix lookups. Storing the top variations in memory (or using a distributed cache like Redis) ensures low latency.",
        "frequency_score": 10
    },
    {
        "id": 1042,
        "topic": "Cloud Spanner",
        "companies": [
            "Google",
            "Uber",
            "Pokemon GO"
        ],
        "question": "You are designing a global banking ledger. You require strong consistency and 99.999% availability. Which database service should you choose? ",
        "options": [
            "Cloud Spanner",
            "Cloud SQL",
            "Bigtable",
            "Firestore"
        ],
        "answer": "Cloud Spanner",
        "explanation": "Cloud Spanner is the only service providing global strong consistency and horizontal scalability with relational semantics (SQL).",
        "frequency_score": 8
    },
    {
        "id": 1043,
        "topic": "Data Quality",
        "companies": [
            "Google",
            "Netflix",
            "Airbnb"
        ],
        "question": "You use the 'Write-Audit-Publish' (WAP) pattern for data quality. Where does the data go immediately after transformation but BEFORE it is visible to users? ",
        "options": [
            "A hidden 'stage' partition or snapshot",
            "The production table directly",
            "A temporary CSV file",
            "The Dead Letter Queue"
        ],
        "answer": "A hidden 'stage' partition or snapshot",
        "explanation": "In WAP, data is written to a staging area. Audits (queries) run against this area. If pass, the partition is swapped/published to production atomically.",
        "frequency_score": 8
    },
    {
        "id": 1044,
        "topic": "Pub/Sub",
        "companies": [
            "Google",
            "Uber"
        ],
        "question": "Your application publishes high throughput messages to Pub/Sub. You observe increased end-to-end latency and growing backlog. What is the most likely cause? ",
        "options": [
            "Subscribers are too slow (backlog)",
            "Publisher quota exceeded",
            "Message size too large",
            "Ordering keys are causing hotspots"
        ],
        "answer": "Subscribers are too slow (backlog)",
        "explanation": "If using ordering keys, high throughput on a single key can limit scalability (1MB/s limit per key). Slow subscribers cause increased backlog.",
        "frequency_score": 7
    },
    {
        "id": 1045,
        "topic": "Data Quality",
        "companies": [
            "Google",
            "Netflix",
            "Airbnb"
        ],
        "question": "You use the 'Write-Audit-Publish' (WAP) pattern for data quality. Where does the data go immediately after transformation but BEFORE it is visible to users? ",
        "options": [
            "A hidden 'stage' partition or snapshot",
            "The production table directly",
            "A temporary CSV file",
            "The Dead Letter Queue"
        ],
        "answer": "A hidden 'stage' partition or snapshot",
        "explanation": "In WAP, data is written to a staging area. Audits (queries) run against this area. If pass, the partition is swapped/published to production atomically.",
        "frequency_score": 8
    },
    {
        "id": 1046,
        "topic": "Data Structures",
        "companies": [
            "Google",
            "Amazon",
            "Microsoft",
            "Facebook"
        ],
        "question": "You need to implement a look-up service that checks if a user ID exists in a set of 1 billion users with O(1) average time complexity. Which data structure is best? ",
        "options": [
            "Hash Table / HashSet",
            "Binary Search Tree",
            "Linked List",
            "Array"
        ],
        "answer": "Hash Table / HashSet",
        "explanation": "Hash Tables provide O(1) average case lookup. BST is O(log n).",
        "frequency_score": 8
    },
    {
        "id": 1047,
        "topic": "Data Structures",
        "companies": [
            "Google",
            "Amazon",
            "Microsoft",
            "Facebook"
        ],
        "question": "You need to implement a look-up service that checks if a user ID exists in a set of 1 billion users with O(log n) average time complexity. Which data structure is best? ",
        "options": [
            "Hash Table / HashSet",
            "Binary Search Tree",
            "Linked List",
            "Array"
        ],
        "answer": "Binary Search Tree",
        "explanation": "Hash Tables provide O(1) average case lookup. BST is O(log n).",
        "frequency_score": 8
    },
    {
        "id": 1048,
        "topic": "System Design",
        "companies": [
            "Google",
            "Pinterest"
        ],
        "question": "You are designing a predictive search engine (like Google Search Autocomplete). You need sub-100ms latency for prefix lookups on billions of queries. Which data structure is optimal? ",
        "options": [
            "Trie (Prefix Tree) stored in memory",
            "B-Tree on disk",
            "Bloom Filter",
            "Inverted Index"
        ],
        "answer": "Trie (Prefix Tree) stored in memory",
        "explanation": "Tries are optimized for prefix lookups. Storing the top variations in memory (or using a distributed cache like Redis) ensures low latency.",
        "frequency_score": 10
    },
    {
        "id": 1049,
        "topic": "Distributed Systems",
        "companies": [
            "Google",
            "Facebook",
            "Amazon"
        ],
        "question": "You are designing a distributed counter. You need strict consistency (Linearizability) so every read returns the latest write. What is the trade-off according to the CAP theorem? ",
        "options": [
            "Availability must be sacrificed during partitions",
            "Partition Tolerance can be ignored",
            "Latency will decrease",
            "Consistency is free"
        ],
        "answer": "Availability must be sacrificed during partitions",
        "explanation": "In a CP (Consistent + Partition Tolerant) system, if a partition occurs, the system must refuse requests (unavailable) to ensure it doesn't return stale data.",
        "frequency_score": 9
    },
    {
        "id": 1050,
        "topic": "Apache Kafka",
        "companies": [
            "Google",
            "LinkedIn",
            "Uber",
            "Netflix"
        ],
        "question": "You need to ensure strict ordering of messages in Kafka for a specific Device ID. How should you configure the producer? ",
        "options": [
            "Use the Device ID as the partition key",
            "Use a single partition for the entire topic",
            "Enable idempotent producer",
            "Increase replication factor"
        ],
        "answer": "Use the Device ID as the partition key",
        "explanation": "Kafka guarantees ordering WITHIN a partition. Using the Entity ID as the key ensures all messages for that entity go to the same partition.",
        "frequency_score": 6
    },
    {
        "id": 1051,
        "topic": "System Design",
        "companies": [
            "Google",
            "Pinterest"
        ],
        "question": "You are designing a predictive search engine (like Google Search Autocomplete). You need sub-100ms latency for prefix lookups on billions of queries. Which data structure is optimal? ",
        "options": [
            "Trie (Prefix Tree) stored in memory",
            "B-Tree on disk",
            "Bloom Filter",
            "Inverted Index"
        ],
        "answer": "Trie (Prefix Tree) stored in memory",
        "explanation": "Tries are optimized for prefix lookups. Storing the top variations in memory (or using a distributed cache like Redis) ensures low latency.",
        "frequency_score": 10
    },
    {
        "id": 1052,
        "topic": "Distributed Systems",
        "companies": [
            "Google",
            "LinkedIn"
        ],
        "question": "Which replication strategy allows multiple nodes to accept writes, increasing write throughput but introducing potential update conflicts? ",
        "options": [
            "Multi-Leader (Master-Master) Replication",
            "Single-Leader Replication",
            "Leaderless Replication (Dynamo-style)",
            "Read Replicas only"
        ],
        "answer": "Multi-Leader (Master-Master) Replication",
        "explanation": "Multi-Leader replication allows writes at multiple datacenters/nodes. It improves performance and local availability but requires conflict resolution logic (e.g., Last Write Wins).",
        "frequency_score": 9
    },
    {
        "id": 1053,
        "topic": "System Design",
        "companies": [
            "Google"
        ],
        "question": "You need to store unstructured images and videos for ML training, but also need rich metadata (tags, unexpected attributes) for querying. What architecture fits? ",
        "options": [
            "Object Store (GCS) for blobs + NoSQL (Firestore) for metadata",
            "BigQuery for everything",
            "Bigtable for blobs",
            "MySQL for everything"
        ],
        "answer": "Object Store (GCS) for blobs + NoSQL (Firestore) for metadata",
        "explanation": "Store heavy blobs in Object Storage (GCS) for cost/performance. Store flexible, schemaless metadata in a NoSQL document store (Firestore/Datastore) for fast querying.",
        "frequency_score": 10
    },
    {
        "id": 1054,
        "topic": "Apache Kafka",
        "companies": [
            "Google",
            "LinkedIn",
            "Uber",
            "Netflix"
        ],
        "question": "You need to ensure strict ordering of messages in Kafka for a specific Device ID. How should you configure the producer? ",
        "options": [
            "Use the Device ID as the partition key",
            "Use a single partition for the entire topic",
            "Enable idempotent producer",
            "Increase replication factor"
        ],
        "answer": "Use the Device ID as the partition key",
        "explanation": "Kafka guarantees ordering WITHIN a partition. Using the Entity ID as the key ensures all messages for that entity go to the same partition.",
        "frequency_score": 6
    },
    {
        "id": 1055,
        "topic": "Dataflow",
        "companies": [
            "Google",
            "Spotify",
            "New York Times"
        ],
        "question": "You are building a streaming pipeline to process IoT temperature sensors. You need to handle rolling averages every minute for the last hour. What windowing strategy is appropriate? ",
        "options": [
            "Fixed Windows",
            "Sliding Windows",
            "Session Windows",
            "Global Windows"
        ],
        "answer": "Sliding Windows",
        "explanation": "Session windows gap-fill based on activity. Sliding windows overlap (e.g. every 5 min show last 1 hour). Fixed windows are tumbling.",
        "frequency_score": 9
    },
    {
        "id": 1056,
        "topic": "Data Quality",
        "companies": [
            "Google",
            "Netflix",
            "Airbnb"
        ],
        "question": "You use the 'Write-Audit-Publish' (WAP) pattern for data quality. Where does the data go immediately after transformation but BEFORE it is visible to users? ",
        "options": [
            "A hidden 'stage' partition or snapshot",
            "The production table directly",
            "A temporary CSV file",
            "The Dead Letter Queue"
        ],
        "answer": "A hidden 'stage' partition or snapshot",
        "explanation": "In WAP, data is written to a staging area. Audits (queries) run against this area. If pass, the partition is swapped/published to production atomically.",
        "frequency_score": 8
    },
    {
        "id": 1057,
        "topic": "System Design",
        "companies": [
            "Google"
        ],
        "question": "You need to store unstructured images and videos for ML training, but also need rich metadata (tags, unexpected attributes) for querying. What architecture fits? ",
        "options": [
            "Object Store (GCS) for blobs + NoSQL (Firestore) for metadata",
            "BigQuery for everything",
            "Bigtable for blobs",
            "MySQL for everything"
        ],
        "answer": "Object Store (GCS) for blobs + NoSQL (Firestore) for metadata",
        "explanation": "Store heavy blobs in Object Storage (GCS) for cost/performance. Store flexible, schemaless metadata in a NoSQL document store (Firestore/Datastore) for fast querying.",
        "frequency_score": 10
    },
    {
        "id": 1058,
        "topic": "Bigtable",
        "companies": [
            "Google",
            "Spotify"
        ],
        "question": "You are designing a Bigtable schema for IoT events. Queries will primarily be retrieve latest events for a specific entity. Which row key design is optimal? ",
        "options": [
            "UserID#Date",
            "Date#UserID",
            "ReverseTimestamp#UserID",
            "Random#UserID"
        ],
        "answer": "UserID#Date",
        "explanation": "Avoid starting with timestamp to prevent hotspots. Use EntityID first for entity-lookup queries. Use ReverseTimestamp for 'latest items' queries globally.",
        "frequency_score": 7
    },
    {
        "id": 1059,
        "topic": "Cloud Storage",
        "companies": [
            "Google",
            "Snapchat"
        ],
        "question": "You are designing a storage solution for disaster recovery backups. The requirement is high frequency access. What storage class should you use? ",
        "options": [
            "Standard",
            "Nearline",
            "Coldline",
            "Archive"
        ],
        "answer": "Standard",
        "explanation": "Standard for hot data. Nearline < 1/month. Coldline < 1/quarter. Archive < 1/year.",
        "frequency_score": 6
    },
    {
        "id": 1060,
        "topic": "Bigtable",
        "companies": [
            "Google",
            "Spotify"
        ],
        "question": "You are designing a Bigtable schema for financial transactions. Queries will primarily be retrieve most recent events globally. Which row key design is optimal? ",
        "options": [
            "SensorID#Timestamp",
            "Timestamp#SensorID",
            "ReverseTimestamp#SensorID",
            "Random#SensorID"
        ],
        "answer": "ReverseTimestamp#SensorID",
        "explanation": "Avoid starting with timestamp to prevent hotspots. Use EntityID first for entity-lookup queries. Use ReverseTimestamp for 'latest items' queries globally.",
        "frequency_score": 7
    },
    {
        "id": 1061,
        "topic": "Bigtable",
        "companies": [
            "Google",
            "Spotify"
        ],
        "question": "You are designing a Bigtable schema for social media posts. Queries will primarily be retrieve latest events for a specific entity. Which row key design is optimal? ",
        "options": [
            "UserID#Timestamp",
            "Timestamp#UserID",
            "ReverseTimestamp#UserID",
            "Random#UserID"
        ],
        "answer": "UserID#Timestamp",
        "explanation": "Avoid starting with timestamp to prevent hotspots. Use EntityID first for entity-lookup queries. Use ReverseTimestamp for 'latest items' queries globally.",
        "frequency_score": 7
    },
    {
        "id": 1062,
        "topic": "IAM",
        "companies": [
            "Google"
        ],
        "question": "A developer needs to upload files to a bucket in a production project. Following the principle of least privilege, which role should you grant? ",
        "options": [
            "Viewer",
            "Editor",
            "Owner",
            "BigQuery Data Viewer"
        ],
        "answer": "BigQuery Data Viewer",
        "explanation": "Always prefer predefined specific roles (like BigQuery Data Viewer, Storage Object Admin) over basic roles (Viewer/Editor/Owner) to ensure least privilege.",
        "frequency_score": 9
    },
    {
        "id": 1063,
        "topic": "Cloud Storage",
        "companies": [
            "Google",
            "Snapchat"
        ],
        "question": "You are designing a storage solution for profile pictures. The requirement is high frequency access. What storage class should you use? ",
        "options": [
            "Standard",
            "Nearline",
            "Coldline",
            "Archive"
        ],
        "answer": "Standard",
        "explanation": "Standard for hot data. Nearline < 1/month. Coldline < 1/quarter. Archive < 1/year.",
        "frequency_score": 6
    },
    {
        "id": 1064,
        "topic": "Data Structures",
        "companies": [
            "Google",
            "Amazon",
            "Microsoft",
            "Facebook"
        ],
        "question": "You need to implement a look-up service that checks if a user ID exists in a set of 1 billion users with O(log n) average time complexity. Which data structure is best? ",
        "options": [
            "Hash Table / HashSet",
            "Binary Search Tree",
            "Linked List",
            "Array"
        ],
        "answer": "Binary Search Tree",
        "explanation": "Hash Tables provide O(1) average case lookup. BST is O(log n).",
        "frequency_score": 8
    },
    {
        "id": 1065,
        "topic": "Apache Spark",
        "companies": [
            "Google",
            "Databricks",
            "Facebook",
            "Netflix"
        ],
        "question": "You are optimizing a Spark job that is suffering from data skew. You are joining a large skewed table with a small reference table. Which technique is most effective? ",
        "options": [
            "Salting the key",
            "Increasing the number of executors",
            "Using a larger instance type",
            "Broadcasting the large table"
        ],
        "answer": "Salting the key",
        "explanation": "Salting adds a random prefix to the skewed key to distribute it. Broadcasting is best for Skewed Joins where one table is small.",
        "frequency_score": 6
    },
    {
        "id": 1066,
        "topic": "Bigtable",
        "companies": [
            "Google",
            "Spotify"
        ],
        "question": "You are designing a Bigtable schema for social media posts. Queries will primarily be retrieve most recent events globally. Which row key design is optimal? ",
        "options": [
            "UserID#Date",
            "Date#UserID",
            "ReverseTimestamp#UserID",
            "Random#UserID"
        ],
        "answer": "ReverseTimestamp#UserID",
        "explanation": "Avoid starting with timestamp to prevent hotspots. Use EntityID first for entity-lookup queries. Use ReverseTimestamp for 'latest items' queries globally.",
        "frequency_score": 7
    },
    {
        "id": 1067,
        "topic": "Cloud Spanner",
        "companies": [
            "Google",
            "Uber",
            "Pokemon GO"
        ],
        "question": "You are designing a global banking ledger. You require strong consistency and 99.999% availability. Which database service should you choose? ",
        "options": [
            "Cloud Spanner",
            "Cloud SQL",
            "Bigtable",
            "Firestore"
        ],
        "answer": "Cloud Spanner",
        "explanation": "Cloud Spanner is the only service providing global strong consistency and horizontal scalability with relational semantics (SQL).",
        "frequency_score": 8
    },
    {
        "id": 1068,
        "topic": "System Design",
        "companies": [
            "Google",
            "Discord"
        ],
        "question": "You need to distribute a massive dataset across 1000 nodes. Nodes frequently join and leave. Which partitioning strategy minimizes data movement when the cluster resizes? ",
        "options": [
            "Consistent Hashing",
            "Round-Robin Partitioning",
            "Range Partitioning",
            "Modulo Hashing (Key % N)"
        ],
        "answer": "Consistent Hashing",
        "explanation": "Consistent Hashing maps both data and nodes to a ring. When a node is added/removed, only 1/k keys need to be remapped (neighbors), vs nearly all keys with Modulo Hashing.",
        "frequency_score": 10
    },
    {
        "id": 1069,
        "topic": "Algorithms",
        "companies": [
            "Google",
            "Amazon",
            "Microsoft"
        ],
        "question": "What is the time complexity of a Merge Sort algorithm in the worst case? ",
        "options": [
            "O(n log n)",
            "O(n^2)",
            "O(n)",
            "O(log n)"
        ],
        "answer": "O(n log n)",
        "explanation": "Merge Sort is O(n log n). Quick Sort is O(n^2) in worst case (though avg O(n log n)). Bubble Sort is O(n^2).",
        "frequency_score": 8
    },
    {
        "id": 1070,
        "topic": "Distributed Systems",
        "companies": [
            "Google",
            "Facebook",
            "Amazon"
        ],
        "question": "You are designing a distributed counter. You need strict consistency (Linearizability) so every read returns the latest write. What is the trade-off according to the CAP theorem? ",
        "options": [
            "Availability must be sacrificed during partitions",
            "Partition Tolerance can be ignored",
            "Latency will decrease",
            "Consistency is free"
        ],
        "answer": "Availability must be sacrificed during partitions",
        "explanation": "In a CP (Consistent + Partition Tolerant) system, if a partition occurs, the system must refuse requests (unavailable) to ensure it doesn't return stale data.",
        "frequency_score": 9
    },
    {
        "id": 1071,
        "topic": "System Design",
        "companies": [
            "Google",
            "Pinterest"
        ],
        "question": "You are designing a predictive search engine (like Google Search Autocomplete). You need sub-100ms latency for prefix lookups on billions of queries. Which data structure is optimal? ",
        "options": [
            "Trie (Prefix Tree) stored in memory",
            "B-Tree on disk",
            "Bloom Filter",
            "Inverted Index"
        ],
        "answer": "Trie (Prefix Tree) stored in memory",
        "explanation": "Tries are optimized for prefix lookups. Storing the top variations in memory (or using a distributed cache like Redis) ensures low latency.",
        "frequency_score": 10
    },
    {
        "id": 1072,
        "topic": "Distributed Systems",
        "companies": [
            "Google",
            "Uber"
        ],
        "question": "You need to update data across two separate microservices (e.g., Payment and Order) transactionally. Traditional 2PC (Two-Phase Commit) is too slow/blocking. What is the modern alternative? ",
        "options": [
            "Saga Pattern",
            "3PC",
            "Write-Ahead Logging",
            "Stored Procedures"
        ],
        "answer": "Saga Pattern",
        "explanation": "The Saga pattern manages distributed transactions as a sequence of local transactions, with compensating actions (undo operations) to handle failures without long locks.",
        "frequency_score": 9
    },
    {
        "id": 1073,
        "topic": "System Design",
        "companies": [
            "Google",
            "Pinterest"
        ],
        "question": "You are designing a predictive search engine (like Google Search Autocomplete). You need sub-100ms latency for prefix lookups on billions of queries. Which data structure is optimal? ",
        "options": [
            "Trie (Prefix Tree) stored in memory",
            "B-Tree on disk",
            "Bloom Filter",
            "Inverted Index"
        ],
        "answer": "Trie (Prefix Tree) stored in memory",
        "explanation": "Tries are optimized for prefix lookups. Storing the top variations in memory (or using a distributed cache like Redis) ensures low latency.",
        "frequency_score": 10
    },
    {
        "id": 1074,
        "topic": "Bigtable",
        "companies": [
            "Google",
            "Spotify"
        ],
        "question": "You are designing a Bigtable schema for social media posts. Queries will primarily be retrieve latest events for a specific entity. Which row key design is optimal? ",
        "options": [
            "UserID#Timestamp",
            "Timestamp#UserID",
            "ReverseTimestamp#UserID",
            "Random#UserID"
        ],
        "answer": "UserID#Timestamp",
        "explanation": "Avoid starting with timestamp to prevent hotspots. Use EntityID first for entity-lookup queries. Use ReverseTimestamp for 'latest items' queries globally.",
        "frequency_score": 7
    },
    {
        "id": 1075,
        "topic": "Apache Spark",
        "companies": [
            "Google",
            "Databricks",
            "Facebook",
            "Netflix"
        ],
        "question": "You are optimizing a Spark job that is suffering from data skew. One task takes 10x longer than others during a wide transformation. Which technique is most effective? ",
        "options": [
            "Salting the key",
            "Increasing the number of executors",
            "Using a larger instance type",
            "Broadcasting the large table"
        ],
        "answer": "Salting the key",
        "explanation": "Salting adds a random prefix to the skewed key to distribute it. Broadcasting is best for Skewed Joins where one table is small.",
        "frequency_score": 6
    },
    {
        "id": 1076,
        "topic": "Apache Spark",
        "companies": [
            "Google",
            "Databricks",
            "Amazon"
        ],
        "question": "In Spark, what is the difference between a Transformation and an Action? ",
        "options": [
            "Transformations are lazy, Actions match strict execution",
            "Actions are lazy, Transformations trigger execution",
            "They are the same",
            "Transformations save to disk, Actions read from disk"
        ],
        "answer": "Transformations are lazy, Actions match strict execution",
        "explanation": "Transformations (like map, filter) build the DAG but do not execute. Actions (like count, collect, save) trigger the actual computation.",
        "frequency_score": 6
    },
    {
        "id": 1077,
        "topic": "Apache Kafka",
        "companies": [
            "Google",
            "LinkedIn",
            "Uber",
            "Netflix"
        ],
        "question": "You need to ensure strict ordering of messages in Kafka for a specific Device ID. How should you configure the producer? ",
        "options": [
            "Use the Device ID as the partition key",
            "Use a single partition for the entire topic",
            "Enable idempotent producer",
            "Increase replication factor"
        ],
        "answer": "Use the Device ID as the partition key",
        "explanation": "Kafka guarantees ordering WITHIN a partition. Using the Entity ID as the key ensures all messages for that entity go to the same partition.",
        "frequency_score": 6
    },
    {
        "id": 1078,
        "topic": "Apache Kafka",
        "companies": [
            "Google",
            "LinkedIn"
        ],
        "question": "What happens if a Kafka Consumer Group has more consumers than partitions in the topic? ",
        "options": [
            "Some consumers will be idle",
            "Throughput increases linearly",
            "Kafka automatically creates more partitions",
            "The extra consumers duplicate the data"
        ],
        "answer": "Some consumers will be idle",
        "explanation": "A partition can be consumed by only one consumer within a group at a time. Extra consumers stay idle.",
        "frequency_score": 6
    },
    {
        "id": 1079,
        "topic": "Distributed Systems",
        "companies": [
            "Google",
            "Uber"
        ],
        "question": "You need to update data across two separate microservices (e.g., Payment and Order) transactionally. Traditional 2PC (Two-Phase Commit) is too slow/blocking. What is the modern alternative? ",
        "options": [
            "Saga Pattern",
            "3PC",
            "Write-Ahead Logging",
            "Stored Procedures"
        ],
        "answer": "Saga Pattern",
        "explanation": "The Saga pattern manages distributed transactions as a sequence of local transactions, with compensating actions (undo operations) to handle failures without long locks.",
        "frequency_score": 9
    },
    {
        "id": 1080,
        "topic": "Data Structures",
        "companies": [
            "Google",
            "Amazon",
            "Microsoft",
            "Facebook"
        ],
        "question": "You need to implement a look-up service that checks if a user ID exists in a set of 1 billion users with O(log n) average time complexity. Which data structure is best? ",
        "options": [
            "Hash Table / HashSet",
            "Binary Search Tree",
            "Linked List",
            "Array"
        ],
        "answer": "Binary Search Tree",
        "explanation": "Hash Tables provide O(1) average case lookup. BST is O(log n).",
        "frequency_score": 8
    },
    {
        "id": 1081,
        "topic": "Pub/Sub",
        "companies": [
            "Google",
            "Uber"
        ],
        "question": "Your application publishes high throughput messages to Pub/Sub. You observe increased end-to-end latency and growing backlog. What is the most likely cause? ",
        "options": [
            "Subscribers are too slow (backlog)",
            "Publisher quota exceeded",
            "Message size too large",
            "Ordering keys are causing hotspots"
        ],
        "answer": "Subscribers are too slow (backlog)",
        "explanation": "If using ordering keys, high throughput on a single key can limit scalability (1MB/s limit per key). Slow subscribers cause increased backlog.",
        "frequency_score": 7
    },
    {
        "id": 1082,
        "topic": "System Design",
        "companies": [
            "Google",
            "Pinterest"
        ],
        "question": "You are designing a predictive search engine (like Google Search Autocomplete). You need sub-100ms latency for prefix lookups on billions of queries. Which data structure is optimal? ",
        "options": [
            "Trie (Prefix Tree) stored in memory",
            "B-Tree on disk",
            "Bloom Filter",
            "Inverted Index"
        ],
        "answer": "Trie (Prefix Tree) stored in memory",
        "explanation": "Tries are optimized for prefix lookups. Storing the top variations in memory (or using a distributed cache like Redis) ensures low latency.",
        "frequency_score": 10
    },
    {
        "id": 1083,
        "topic": "Distributed Systems",
        "companies": [
            "Google",
            "LinkedIn"
        ],
        "question": "Which replication strategy allows multiple nodes to accept writes, increasing write throughput but introducing potential update conflicts? ",
        "options": [
            "Multi-Leader (Master-Master) Replication",
            "Single-Leader Replication",
            "Leaderless Replication (Dynamo-style)",
            "Read Replicas only"
        ],
        "answer": "Multi-Leader (Master-Master) Replication",
        "explanation": "Multi-Leader replication allows writes at multiple datacenters/nodes. It improves performance and local availability but requires conflict resolution logic (e.g., Last Write Wins).",
        "frequency_score": 9
    },
    {
        "id": 1084,
        "topic": "Cloud Spanner",
        "companies": [
            "Google",
            "Uber",
            "Pokemon GO"
        ],
        "question": "You are designing a global banking ledger. You require strong consistency and 99.999% availability. Which database service should you choose? ",
        "options": [
            "Cloud Spanner",
            "Cloud SQL",
            "Bigtable",
            "Firestore"
        ],
        "answer": "Cloud Spanner",
        "explanation": "Cloud Spanner is the only service providing global strong consistency and horizontal scalability with relational semantics (SQL).",
        "frequency_score": 8
    },
    {
        "id": 1085,
        "topic": "Cloud Spanner",
        "companies": [
            "Google",
            "Uber",
            "Pokemon GO"
        ],
        "question": "You are designing a global banking ledger. You require strong consistency and horizontal scalability. Which database service should you choose? ",
        "options": [
            "Cloud Spanner",
            "Cloud SQL",
            "Bigtable",
            "Firestore"
        ],
        "answer": "Cloud Spanner",
        "explanation": "Cloud Spanner is the only service providing global strong consistency and horizontal scalability with relational semantics (SQL).",
        "frequency_score": 8
    },
    {
        "id": 1086,
        "topic": "Cloud Spanner",
        "companies": [
            "Google",
            "Uber",
            "Pokemon GO"
        ],
        "question": "You are designing a global banking ledger. You require strong consistency and 99.999% availability. Which database service should you choose? ",
        "options": [
            "Cloud Spanner",
            "Cloud SQL",
            "Bigtable",
            "Firestore"
        ],
        "answer": "Cloud Spanner",
        "explanation": "Cloud Spanner is the only service providing global strong consistency and horizontal scalability with relational semantics (SQL).",
        "frequency_score": 8
    },
    {
        "id": 1087,
        "topic": "System Design",
        "companies": [
            "Google",
            "Pinterest"
        ],
        "question": "You are designing a predictive search engine (like Google Search Autocomplete). You need sub-100ms latency for prefix lookups on billions of queries. Which data structure is optimal? ",
        "options": [
            "Trie (Prefix Tree) stored in memory",
            "B-Tree on disk",
            "Bloom Filter",
            "Inverted Index"
        ],
        "answer": "Trie (Prefix Tree) stored in memory",
        "explanation": "Tries are optimized for prefix lookups. Storing the top variations in memory (or using a distributed cache like Redis) ensures low latency.",
        "frequency_score": 10
    },
    {
        "id": 1088,
        "topic": "Apache Spark",
        "companies": [
            "Google",
            "Databricks",
            "Facebook",
            "Netflix"
        ],
        "question": "You are optimizing a Spark job that is suffering from data skew. You are joining a large skewed table with a small reference table. Which technique is most effective? ",
        "options": [
            "Salting the key",
            "Increasing the number of executors",
            "Using a larger instance type",
            "Broadcasting the large table"
        ],
        "answer": "Salting the key",
        "explanation": "Salting adds a random prefix to the skewed key to distribute it. Broadcasting is best for Skewed Joins where one table is small.",
        "frequency_score": 6
    },
    {
        "id": 1089,
        "topic": "System Design",
        "companies": [
            "Google",
            "Discord"
        ],
        "question": "You need to distribute a massive dataset across 1000 nodes. Nodes frequently join and leave. Which partitioning strategy minimizes data movement when the cluster resizes? ",
        "options": [
            "Consistent Hashing",
            "Round-Robin Partitioning",
            "Range Partitioning",
            "Modulo Hashing (Key % N)"
        ],
        "answer": "Consistent Hashing",
        "explanation": "Consistent Hashing maps both data and nodes to a ring. When a node is added/removed, only 1/k keys need to be remapped (neighbors), vs nearly all keys with Modulo Hashing.",
        "frequency_score": 10
    },
    {
        "id": 1090,
        "topic": "Distributed Systems",
        "companies": [
            "Google",
            "LinkedIn"
        ],
        "question": "Which replication strategy allows multiple nodes to accept writes, increasing write throughput but introducing potential update conflicts? ",
        "options": [
            "Multi-Leader (Master-Master) Replication",
            "Single-Leader Replication",
            "Leaderless Replication (Dynamo-style)",
            "Read Replicas only"
        ],
        "answer": "Multi-Leader (Master-Master) Replication",
        "explanation": "Multi-Leader replication allows writes at multiple datacenters/nodes. It improves performance and local availability but requires conflict resolution logic (e.g., Last Write Wins).",
        "frequency_score": 9
    },
    {
        "id": 1091,
        "topic": "Apache Spark",
        "companies": [
            "Google",
            "Databricks",
            "Amazon"
        ],
        "question": "In Spark, what is the difference between a Transformation and an Action? ",
        "options": [
            "Transformations are lazy, Actions match strict execution",
            "Actions are lazy, Transformations trigger execution",
            "They are the same",
            "Transformations save to disk, Actions read from disk"
        ],
        "answer": "Transformations are lazy, Actions match strict execution",
        "explanation": "Transformations (like map, filter) build the DAG but do not execute. Actions (like count, collect, save) trigger the actual computation.",
        "frequency_score": 6
    },
    {
        "id": 1092,
        "topic": "Bigtable",
        "companies": [
            "Google",
            "Spotify"
        ],
        "question": "You are designing a Bigtable schema for IoT events. Queries will primarily be retrieve most recent events globally. Which row key design is optimal? ",
        "options": [
            "SensorID#Timestamp",
            "Timestamp#SensorID",
            "ReverseTimestamp#SensorID",
            "Random#SensorID"
        ],
        "answer": "ReverseTimestamp#SensorID",
        "explanation": "Avoid starting with timestamp to prevent hotspots. Use EntityID first for entity-lookup queries. Use ReverseTimestamp for 'latest items' queries globally.",
        "frequency_score": 7
    },
    {
        "id": 1093,
        "topic": "System Design",
        "companies": [
            "Google"
        ],
        "question": "You need to store unstructured images and videos for ML training, but also need rich metadata (tags, unexpected attributes) for querying. What architecture fits? ",
        "options": [
            "Object Store (GCS) for blobs + NoSQL (Firestore) for metadata",
            "BigQuery for everything",
            "Bigtable for blobs",
            "MySQL for everything"
        ],
        "answer": "Object Store (GCS) for blobs + NoSQL (Firestore) for metadata",
        "explanation": "Store heavy blobs in Object Storage (GCS) for cost/performance. Store flexible, schemaless metadata in a NoSQL document store (Firestore/Datastore) for fast querying.",
        "frequency_score": 10
    },
    {
        "id": 1094,
        "topic": "System Design",
        "companies": [
            "Google",
            "Pinterest"
        ],
        "question": "You are designing a predictive search engine (like Google Search Autocomplete). You need sub-100ms latency for prefix lookups on billions of queries. Which data structure is optimal? ",
        "options": [
            "Trie (Prefix Tree) stored in memory",
            "B-Tree on disk",
            "Bloom Filter",
            "Inverted Index"
        ],
        "answer": "Trie (Prefix Tree) stored in memory",
        "explanation": "Tries are optimized for prefix lookups. Storing the top variations in memory (or using a distributed cache like Redis) ensures low latency.",
        "frequency_score": 10
    },
    {
        "id": 1095,
        "topic": "BigQuery",
        "companies": [
            "Google",
            "Spotify",
            "Twitter"
        ],
        "question": "You need to store 50 TB of transaction records data in BigQuery. The data is accessed rarely (every 6 months). Which storage class fits best to minimize costs? ",
        "options": [
            "Active Storage",
            "Long-term Storage",
            "Nearline Storage",
            "Coldline Storage"
        ],
        "answer": "Long-term Storage",
        "explanation": "BigQuery Long-term storage applies automatically after 90 days of no modification, reducing price by ~50%.",
        "frequency_score": 10
    },
    {
        "id": 1096,
        "topic": "Distributed Systems",
        "companies": [
            "Google",
            "Uber"
        ],
        "question": "You need to update data across two separate microservices (e.g., Payment and Order) transactionally. Traditional 2PC (Two-Phase Commit) is too slow/blocking. What is the modern alternative? ",
        "options": [
            "Saga Pattern",
            "3PC",
            "Write-Ahead Logging",
            "Stored Procedures"
        ],
        "answer": "Saga Pattern",
        "explanation": "The Saga pattern manages distributed transactions as a sequence of local transactions, with compensating actions (undo operations) to handle failures without long locks.",
        "frequency_score": 9
    },
    {
        "id": 1097,
        "topic": "Apache Kafka",
        "companies": [
            "Google",
            "LinkedIn",
            "Uber",
            "Netflix"
        ],
        "question": "You need to ensure strict ordering of messages in Kafka for a specific User ID. How should you configure the producer? ",
        "options": [
            "Use the User ID as the partition key",
            "Use a single partition for the entire topic",
            "Enable idempotent producer",
            "Increase replication factor"
        ],
        "answer": "Use the User ID as the partition key",
        "explanation": "Kafka guarantees ordering WITHIN a partition. Using the Entity ID as the key ensures all messages for that entity go to the same partition.",
        "frequency_score": 6
    },
    {
        "id": 1098,
        "topic": "System Design",
        "companies": [
            "Google",
            "Discord"
        ],
        "question": "You need to distribute a massive dataset across 1000 nodes. Nodes frequently join and leave. Which partitioning strategy minimizes data movement when the cluster resizes? ",
        "options": [
            "Consistent Hashing",
            "Round-Robin Partitioning",
            "Range Partitioning",
            "Modulo Hashing (Key % N)"
        ],
        "answer": "Consistent Hashing",
        "explanation": "Consistent Hashing maps both data and nodes to a ring. When a node is added/removed, only 1/k keys need to be remapped (neighbors), vs nearly all keys with Modulo Hashing.",
        "frequency_score": 10
    },
    {
        "id": 1099,
        "topic": "System Design",
        "companies": [
            "Google"
        ],
        "question": "You need to store unstructured images and videos for ML training, but also need rich metadata (tags, unexpected attributes) for querying. What architecture fits? ",
        "options": [
            "Object Store (GCS) for blobs + NoSQL (Firestore) for metadata",
            "BigQuery for everything",
            "Bigtable for blobs",
            "MySQL for everything"
        ],
        "answer": "Object Store (GCS) for blobs + NoSQL (Firestore) for metadata",
        "explanation": "Store heavy blobs in Object Storage (GCS) for cost/performance. Store flexible, schemaless metadata in a NoSQL document store (Firestore/Datastore) for fast querying.",
        "frequency_score": 10
    },
    {
        "id": 1100,
        "topic": "Distributed Systems",
        "companies": [
            "Google",
            "Uber"
        ],
        "question": "You need to update data across two separate microservices (e.g., Payment and Order) transactionally. Traditional 2PC (Two-Phase Commit) is too slow/blocking. What is the modern alternative? ",
        "options": [
            "Saga Pattern",
            "3PC",
            "Write-Ahead Logging",
            "Stored Procedures"
        ],
        "answer": "Saga Pattern",
        "explanation": "The Saga pattern manages distributed transactions as a sequence of local transactions, with compensating actions (undo operations) to handle failures without long locks.",
        "frequency_score": 9
    },
    {
        "id": 1101,
        "topic": "BigQuery",
        "companies": [
            "Google",
            "Spotify",
            "Twitter"
        ],
        "question": "You need to store 50 TB of sensor metrics data in BigQuery. The data is accessed rarely (every 6 months). Which storage class fits best to minimize costs?",
        "options": [
            "Active Storage",
            "Long-term Storage",
            "Nearline Storage",
            "Coldline Storage"
        ],
        "answer": "Long-term Storage",
        "explanation": "BigQuery Long-term storage applies automatically after 90 days of no modification, reducing price by ~50%.",
        "frequency_score": 10
    },
    {
        "id": 1102,
        "topic": "Distributed Systems",
        "companies": [
            "Google",
            "LinkedIn"
        ],
        "question": "Which replication strategy allows multiple nodes to accept writes, increasing write throughput but introducing potential update conflicts? ",
        "options": [
            "Multi-Leader (Master-Master) Replication",
            "Single-Leader Replication",
            "Leaderless Replication (Dynamo-style)",
            "Read Replicas only"
        ],
        "answer": "Multi-Leader (Master-Master) Replication",
        "explanation": "Multi-Leader replication allows writes at multiple datacenters/nodes. It improves performance and local availability but requires conflict resolution logic (e.g., Last Write Wins).",
        "frequency_score": 9
    },
    {
        "id": 1103,
        "topic": "Cloud Storage",
        "companies": [
            "Google",
            "Snapchat"
        ],
        "question": "You are designing a storage solution for disaster recovery backups. The requirement is access once a year. What storage class should you use? ",
        "options": [
            "Standard",
            "Nearline",
            "Coldline",
            "Archive"
        ],
        "answer": "Archive",
        "explanation": "Standard for hot data. Nearline < 1/month. Coldline < 1/quarter. Archive < 1/year.",
        "frequency_score": 6
    },
    {
        "id": 1104,
        "topic": "System Design",
        "companies": [
            "Google",
            "Discord"
        ],
        "question": "You need to distribute a massive dataset across 1000 nodes. Nodes frequently join and leave. Which partitioning strategy minimizes data movement when the cluster resizes? ",
        "options": [
            "Consistent Hashing",
            "Round-Robin Partitioning",
            "Range Partitioning",
            "Modulo Hashing (Key % N)"
        ],
        "answer": "Consistent Hashing",
        "explanation": "Consistent Hashing maps both data and nodes to a ring. When a node is added/removed, only 1/k keys need to be remapped (neighbors), vs nearly all keys with Modulo Hashing.",
        "frequency_score": 10
    },
    {
        "id": 1105,
        "topic": "Data Quality",
        "companies": [
            "Google",
            "Netflix",
            "Airbnb"
        ],
        "question": "You use the 'Write-Audit-Publish' (WAP) pattern for data quality. Where does the data go immediately after transformation but BEFORE it is visible to users? ",
        "options": [
            "A hidden 'stage' partition or snapshot",
            "The production table directly",
            "A temporary CSV file",
            "The Dead Letter Queue"
        ],
        "answer": "A hidden 'stage' partition or snapshot",
        "explanation": "In WAP, data is written to a staging area. Audits (queries) run against this area. If pass, the partition is swapped/published to production atomically.",
        "frequency_score": 8
    },
    {
        "id": 1106,
        "topic": "Cloud Storage",
        "companies": [
            "Google",
            "Snapchat"
        ],
        "question": "You are designing a storage solution for regulatory archives. The requirement is high frequency access. What storage class should you use? ",
        "options": [
            "Standard",
            "Nearline",
            "Coldline",
            "Archive"
        ],
        "answer": "Standard",
        "explanation": "Standard for hot data. Nearline < 1/month. Coldline < 1/quarter. Archive < 1/year.",
        "frequency_score": 6
    },
    {
        "id": 1107,
        "topic": "Cloud Storage",
        "companies": [
            "Google",
            "Snapchat"
        ],
        "question": "You are designing a storage solution for regulatory archives. The requirement is access once a quarter. What storage class should you use? ",
        "options": [
            "Standard",
            "Nearline",
            "Coldline",
            "Archive"
        ],
        "answer": "Coldline",
        "explanation": "Standard for hot data. Nearline < 1/month. Coldline < 1/quarter. Archive < 1/year.",
        "frequency_score": 6
    },
    {
        "id": 1108,
        "topic": "Distributed Systems",
        "companies": [
            "Google",
            "Facebook",
            "Amazon"
        ],
        "question": "You are designing a distributed counter. You need strict consistency (Linearizability) so every read returns the latest write. What is the trade-off according to the CAP theorem? ",
        "options": [
            "Availability must be sacrificed during partitions",
            "Partition Tolerance can be ignored",
            "Latency will decrease",
            "Consistency is free"
        ],
        "answer": "Availability must be sacrificed during partitions",
        "explanation": "In a CP (Consistent + Partition Tolerant) system, if a partition occurs, the system must refuse requests (unavailable) to ensure it doesn't return stale data.",
        "frequency_score": 9
    },
    {
        "id": 1109,
        "topic": "Data Quality",
        "companies": [
            "Google",
            "Netflix",
            "Airbnb"
        ],
        "question": "You use the 'Write-Audit-Publish' (WAP) pattern for data quality. Where does the data go immediately after transformation but BEFORE it is visible to users? ",
        "options": [
            "A hidden 'stage' partition or snapshot",
            "The production table directly",
            "A temporary CSV file",
            "The Dead Letter Queue"
        ],
        "answer": "A hidden 'stage' partition or snapshot",
        "explanation": "In WAP, data is written to a staging area. Audits (queries) run against this area. If pass, the partition is swapped/published to production atomically.",
        "frequency_score": 8
    },
    {
        "id": 1110,
        "topic": "Apache Kafka",
        "companies": [
            "Google",
            "LinkedIn"
        ],
        "question": "What happens if a Kafka Consumer Group has more consumers than partitions in the topic? ",
        "options": [
            "Some consumers will be idle",
            "Throughput increases linearly",
            "Kafka automatically creates more partitions",
            "The extra consumers duplicate the data"
        ],
        "answer": "Some consumers will be idle",
        "explanation": "A partition can be consumed by only one consumer within a group at a time. Extra consumers stay idle.",
        "frequency_score": 6
    },
    {
        "id": 1111,
        "topic": "Algorithms",
        "companies": [
            "Google",
            "Amazon",
            "Microsoft"
        ],
        "question": "What is the time complexity of a Bubble Sort algorithm in the worst case? ",
        "options": [
            "O(n log n)",
            "O(n^2)",
            "O(n)",
            "O(log n)"
        ],
        "answer": "O(n^2)",
        "explanation": "Merge Sort is O(n log n). Quick Sort is O(n^2) in worst case (though avg O(n log n)). Bubble Sort is O(n^2).",
        "frequency_score": 8
    },
    {
        "id": 1112,
        "topic": "Bigtable",
        "companies": [
            "Google",
            "Spotify"
        ],
        "question": "You are designing a Bigtable schema for financial transactions. Queries will primarily be retrieve most recent events globally. Which row key design is optimal? ",
        "options": [
            "DeviceID#Date",
            "Date#DeviceID",
            "ReverseTimestamp#DeviceID",
            "Random#DeviceID"
        ],
        "answer": "ReverseTimestamp#DeviceID",
        "explanation": "Avoid starting with timestamp to prevent hotspots. Use EntityID first for entity-lookup queries. Use ReverseTimestamp for 'latest items' queries globally.",
        "frequency_score": 7
    },
    {
        "id": 1113,
        "topic": "Algorithms",
        "companies": [
            "Google",
            "Amazon",
            "Microsoft"
        ],
        "question": "What is the time complexity of a Merge Sort algorithm in the worst case? ",
        "options": [
            "O(n log n)",
            "O(n^2)",
            "O(n)",
            "O(log n)"
        ],
        "answer": "O(n log n)",
        "explanation": "Merge Sort is O(n log n). Quick Sort is O(n^2) in worst case (though avg O(n log n)). Bubble Sort is O(n^2).",
        "frequency_score": 8
    },
    {
        "id": 1114,
        "topic": "Distributed Systems",
        "companies": [
            "Google",
            "Uber"
        ],
        "question": "You need to update data across two separate microservices (e.g., Payment and Order) transactionally. Traditional 2PC (Two-Phase Commit) is too slow/blocking. What is the modern alternative? ",
        "options": [
            "Saga Pattern",
            "3PC",
            "Write-Ahead Logging",
            "Stored Procedures"
        ],
        "answer": "Saga Pattern",
        "explanation": "The Saga pattern manages distributed transactions as a sequence of local transactions, with compensating actions (undo operations) to handle failures without long locks.",
        "frequency_score": 9
    },
    {
        "id": 1115,
        "topic": "Distributed Systems",
        "companies": [
            "Google",
            "Facebook",
            "Amazon"
        ],
        "question": "You are designing a distributed counter. You need strict consistency (Linearizability) so every read returns the latest write. What is the trade-off according to the CAP theorem? ",
        "options": [
            "Availability must be sacrificed during partitions",
            "Partition Tolerance can be ignored",
            "Latency will decrease",
            "Consistency is free"
        ],
        "answer": "Availability must be sacrificed during partitions",
        "explanation": "In a CP (Consistent + Partition Tolerant) system, if a partition occurs, the system must refuse requests (unavailable) to ensure it doesn't return stale data.",
        "frequency_score": 9
    },
    {
        "id": 1116,
        "topic": "Distributed Systems",
        "companies": [
            "Google",
            "Facebook",
            "Amazon"
        ],
        "question": "You are designing a distributed counter. You need strict consistency (Linearizability) so every read returns the latest write. What is the trade-off according to the CAP theorem? ",
        "options": [
            "Availability must be sacrificed during partitions",
            "Partition Tolerance can be ignored",
            "Latency will decrease",
            "Consistency is free"
        ],
        "answer": "Availability must be sacrificed during partitions",
        "explanation": "In a CP (Consistent + Partition Tolerant) system, if a partition occurs, the system must refuse requests (unavailable) to ensure it doesn't return stale data.",
        "frequency_score": 9
    },
    {
        "id": 1117,
        "topic": "Data Quality",
        "companies": [
            "Google",
            "Netflix",
            "Airbnb"
        ],
        "question": "You use the 'Write-Audit-Publish' (WAP) pattern for data quality. Where does the data go immediately after transformation but BEFORE it is visible to users? ",
        "options": [
            "A hidden 'stage' partition or snapshot",
            "The production table directly",
            "A temporary CSV file",
            "The Dead Letter Queue"
        ],
        "answer": "A hidden 'stage' partition or snapshot",
        "explanation": "In WAP, data is written to a staging area. Audits (queries) run against this area. If pass, the partition is swapped/published to production atomically.",
        "frequency_score": 8
    },
    {
        "id": 1118,
        "topic": "Data pipelines",
        "companies": [
            "Google",
            "Stripe",
            "PayPal"
        ],
        "question": "You are ingesting payment events from an external API that might send duplicates 1% of the time. You need 'Exactly-Once' processing in your warehouse. What is the most robust strategy?",
        "options": [
            "Idempotent ingestion using unique Transaction IDs",
            "Trust the API to never send duplicates",
            "Run a DISTINCT query at the end",
            "Use a low isolation level"
        ],
        "answer": "Idempotent ingestion using unique Transaction IDs",
        "explanation": "Idempotency means applying the same operation multiple times has the same effect as applying it once. Using a unique key (Transaction ID) to merge/deduplicate is the standard.",
        "frequency_score": 9
    },
    {
        "id": 1119,
        "topic": "Cloud Storage",
        "companies": [
            "Google",
            "Snapchat"
        ],
        "question": "You are designing a storage solution for daily analytics content. The requirement is high frequency access. What storage class should you use? ",
        "options": [
            "Standard",
            "Nearline",
            "Coldline",
            "Archive"
        ],
        "answer": "Standard",
        "explanation": "Standard for hot data. Nearline < 1/month. Coldline < 1/quarter. Archive < 1/year.",
        "frequency_score": 6
    },
    {
        "id": 1120,
        "topic": "Apache Spark",
        "companies": [
            "Google",
            "Databricks",
            "Amazon"
        ],
        "question": "In Spark, what is the difference between a Transformation and an Action? ",
        "options": [
            "Transformations are lazy, Actions match strict execution",
            "Actions are lazy, Transformations trigger execution",
            "They are the same",
            "Transformations save to disk, Actions read from disk"
        ],
        "answer": "Transformations are lazy, Actions match strict execution",
        "explanation": "Transformations (like map, filter) build the DAG but do not execute. Actions (like count, collect, save) trigger the actual computation.",
        "frequency_score": 6
    },
    {
        "id": 1121,
        "topic": "System Design",
        "companies": [
            "Google",
            "Discord"
        ],
        "question": "You need to distribute a massive dataset across 1000 nodes. Nodes frequently join and leave. Which partitioning strategy minimizes data movement when the cluster resizes? ",
        "options": [
            "Consistent Hashing",
            "Round-Robin Partitioning",
            "Range Partitioning",
            "Modulo Hashing (Key % N)"
        ],
        "answer": "Consistent Hashing",
        "explanation": "Consistent Hashing maps both data and nodes to a ring. When a node is added/removed, only 1/k keys need to be remapped (neighbors), vs nearly all keys with Modulo Hashing.",
        "frequency_score": 10
    },
    {
        "id": 1122,
        "topic": "Data Quality",
        "companies": [
            "Google",
            "Netflix",
            "Airbnb"
        ],
        "question": "You use the 'Write-Audit-Publish' (WAP) pattern for data quality. Where does the data go immediately after transformation but BEFORE it is visible to users? ",
        "options": [
            "A hidden 'stage' partition or snapshot",
            "The production table directly",
            "A temporary CSV file",
            "The Dead Letter Queue"
        ],
        "answer": "A hidden 'stage' partition or snapshot",
        "explanation": "In WAP, data is written to a staging area. Audits (queries) run against this area. If pass, the partition is swapped/published to production atomically.",
        "frequency_score": 8
    },
    {
        "id": 1123,
        "topic": "Apache Kafka",
        "companies": [
            "Google",
            "LinkedIn"
        ],
        "question": "What happens if a Kafka Consumer Group has more consumers than partitions in the topic? ",
        "options": [
            "Some consumers will be idle",
            "Throughput increases linearly",
            "Kafka automatically creates more partitions",
            "The extra consumers duplicate the data"
        ],
        "answer": "Some consumers will be idle",
        "explanation": "A partition can be consumed by only one consumer within a group at a time. Extra consumers stay idle.",
        "frequency_score": 6
    },
    {
        "id": 1124,
        "topic": "BigQuery",
        "companies": [
            "Google",
            "Spotify",
            "Twitter"
        ],
        "question": "You need to store 1 PB of audit logs data in BigQuery. The data is accessed once a quarter. Which storage class fits best to minimize costs? ",
        "options": [
            "Active Storage",
            "Long-term Storage",
            "Nearline Storage",
            "Coldline Storage"
        ],
        "answer": "Active Storage",
        "explanation": "BigQuery Long-term storage applies automatically after 90 days of no modification, reducing price by ~50%.",
        "frequency_score": 10
    },
    {
        "id": 1125,
        "topic": "Cloud Storage",
        "companies": [
            "Google",
            "Snapchat"
        ],
        "question": "You are designing a storage solution for daily analytics content. The requirement is high frequency access. What storage class should you use? ",
        "options": [
            "Standard",
            "Nearline",
            "Coldline",
            "Archive"
        ],
        "answer": "Standard",
        "explanation": "Standard for hot data. Nearline < 1/month. Coldline < 1/quarter. Archive < 1/year.",
        "frequency_score": 6
    },
    {
        "id": 1126,
        "topic": "System Design",
        "companies": [
            "Google",
            "Pinterest"
        ],
        "question": "You are designing a predictive search engine (like Google Search Autocomplete). You need sub-100ms latency for prefix lookups on billions of queries. Which data structure is optimal? ",
        "options": [
            "Trie (Prefix Tree) stored in memory",
            "B-Tree on disk",
            "Bloom Filter",
            "Inverted Index"
        ],
        "answer": "Trie (Prefix Tree) stored in memory",
        "explanation": "Tries are optimized for prefix lookups. Storing the top variations in memory (or using a distributed cache like Redis) ensures low latency.",
        "frequency_score": 10
    },
    {
        "id": 1127,
        "topic": "Apache Kafka",
        "companies": [
            "Google",
            "LinkedIn"
        ],
        "question": "What happens if a Kafka Consumer Group has more consumers than partitions in the topic? ",
        "options": [
            "Some consumers will be idle",
            "Throughput increases linearly",
            "Kafka automatically creates more partitions",
            "The extra consumers duplicate the data"
        ],
        "answer": "Some consumers will be idle",
        "explanation": "A partition can be consumed by only one consumer within a group at a time. Extra consumers stay idle.",
        "frequency_score": 6
    },
    {
        "id": 1128,
        "topic": "Bigtable",
        "companies": [
            "Google",
            "Spotify"
        ],
        "question": "You are designing a Bigtable schema for IoT events. Queries will primarily be retrieve latest events for a specific entity. Which row key design is optimal? ",
        "options": [
            "DeviceID#Timestamp",
            "Timestamp#DeviceID",
            "ReverseTimestamp#DeviceID",
            "Random#DeviceID"
        ],
        "answer": "DeviceID#Timestamp",
        "explanation": "Avoid starting with timestamp to prevent hotspots. Use EntityID first for entity-lookup queries. Use ReverseTimestamp for 'latest items' queries globally.",
        "frequency_score": 7
    },
    {
        "id": 1129,
        "topic": "Dataflow",
        "companies": [
            "Google",
            "Spotify",
            "New York Times"
        ],
        "question": "You are building a streaming pipeline to process IoT temperature sensors. You need to handle rolling averages every minute for the last hour. What windowing strategy is appropriate? ",
        "options": [
            "Fixed Windows",
            "Sliding Windows",
            "Session Windows",
            "Global Windows"
        ],
        "answer": "Sliding Windows",
        "explanation": "Session windows gap-fill based on activity. Sliding windows overlap (e.g. every 5 min show last 1 hour). Fixed windows are tumbling.",
        "frequency_score": 9
    },
    {
        "id": 1130,
        "topic": "Apache Kafka",
        "companies": [
            "Google",
            "LinkedIn",
            "Uber",
            "Netflix"
        ],
        "question": "You need to ensure strict ordering of messages in Kafka for a specific User ID. How should you configure the producer? ",
        "options": [
            "Use the User ID as the partition key",
            "Use a single partition for the entire topic",
            "Enable idempotent producer",
            "Increase replication factor"
        ],
        "answer": "Use the User ID as the partition key",
        "explanation": "Kafka guarantees ordering WITHIN a partition. Using the Entity ID as the key ensures all messages for that entity go to the same partition.",
        "frequency_score": 6
    },
    {
        "id": 1131,
        "topic": "Bigtable",
        "companies": [
            "Google",
            "Spotify"
        ],
        "question": "You are designing a Bigtable schema for social media posts. Queries will primarily be retrieve latest events for a specific entity. Which row key design is optimal? ",
        "options": [
            "UserID#Date",
            "Date#UserID",
            "ReverseTimestamp#UserID",
            "Random#UserID"
        ],
        "answer": "UserID#Date",
        "explanation": "Avoid starting with timestamp to prevent hotspots. Use EntityID first for entity-lookup queries. Use ReverseTimestamp for 'latest items' queries globally.",
        "frequency_score": 7
    },
    {
        "id": 1132,
        "topic": "Algorithms",
        "companies": [
            "Google",
            "Amazon",
            "Microsoft"
        ],
        "question": "What is the time complexity of a Merge Sort algorithm in the worst case? ",
        "options": [
            "O(n log n)",
            "O(n^2)",
            "O(n)",
            "O(log n)"
        ],
        "answer": "O(n log n)",
        "explanation": "Merge Sort is O(n log n). Quick Sort is O(n^2) in worst case (though avg O(n log n)). Bubble Sort is O(n^2).",
        "frequency_score": 8
    },
    {
        "id": 1133,
        "topic": "Data Structures",
        "companies": [
            "Google",
            "Amazon",
            "Microsoft",
            "Facebook"
        ],
        "question": "You need to implement a look-up service that checks if a user ID exists in a set of 1 billion users with O(1) average time complexity. Which data structure is best? ",
        "options": [
            "Hash Table / HashSet",
            "Binary Search Tree",
            "Linked List",
            "Array"
        ],
        "answer": "Hash Table / HashSet",
        "explanation": "Hash Tables provide O(1) average case lookup. BST is O(log n).",
        "frequency_score": 8
    },
    {
        "id": 1134,
        "topic": "Distributed Systems",
        "companies": [
            "Google",
            "Uber"
        ],
        "question": "You need to update data across two separate microservices (e.g., Payment and Order) transactionally. Traditional 2PC (Two-Phase Commit) is too slow/blocking. What is the modern alternative? ",
        "options": [
            "Saga Pattern",
            "3PC",
            "Write-Ahead Logging",
            "Stored Procedures"
        ],
        "answer": "Saga Pattern",
        "explanation": "The Saga pattern manages distributed transactions as a sequence of local transactions, with compensating actions (undo operations) to handle failures without long locks.",
        "frequency_score": 9
    },
    {
        "id": 1135,
        "topic": "System Design",
        "companies": [
            "Google",
            "Pinterest"
        ],
        "question": "You are designing a predictive search engine (like Google Search Autocomplete). You need sub-100ms latency for prefix lookups on billions of queries. Which data structure is optimal? ",
        "options": [
            "Trie (Prefix Tree) stored in memory",
            "B-Tree on disk",
            "Bloom Filter",
            "Inverted Index"
        ],
        "answer": "Trie (Prefix Tree) stored in memory",
        "explanation": "Tries are optimized for prefix lookups. Storing the top variations in memory (or using a distributed cache like Redis) ensures low latency.",
        "frequency_score": 10
    },
    {
        "id": 1136,
        "topic": "Apache Spark",
        "companies": [
            "Google",
            "Databricks",
            "Amazon"
        ],
        "question": "In Spark, what is the difference between a Transformation and an Action? ",
        "options": [
            "Transformations are lazy, Actions match strict execution",
            "Actions are lazy, Transformations trigger execution",
            "They are the same",
            "Transformations save to disk, Actions read from disk"
        ],
        "answer": "Transformations are lazy, Actions match strict execution",
        "explanation": "Transformations (like map, filter) build the DAG but do not execute. Actions (like count, collect, save) trigger the actual computation.",
        "frequency_score": 6
    },
    {
        "id": 1137,
        "topic": "Data Structures",
        "companies": [
            "Google",
            "Amazon",
            "Microsoft",
            "Facebook"
        ],
        "question": "You need to implement a look-up service that checks if a user ID exists in a set of 1 billion users with O(1) average time complexity. Which data structure is best? ",
        "options": [
            "Hash Table / HashSet",
            "Binary Search Tree",
            "Linked List",
            "Array"
        ],
        "answer": "Hash Table / HashSet",
        "explanation": "Hash Tables provide O(1) average case lookup. BST is O(log n).",
        "frequency_score": 8
    },
    {
        "id": 1138,
        "topic": "IAM",
        "companies": [
            "Google"
        ],
        "question": "A developer needs to deploy Cloud Functions in a production project. Following the principle of least privilege, which role should you grant? ",
        "options": [
            "Viewer",
            "Editor",
            "Owner",
            "Storage Object Creator"
        ],
        "answer": "Storage Object Creator",
        "explanation": "Always prefer predefined specific roles (like BigQuery Data Viewer, Storage Object Admin) over basic roles (Viewer/Editor/Owner) to ensure least privilege.",
        "frequency_score": 9
    },
    {
        "id": 1139,
        "topic": "Cloud Storage",
        "companies": [
            "Google",
            "Snapchat"
        ],
        "question": "You are designing a storage solution for profile pictures. The requirement is access once a year. What storage class should you use? ",
        "options": [
            "Standard",
            "Nearline",
            "Coldline",
            "Archive"
        ],
        "answer": "Archive",
        "explanation": "Standard for hot data. Nearline < 1/month. Coldline < 1/quarter. Archive < 1/year.",
        "frequency_score": 6
    },
    {
        "id": 1140,
        "topic": "BigQuery",
        "companies": [
            "Google",
            "Spotify",
            "Twitter"
        ],
        "question": "You need to store 500 TB of transaction records data in BigQuery. The data is accessed rarely (every 6 months). Which storage class fits best to minimize costs? ",
        "options": [
            "Active Storage",
            "Long-term Storage",
            "Nearline Storage",
            "Coldline Storage"
        ],
        "answer": "Long-term Storage",
        "explanation": "BigQuery Long-term storage applies automatically after 90 days of no modification, reducing price by ~50%.",
        "frequency_score": 10
    },
    {
        "id": 1141,
        "topic": "System Design",
        "companies": [
            "Google",
            "YouTube",
            "TikTok"
        ],
        "question": "You are building a video recommendation engine. The 'Candidate Generation' phase filters millions of videos down to hundreds. Which approach is valid for this phase? ",
        "options": [
            "Collaborative Filtering / Two-Tower Neural Network",
            "Heavy learning-to-rank model",
            "A/B Testing",
            "Linear Regression"
        ],
        "answer": "Collaborative Filtering / Two-Tower Neural Network",
        "explanation": "Candidate generation must be fast and lightweight (high recall). Complex ranking models (high precision) are used only on the smaller subset of candidates.",
        "frequency_score": 10
    },
    {
        "id": 1142,
        "topic": "Distributed Systems",
        "companies": [
            "Google",
            "Facebook",
            "Amazon"
        ],
        "question": "You are designing a distributed counter. You need strict consistency (Linearizability) so every read returns the latest write. What is the trade-off according to the CAP theorem? ",
        "options": [
            "Availability must be sacrificed during partitions",
            "Partition Tolerance can be ignored",
            "Latency will decrease",
            "Consistency is free"
        ],
        "answer": "Availability must be sacrificed during partitions",
        "explanation": "In a CP (Consistent + Partition Tolerant) system, if a partition occurs, the system must refuse requests (unavailable) to ensure it doesn't return stale data.",
        "frequency_score": 9
    },
    {
        "id": 1143,
        "topic": "Dataflow",
        "companies": [
            "Google",
            "Spotify",
            "New York Times"
        ],
        "question": "You are building a streaming pipeline to process IoT temperature sensors. You need to handle rolling averages every minute for the last hour. What windowing strategy is appropriate? ",
        "options": [
            "Fixed Windows",
            "Sliding Windows",
            "Session Windows",
            "Global Windows"
        ],
        "answer": "Sliding Windows",
        "explanation": "Session windows gap-fill based on activity. Sliding windows overlap (e.g. every 5 min show last 1 hour). Fixed windows are tumbling.",
        "frequency_score": 9
    },
    {
        "id": 1144,
        "topic": "Apache Kafka",
        "companies": [
            "Google",
            "LinkedIn"
        ],
        "question": "What happens if a Kafka Consumer Group has more consumers than partitions in the topic? ",
        "options": [
            "Some consumers will be idle",
            "Throughput increases linearly",
            "Kafka automatically creates more partitions",
            "The extra consumers duplicate the data"
        ],
        "answer": "Some consumers will be idle",
        "explanation": "A partition can be consumed by only one consumer within a group at a time. Extra consumers stay idle.",
        "frequency_score": 6
    },
    {
        "id": 1145,
        "topic": "Distributed Systems",
        "companies": [
            "Google",
            "Uber"
        ],
        "question": "You need to update data across two separate microservices (e.g., Payment and Order) transactionally. Traditional 2PC (Two-Phase Commit) is too slow/blocking. What is the modern alternative? ",
        "options": [
            "Saga Pattern",
            "3PC",
            "Write-Ahead Logging",
            "Stored Procedures"
        ],
        "answer": "Saga Pattern",
        "explanation": "The Saga pattern manages distributed transactions as a sequence of local transactions, with compensating actions (undo operations) to handle failures without long locks.",
        "frequency_score": 9
    },
    {
        "id": 1146,
        "topic": "Distributed Systems",
        "companies": [
            "Google",
            "Uber"
        ],
        "question": "You need to update data across two separate microservices (e.g., Payment and Order) transactionally. Traditional 2PC (Two-Phase Commit) is too slow/blocking. What is the modern alternative? ",
        "options": [
            "Saga Pattern",
            "3PC",
            "Write-Ahead Logging",
            "Stored Procedures"
        ],
        "answer": "Saga Pattern",
        "explanation": "The Saga pattern manages distributed transactions as a sequence of local transactions, with compensating actions (undo operations) to handle failures without long locks.",
        "frequency_score": 9
    },
    {
        "id": 1147,
        "topic": "Apache Kafka",
        "companies": [
            "Google",
            "LinkedIn",
            "Uber",
            "Netflix"
        ],
        "question": "You need to ensure strict ordering of messages in Kafka for a specific Transaction ID. How should you configure the producer? ",
        "options": [
            "Use the Transaction ID as the partition key",
            "Use a single partition for the entire topic",
            "Enable idempotent producer",
            "Increase replication factor"
        ],
        "answer": "Use the Transaction ID as the partition key",
        "explanation": "Kafka guarantees ordering WITHIN a partition. Using the Entity ID as the key ensures all messages for that entity go to the same partition.",
        "frequency_score": 6
    },
    {
        "id": 1148,
        "topic": "IAM",
        "companies": [
            "Google"
        ],
        "question": "A developer needs to view BigQuery datasets in a production project. Following the principle of least privilege, which role should you grant? ",
        "options": [
            "Viewer",
            "Editor",
            "Owner",
            "Cloud Functions Developer"
        ],
        "answer": "Cloud Functions Developer",
        "explanation": "Always prefer predefined specific roles (like BigQuery Data Viewer, Storage Object Admin) over basic roles (Viewer/Editor/Owner) to ensure least privilege.",
        "frequency_score": 9
    },
    {
        "id": 1149,
        "topic": "BigQuery",
        "companies": [
            "Google",
            "Spotify",
            "Twitter"
        ],
        "question": "You need to store 2 PB of sensor metrics data in BigQuery. The data is accessed rarely (every 6 months). Which storage class fits best to minimize costs? ",
        "options": [
            "Active Storage",
            "Long-term Storage",
            "Nearline Storage",
            "Coldline Storage"
        ],
        "answer": "Long-term Storage",
        "explanation": "BigQuery Long-term storage applies automatically after 90 days of no modification, reducing price by ~50%.",
        "frequency_score": 10
    },
    {
        "id": 1150,
        "topic": "Dataflow",
        "companies": [
            "Google",
            "Spotify",
            "New York Times"
        ],
        "question": "You are building a streaming pipeline to process server logs. You need to handle rolling averages every minute for the last hour. What windowing strategy is appropriate? ",
        "options": [
            "Fixed Windows",
            "Sliding Windows",
            "Session Windows",
            "Global Windows"
        ],
        "answer": "Sliding Windows",
        "explanation": "Session windows gap-fill based on activity. Sliding windows overlap (e.g. every 5 min show last 1 hour). Fixed windows are tumbling.",
        "frequency_score": 9
    },
    {
        "id": 1151,
        "topic": "Apache Spark",
        "companies": [
            "Google",
            "Databricks",
            "Facebook",
            "Netflix"
        ],
        "question": "You are optimizing a Spark job that is suffering from data skew. You are joining a large skewed table with a small reference table. Which technique is most effective? ",
        "options": [
            "Salting the key",
            "Increasing the number of executors",
            "Using a larger instance type",
            "Broadcasting the large table"
        ],
        "answer": "Salting the key",
        "explanation": "Salting adds a random prefix to the skewed key to distribute it. Broadcasting is best for Skewed Joins where one table is small.",
        "frequency_score": 6
    },
    {
        "id": 1152,
        "topic": "Data Structures",
        "companies": [
            "Google",
            "Amazon",
            "Microsoft",
            "Facebook"
        ],
        "question": "You need to implement a look-up service that checks if a user ID exists in a set of 1 billion users with O(1) average time complexity. Which data structure is best? ",
        "options": [
            "Hash Table / HashSet",
            "Binary Search Tree",
            "Linked List",
            "Array"
        ],
        "answer": "Hash Table / HashSet",
        "explanation": "Hash Tables provide O(1) average case lookup. BST is O(log n).",
        "frequency_score": 8
    },
    {
        "id": 1153,
        "topic": "Data Quality",
        "companies": [
            "Google",
            "Netflix",
            "Airbnb"
        ],
        "question": "You use the 'Write-Audit-Publish' (WAP) pattern for data quality. Where does the data go immediately after transformation but BEFORE it is visible to users? ",
        "options": [
            "A hidden 'stage' partition or snapshot",
            "The production table directly",
            "A temporary CSV file",
            "The Dead Letter Queue"
        ],
        "answer": "A hidden 'stage' partition or snapshot",
        "explanation": "In WAP, data is written to a staging area. Audits (queries) run against this area. If pass, the partition is swapped/published to production atomically.",
        "frequency_score": 8
    },
    {
        "id": 1154,
        "topic": "Data pipelines",
        "companies": [
            "Google",
            "Stripe",
            "PayPal"
        ],
        "question": "You are ingesting payment events from an external API that might send duplicates 1% of the time. You need 'Exactly-Once' processing in your warehouse. What is the most robust strategy? ",
        "options": [
            "Idempotent ingestion using unique Transaction IDs",
            "Trust the API to never send duplicates",
            "Run a DISTINCT query at the end",
            "Use a low isolation level"
        ],
        "answer": "Idempotent ingestion using unique Transaction IDs",
        "explanation": "Idempotency means applying the same operation multiple times has the same effect as applying it once. Using a unique key (Transaction ID) to merge/deduplicate is the standard.",
        "frequency_score": 9
    },
    {
        "id": 1155,
        "topic": "BigQuery",
        "companies": [
            "Google",
            "Spotify",
            "Twitter"
        ],
        "question": "You need to store 50 TB of clickstream data data in BigQuery. The data is accessed continuously. Which storage class fits best to minimize costs? ",
        "options": [
            "Active Storage",
            "Long-term Storage",
            "Nearline Storage",
            "Coldline Storage"
        ],
        "answer": "Active Storage",
        "explanation": "BigQuery Long-term storage applies automatically after 90 days of no modification, reducing price by ~50%.",
        "frequency_score": 10
    },
    {
        "id": 1156,
        "topic": "Apache Kafka",
        "companies": [
            "Google",
            "LinkedIn"
        ],
        "question": "What happens if a Kafka Consumer Group has more consumers than partitions in the topic? ",
        "options": [
            "Some consumers will be idle",
            "Throughput increases linearly",
            "Kafka automatically creates more partitions",
            "The extra consumers duplicate the data"
        ],
        "answer": "Some consumers will be idle",
        "explanation": "A partition can be consumed by only one consumer within a group at a time. Extra consumers stay idle.",
        "frequency_score": 6
    },
    {
        "id": 1157,
        "topic": "Cloud Storage",
        "companies": [
            "Google",
            "Snapchat"
        ],
        "question": "You are designing a storage solution for disaster recovery backups. The requirement is access once a month. What storage class should you use? ",
        "options": [
            "Standard",
            "Nearline",
            "Coldline",
            "Archive"
        ],
        "answer": "Nearline",
        "explanation": "Standard for hot data. Nearline < 1/month. Coldline < 1/quarter. Archive < 1/year.",
        "frequency_score": 6
    },
    {
        "id": 1158,
        "topic": "System Design",
        "companies": [
            "Google",
            "Discord"
        ],
        "question": "You need to distribute a massive dataset across 1000 nodes. Nodes frequently join and leave. Which partitioning strategy minimizes data movement when the cluster resizes? ",
        "options": [
            "Consistent Hashing",
            "Round-Robin Partitioning",
            "Range Partitioning",
            "Modulo Hashing (Key % N)"
        ],
        "answer": "Consistent Hashing",
        "explanation": "Consistent Hashing maps both data and nodes to a ring. When a node is added/removed, only 1/k keys need to be remapped (neighbors), vs nearly all keys with Modulo Hashing.",
        "frequency_score": 10
    },
    {
        "id": 1159,
        "topic": "IAM",
        "companies": [
            "Google"
        ],
        "question": "A developer needs to view BigQuery datasets in a production project. Following the principle of least privilege, which role should you grant? ",
        "options": [
            "Viewer",
            "Editor",
            "Owner",
            "Storage Object Creator"
        ],
        "answer": "Storage Object Creator",
        "explanation": "Always prefer predefined specific roles (like BigQuery Data Viewer, Storage Object Admin) over basic roles (Viewer/Editor/Owner) to ensure least privilege.",
        "frequency_score": 9
    },
    {
        "id": 1160,
        "topic": "Bigtable",
        "companies": [
            "Google",
            "Spotify"
        ],
        "question": "You are designing a Bigtable schema for financial transactions. Queries will primarily be retrieve latest events for a specific entity. Which row key design is optimal? ",
        "options": [
            "DeviceID#Timestamp",
            "Timestamp#DeviceID",
            "ReverseTimestamp#DeviceID",
            "Random#DeviceID"
        ],
        "answer": "DeviceID#Timestamp",
        "explanation": "Avoid starting with timestamp to prevent hotspots. Use EntityID first for entity-lookup queries. Use ReverseTimestamp for 'latest items' queries globally.",
        "frequency_score": 7
    },
    {
        "id": 1161,
        "topic": "Distributed Systems",
        "companies": [
            "Google",
            "LinkedIn"
        ],
        "question": "Which replication strategy allows multiple nodes to accept writes, increasing write throughput but introducing potential update conflicts? ",
        "options": [
            "Multi-Leader (Master-Master) Replication",
            "Single-Leader Replication",
            "Leaderless Replication (Dynamo-style)",
            "Read Replicas only"
        ],
        "answer": "Multi-Leader (Master-Master) Replication",
        "explanation": "Multi-Leader replication allows writes at multiple datacenters/nodes. It improves performance and local availability but requires conflict resolution logic (e.g., Last Write Wins).",
        "frequency_score": 9
    },
    {
        "id": 1162,
        "topic": "Bigtable",
        "companies": [
            "Google",
            "Spotify"
        ],
        "question": "You are designing a Bigtable schema for financial transactions. Queries will primarily be retrieve latest events for a specific entity. Which row key design is optimal? ",
        "options": [
            "DeviceID#Timestamp",
            "Timestamp#DeviceID",
            "ReverseTimestamp#DeviceID",
            "Random#DeviceID"
        ],
        "answer": "DeviceID#Timestamp",
        "explanation": "Avoid starting with timestamp to prevent hotspots. Use EntityID first for entity-lookup queries. Use ReverseTimestamp for 'latest items' queries globally.",
        "frequency_score": 7
    },
    {
        "id": 1163,
        "topic": "Apache Spark",
        "companies": [
            "Google",
            "Databricks",
            "Facebook",
            "Netflix"
        ],
        "question": "You are optimizing a Spark job that is suffering from data skew. You are joining a large skewed table with a small reference table. Which technique is most effective? ",
        "options": [
            "Salting the key",
            "Increasing the number of executors",
            "Using a larger instance type",
            "Broadcasting the large table"
        ],
        "answer": "Salting the key",
        "explanation": "Salting adds a random prefix to the skewed key to distribute it. Broadcasting is best for Skewed Joins where one table is small.",
        "frequency_score": 6
    },
    {
        "id": 1164,
        "topic": "BigQuery",
        "companies": [
            "Google",
            "Spotify",
            "Twitter"
        ],
        "question": "You need to store 50 TB of audit logs data in BigQuery. The data is accessed once a quarter. Which storage class fits best to minimize costs?",
        "options": [
            "Active Storage",
            "Long-term Storage",
            "Nearline Storage",
            "Coldline Storage"
        ],
        "answer": "Active Storage",
        "explanation": "BigQuery Long-term storage applies automatically after 90 days of no modification, reducing price by ~50%.",
        "frequency_score": 10
    },
    {
        "id": 1165,
        "topic": "Apache Spark",
        "companies": [
            "Google",
            "Databricks",
            "Facebook",
            "Netflix"
        ],
        "question": "You are optimizing a Spark job that is suffering from data skew. You are joining a large skewed table with a small reference table. Which technique is most effective? ",
        "options": [
            "Salting the key",
            "Increasing the number of executors",
            "Using a larger instance type",
            "Broadcasting the large table"
        ],
        "answer": "Salting the key",
        "explanation": "Salting adds a random prefix to the skewed key to distribute it. Broadcasting is best for Skewed Joins where one table is small.",
        "frequency_score": 6
    },
    {
        "id": 1166,
        "topic": "System Design",
        "companies": [
            "Google",
            "YouTube",
            "TikTok"
        ],
        "question": "You are building a video recommendation engine. The 'Candidate Generation' phase filters millions of videos down to hundreds. Which approach is valid for this phase? ",
        "options": [
            "Collaborative Filtering / Two-Tower Neural Network",
            "Heavy learning-to-rank model",
            "A/B Testing",
            "Linear Regression"
        ],
        "answer": "Collaborative Filtering / Two-Tower Neural Network",
        "explanation": "Candidate generation must be fast and lightweight (high recall). Complex ranking models (high precision) are used only on the smaller subset of candidates.",
        "frequency_score": 10
    },
    {
        "id": 1167,
        "topic": "Data pipelines",
        "companies": [
            "Google",
            "Stripe",
            "PayPal"
        ],
        "question": "You are ingesting payment events from an external API that might send duplicates 1% of the time. You need 'Exactly-Once' processing in your warehouse. What is the most robust strategy? ",
        "options": [
            "Idempotent ingestion using unique Transaction IDs",
            "Trust the API to never send duplicates",
            "Run a DISTINCT query at the end",
            "Use a low isolation level"
        ],
        "answer": "Idempotent ingestion using unique Transaction IDs",
        "explanation": "Idempotency means applying the same operation multiple times has the same effect as applying it once. Using a unique key (Transaction ID) to merge/deduplicate is the standard.",
        "frequency_score": 9
    },
    {
        "id": 1168,
        "topic": "Cloud Spanner",
        "companies": [
            "Google",
            "Uber",
            "Pokemon GO"
        ],
        "question": "You are designing a global banking ledger. You require strong consistency and 99.999% availability. Which database service should you choose? ",
        "options": [
            "Cloud Spanner",
            "Cloud SQL",
            "Bigtable",
            "Firestore"
        ],
        "answer": "Cloud Spanner",
        "explanation": "Cloud Spanner is the only service providing global strong consistency and horizontal scalability with relational semantics (SQL).",
        "frequency_score": 8
    },
    {
        "id": 1169,
        "topic": "Data Structures",
        "companies": [
            "Google",
            "Amazon",
            "Microsoft",
            "Facebook"
        ],
        "question": "You need to implement a look-up service that checks if a user ID exists in a set of 1 billion users with O(1) average time complexity. Which data structure is best? ",
        "options": [
            "Hash Table / HashSet",
            "Binary Search Tree",
            "Linked List",
            "Array"
        ],
        "answer": "Hash Table / HashSet",
        "explanation": "Hash Tables provide O(1) average case lookup. BST is O(log n).",
        "frequency_score": 8
    },
    {
        "id": 1170,
        "topic": "Cloud Storage",
        "companies": [
            "Google",
            "Snapchat"
        ],
        "question": "You are designing a storage solution for regulatory archives. The requirement is access once a month. What storage class should you use? ",
        "options": [
            "Standard",
            "Nearline",
            "Coldline",
            "Archive"
        ],
        "answer": "Nearline",
        "explanation": "Standard for hot data. Nearline < 1/month. Coldline < 1/quarter. Archive < 1/year.",
        "frequency_score": 6
    },
    {
        "id": 1171,
        "topic": "System Design",
        "companies": [
            "Google",
            "Pinterest"
        ],
        "question": "You are designing a predictive search engine (like Google Search Autocomplete). You need sub-100ms latency for prefix lookups on billions of queries. Which data structure is optimal? ",
        "options": [
            "Trie (Prefix Tree) stored in memory",
            "B-Tree on disk",
            "Bloom Filter",
            "Inverted Index"
        ],
        "answer": "Trie (Prefix Tree) stored in memory",
        "explanation": "Tries are optimized for prefix lookups. Storing the top variations in memory (or using a distributed cache like Redis) ensures low latency.",
        "frequency_score": 10
    },
    {
        "id": 1172,
        "topic": "BigQuery",
        "companies": [
            "Google",
            "Spotify",
            "Twitter"
        ],
        "question": "You need to store 500 TB of transaction records data in BigQuery. The data is accessed continuously. Which storage class fits best to minimize costs? ",
        "options": [
            "Active Storage",
            "Long-term Storage",
            "Nearline Storage",
            "Coldline Storage"
        ],
        "answer": "Active Storage",
        "explanation": "BigQuery Long-term storage applies automatically after 90 days of no modification, reducing price by ~50%.",
        "frequency_score": 10
    },
    {
        "id": 1173,
        "topic": "Distributed Systems",
        "companies": [
            "Google",
            "Facebook",
            "Amazon"
        ],
        "question": "You are designing a distributed counter. You need strict consistency (Linearizability) so every read returns the latest write. What is the trade-off according to the CAP theorem? ",
        "options": [
            "Availability must be sacrificed during partitions",
            "Partition Tolerance can be ignored",
            "Latency will decrease",
            "Consistency is free"
        ],
        "answer": "Availability must be sacrificed during partitions",
        "explanation": "In a CP (Consistent + Partition Tolerant) system, if a partition occurs, the system must refuse requests (unavailable) to ensure it doesn't return stale data.",
        "frequency_score": 9
    },
    {
        "id": 1174,
        "topic": "Apache Spark",
        "companies": [
            "Google",
            "Databricks",
            "Facebook",
            "Netflix"
        ],
        "question": "You are optimizing a Spark job that is suffering from data skew. One task takes 10x longer than others during a wide transformation. Which technique is most effective? ",
        "options": [
            "Salting the key",
            "Increasing the number of executors",
            "Using a larger instance type",
            "Broadcasting the large table"
        ],
        "answer": "Salting the key",
        "explanation": "Salting adds a random prefix to the skewed key to distribute it. Broadcasting is best for Skewed Joins where one table is small.",
        "frequency_score": 6
    },
    {
        "id": 1175,
        "topic": "Apache Spark",
        "companies": [
            "Google",
            "Databricks",
            "Amazon"
        ],
        "question": "In Spark, what is the difference between a Transformation and an Action? ",
        "options": [
            "Transformations are lazy, Actions match strict execution",
            "Actions are lazy, Transformations trigger execution",
            "They are the same",
            "Transformations save to disk, Actions read from disk"
        ],
        "answer": "Transformations are lazy, Actions match strict execution",
        "explanation": "Transformations (like map, filter) build the DAG but do not execute. Actions (like count, collect, save) trigger the actual computation.",
        "frequency_score": 6
    },
    {
        "id": 1176,
        "topic": "Data Quality",
        "companies": [
            "Google",
            "Netflix",
            "Airbnb"
        ],
        "question": "You use the 'Write-Audit-Publish' (WAP) pattern for data quality. Where does the data go immediately after transformation but BEFORE it is visible to users? ",
        "options": [
            "A hidden 'stage' partition or snapshot",
            "The production table directly",
            "A temporary CSV file",
            "The Dead Letter Queue"
        ],
        "answer": "A hidden 'stage' partition or snapshot",
        "explanation": "In WAP, data is written to a staging area. Audits (queries) run against this area. If pass, the partition is swapped/published to production atomically.",
        "frequency_score": 8
    },
    {
        "id": 1177,
        "topic": "Distributed Systems",
        "companies": [
            "Google",
            "Uber"
        ],
        "question": "You need to update data across two separate microservices (e.g., Payment and Order) transactionally. Traditional 2PC (Two-Phase Commit) is too slow/blocking. What is the modern alternative? ",
        "options": [
            "Saga Pattern",
            "3PC",
            "Write-Ahead Logging",
            "Stored Procedures"
        ],
        "answer": "Saga Pattern",
        "explanation": "The Saga pattern manages distributed transactions as a sequence of local transactions, with compensating actions (undo operations) to handle failures without long locks.",
        "frequency_score": 9
    },
    {
        "id": 1178,
        "topic": "Apache Spark",
        "companies": [
            "Google",
            "Databricks",
            "Facebook",
            "Netflix"
        ],
        "question": "You are optimizing a Spark job that is suffering from data skew. You are joining a large skewed table with a small reference table. Which technique is most effective? ",
        "options": [
            "Salting the key",
            "Increasing the number of executors",
            "Using a larger instance type",
            "Broadcasting the large table"
        ],
        "answer": "Salting the key",
        "explanation": "Salting adds a random prefix to the skewed key to distribute it. Broadcasting is best for Skewed Joins where one table is small.",
        "frequency_score": 6
    },
    {
        "id": 1179,
        "topic": "Distributed Systems",
        "companies": [
            "Google",
            "Uber"
        ],
        "question": "You need to update data across two separate microservices (e.g., Payment and Order) transactionally. Traditional 2PC (Two-Phase Commit) is too slow/blocking. What is the modern alternative? ",
        "options": [
            "Saga Pattern",
            "3PC",
            "Write-Ahead Logging",
            "Stored Procedures"
        ],
        "answer": "Saga Pattern",
        "explanation": "The Saga pattern manages distributed transactions as a sequence of local transactions, with compensating actions (undo operations) to handle failures without long locks.",
        "frequency_score": 9
    },
    {
        "id": 1180,
        "topic": "Distributed Systems",
        "companies": [
            "Google",
            "Facebook",
            "Amazon"
        ],
        "question": "You are designing a distributed counter. You need strict consistency (Linearizability) so every read returns the latest write. What is the trade-off according to the CAP theorem? ",
        "options": [
            "Availability must be sacrificed during partitions",
            "Partition Tolerance can be ignored",
            "Latency will decrease",
            "Consistency is free"
        ],
        "answer": "Availability must be sacrificed during partitions",
        "explanation": "In a CP (Consistent + Partition Tolerant) system, if a partition occurs, the system must refuse requests (unavailable) to ensure it doesn't return stale data.",
        "frequency_score": 9
    },
    {
        "id": 1181,
        "topic": "Apache Kafka",
        "companies": [
            "Google",
            "LinkedIn"
        ],
        "question": "What happens if a Kafka Consumer Group has more consumers than partitions in the topic? ",
        "options": [
            "Some consumers will be idle",
            "Throughput increases linearly",
            "Kafka automatically creates more partitions",
            "The extra consumers duplicate the data"
        ],
        "answer": "Some consumers will be idle",
        "explanation": "A partition can be consumed by only one consumer within a group at a time. Extra consumers stay idle.",
        "frequency_score": 6
    },
    {
        "id": 1182,
        "topic": "Pub/Sub",
        "companies": [
            "Google",
            "Uber"
        ],
        "question": "Your application publishes 1 million/sec messages to Pub/Sub. You observe increased end-to-end latency and growing backlog. What is the most likely cause? ",
        "options": [
            "Subscribers are too slow (backlog)",
            "Publisher quota exceeded",
            "Message size too large",
            "Ordering keys are causing hotspots"
        ],
        "answer": "Subscribers are too slow (backlog)",
        "explanation": "If using ordering keys, high throughput on a single key can limit scalability (1MB/s limit per key). Slow subscribers cause increased backlog.",
        "frequency_score": 7
    },
    {
        "id": 1183,
        "topic": "Algorithms",
        "companies": [
            "Google",
            "Amazon",
            "Microsoft"
        ],
        "question": "What is the time complexity of a Bubble Sort algorithm in the worst case? ",
        "options": [
            "O(n log n)",
            "O(n^2)",
            "O(n)",
            "O(log n)"
        ],
        "answer": "O(n^2)",
        "explanation": "Merge Sort is O(n log n). Quick Sort is O(n^2) in worst case (though avg O(n log n)). Bubble Sort is O(n^2).",
        "frequency_score": 8
    },
    {
        "id": 1184,
        "topic": "System Design",
        "companies": [
            "Google",
            "Discord"
        ],
        "question": "You need to distribute a massive dataset across 1000 nodes. Nodes frequently join and leave. Which partitioning strategy minimizes data movement when the cluster resizes? ",
        "options": [
            "Consistent Hashing",
            "Round-Robin Partitioning",
            "Range Partitioning",
            "Modulo Hashing (Key % N)"
        ],
        "answer": "Consistent Hashing",
        "explanation": "Consistent Hashing maps both data and nodes to a ring. When a node is added/removed, only 1/k keys need to be remapped (neighbors), vs nearly all keys with Modulo Hashing.",
        "frequency_score": 10
    },
    {
        "id": 1185,
        "topic": "Distributed Systems",
        "companies": [
            "Google",
            "Facebook",
            "Amazon"
        ],
        "question": "You are designing a distributed counter. You need strict consistency (Linearizability) so every read returns the latest write. What is the trade-off according to the CAP theorem? ",
        "options": [
            "Availability must be sacrificed during partitions",
            "Partition Tolerance can be ignored",
            "Latency will decrease",
            "Consistency is free"
        ],
        "answer": "Availability must be sacrificed during partitions",
        "explanation": "In a CP (Consistent + Partition Tolerant) system, if a partition occurs, the system must refuse requests (unavailable) to ensure it doesn't return stale data.",
        "frequency_score": 9
    },
    {
        "id": 1186,
        "topic": "Bigtable",
        "companies": [
            "Google",
            "Spotify"
        ],
        "question": "You are designing a Bigtable schema for financial transactions. Queries will primarily be retrieve latest events for a specific entity. Which row key design is optimal? ",
        "options": [
            "UserID#Timestamp",
            "Timestamp#UserID",
            "ReverseTimestamp#UserID",
            "Random#UserID"
        ],
        "answer": "UserID#Timestamp",
        "explanation": "Avoid starting with timestamp to prevent hotspots. Use EntityID first for entity-lookup queries. Use ReverseTimestamp for 'latest items' queries globally.",
        "frequency_score": 7
    },
    {
        "id": 1187,
        "topic": "Apache Spark",
        "companies": [
            "Google",
            "Databricks",
            "Facebook",
            "Netflix"
        ],
        "question": "You are optimizing a Spark job that is suffering from data skew. You are joining a large skewed table with a small reference table. Which technique is most effective? ",
        "options": [
            "Salting the key",
            "Increasing the number of executors",
            "Using a larger instance type",
            "Broadcasting the large table"
        ],
        "answer": "Salting the key",
        "explanation": "Salting adds a random prefix to the skewed key to distribute it. Broadcasting is best for Skewed Joins where one table is small.",
        "frequency_score": 6
    },
    {
        "id": 1188,
        "topic": "System Design",
        "companies": [
            "Google"
        ],
        "question": "You need to store unstructured images and videos for ML training, but also need rich metadata (tags, unexpected attributes) for querying. What architecture fits? ",
        "options": [
            "Object Store (GCS) for blobs + NoSQL (Firestore) for metadata",
            "BigQuery for everything",
            "Bigtable for blobs",
            "MySQL for everything"
        ],
        "answer": "Object Store (GCS) for blobs + NoSQL (Firestore) for metadata",
        "explanation": "Store heavy blobs in Object Storage (GCS) for cost/performance. Store flexible, schemaless metadata in a NoSQL document store (Firestore/Datastore) for fast querying.",
        "frequency_score": 10
    },
    {
        "id": 1189,
        "topic": "Cloud Spanner",
        "companies": [
            "Google",
            "Uber",
            "Pokemon GO"
        ],
        "question": "You are designing a global banking ledger. You require strong consistency and 99.999% availability. Which database service should you choose? ",
        "options": [
            "Cloud Spanner",
            "Cloud SQL",
            "Bigtable",
            "Firestore"
        ],
        "answer": "Cloud Spanner",
        "explanation": "Cloud Spanner is the only service providing global strong consistency and horizontal scalability with relational semantics (SQL).",
        "frequency_score": 8
    },
    {
        "id": 1190,
        "topic": "Apache Kafka",
        "companies": [
            "Google",
            "LinkedIn"
        ],
        "question": "What happens if a Kafka Consumer Group has more consumers than partitions in the topic? ",
        "options": [
            "Some consumers will be idle",
            "Throughput increases linearly",
            "Kafka automatically creates more partitions",
            "The extra consumers duplicate the data"
        ],
        "answer": "Some consumers will be idle",
        "explanation": "A partition can be consumed by only one consumer within a group at a time. Extra consumers stay idle.",
        "frequency_score": 6
    },
    {
        "id": 1191,
        "topic": "System Design",
        "companies": [
            "Google",
            "YouTube",
            "TikTok"
        ],
        "question": "You are building a video recommendation engine. The 'Candidate Generation' phase filters millions of videos down to hundreds. Which approach is valid for this phase? ",
        "options": [
            "Collaborative Filtering / Two-Tower Neural Network",
            "Heavy learning-to-rank model",
            "A/B Testing",
            "Linear Regression"
        ],
        "answer": "Collaborative Filtering / Two-Tower Neural Network",
        "explanation": "Candidate generation must be fast and lightweight (high recall). Complex ranking models (high precision) are used only on the smaller subset of candidates.",
        "frequency_score": 10
    },
    {
        "id": 1192,
        "topic": "Distributed Systems",
        "companies": [
            "Google",
            "Uber"
        ],
        "question": "You need to update data across two separate microservices (e.g., Payment and Order) transactionally. Traditional 2PC (Two-Phase Commit) is too slow/blocking. What is the modern alternative? ",
        "options": [
            "Saga Pattern",
            "3PC",
            "Write-Ahead Logging",
            "Stored Procedures"
        ],
        "answer": "Saga Pattern",
        "explanation": "The Saga pattern manages distributed transactions as a sequence of local transactions, with compensating actions (undo operations) to handle failures without long locks.",
        "frequency_score": 9
    },
    {
        "id": 1193,
        "topic": "System Design",
        "companies": [
            "Google",
            "Discord"
        ],
        "question": "You need to distribute a massive dataset across 1000 nodes. Nodes frequently join and leave. Which partitioning strategy minimizes data movement when the cluster resizes? ",
        "options": [
            "Consistent Hashing",
            "Round-Robin Partitioning",
            "Range Partitioning",
            "Modulo Hashing (Key % N)"
        ],
        "answer": "Consistent Hashing",
        "explanation": "Consistent Hashing maps both data and nodes to a ring. When a node is added/removed, only 1/k keys need to be remapped (neighbors), vs nearly all keys with Modulo Hashing.",
        "frequency_score": 10
    },
    {
        "id": 1194,
        "topic": "Distributed Systems",
        "companies": [
            "Google",
            "LinkedIn"
        ],
        "question": "Which replication strategy allows multiple nodes to accept writes, increasing write throughput but introducing potential update conflicts? ",
        "options": [
            "Multi-Leader (Master-Master) Replication",
            "Single-Leader Replication",
            "Leaderless Replication (Dynamo-style)",
            "Read Replicas only"
        ],
        "answer": "Multi-Leader (Master-Master) Replication",
        "explanation": "Multi-Leader replication allows writes at multiple datacenters/nodes. It improves performance and local availability but requires conflict resolution logic (e.g., Last Write Wins).",
        "frequency_score": 9
    },
    {
        "id": 1195,
        "topic": "Apache Kafka",
        "companies": [
            "Google",
            "LinkedIn"
        ],
        "question": "What happens if a Kafka Consumer Group has more consumers than partitions in the topic? ",
        "options": [
            "Some consumers will be idle",
            "Throughput increases linearly",
            "Kafka automatically creates more partitions",
            "The extra consumers duplicate the data"
        ],
        "answer": "Some consumers will be idle",
        "explanation": "A partition can be consumed by only one consumer within a group at a time. Extra consumers stay idle.",
        "frequency_score": 6
    },
    {
        "id": 1196,
        "topic": "Distributed Systems",
        "companies": [
            "Google",
            "Facebook",
            "Amazon"
        ],
        "question": "You are designing a distributed counter. You need strict consistency (Linearizability) so every read returns the latest write. What is the trade-off according to the CAP theorem? ",
        "options": [
            "Availability must be sacrificed during partitions",
            "Partition Tolerance can be ignored",
            "Latency will decrease",
            "Consistency is free"
        ],
        "answer": "Availability must be sacrificed during partitions",
        "explanation": "In a CP (Consistent + Partition Tolerant) system, if a partition occurs, the system must refuse requests (unavailable) to ensure it doesn't return stale data.",
        "frequency_score": 9
    },
    {
        "id": 1197,
        "topic": "System Design",
        "companies": [
            "Google"
        ],
        "question": "You need to store unstructured images and videos for ML training, but also need rich metadata (tags, unexpected attributes) for querying. What architecture fits? ",
        "options": [
            "Object Store (GCS) for blobs + NoSQL (Firestore) for metadata",
            "BigQuery for everything",
            "Bigtable for blobs",
            "MySQL for everything"
        ],
        "answer": "Object Store (GCS) for blobs + NoSQL (Firestore) for metadata",
        "explanation": "Store heavy blobs in Object Storage (GCS) for cost/performance. Store flexible, schemaless metadata in a NoSQL document store (Firestore/Datastore) for fast querying.",
        "frequency_score": 10
    },
    {
        "id": 1198,
        "topic": "Apache Kafka",
        "companies": [
            "Google",
            "LinkedIn"
        ],
        "question": "What happens if a Kafka Consumer Group has more consumers than partitions in the topic? ",
        "options": [
            "Some consumers will be idle",
            "Throughput increases linearly",
            "Kafka automatically creates more partitions",
            "The extra consumers duplicate the data"
        ],
        "answer": "Some consumers will be idle",
        "explanation": "A partition can be consumed by only one consumer within a group at a time. Extra consumers stay idle.",
        "frequency_score": 6
    },
    {
        "id": 1199,
        "topic": "BigQuery",
        "companies": [
            "Google",
            "Spotify",
            "Twitter"
        ],
        "question": "You need to store 500 TB of transaction records data in BigQuery. The data is accessed daily. Which storage class fits best to minimize costs? ",
        "options": [
            "Active Storage",
            "Long-term Storage",
            "Nearline Storage",
            "Coldline Storage"
        ],
        "answer": "Active Storage",
        "explanation": "BigQuery Long-term storage applies automatically after 90 days of no modification, reducing price by ~50%.",
        "frequency_score": 10
    },
    {
        "id": 1200,
        "topic": "System Design",
        "companies": [
            "Google",
            "Discord"
        ],
        "question": "You need to distribute a massive dataset across 1000 nodes. Nodes frequently join and leave. Which partitioning strategy minimizes data movement when the cluster resizes? ",
        "options": [
            "Consistent Hashing",
            "Round-Robin Partitioning",
            "Range Partitioning",
            "Modulo Hashing (Key % N)"
        ],
        "answer": "Consistent Hashing",
        "explanation": "Consistent Hashing maps both data and nodes to a ring. When a node is added/removed, only 1/k keys need to be remapped (neighbors), vs nearly all keys with Modulo Hashing.",
        "frequency_score": 10
    },
    {
        "id": 1201,
        "topic": "Data Quality",
        "companies": [
            "Google",
            "Netflix",
            "Airbnb"
        ],
        "question": "You use the 'Write-Audit-Publish' (WAP) pattern for data quality. Where does the data go immediately after transformation but BEFORE it is visible to users? ",
        "options": [
            "A hidden 'stage' partition or snapshot",
            "The production table directly",
            "A temporary CSV file",
            "The Dead Letter Queue"
        ],
        "answer": "A hidden 'stage' partition or snapshot",
        "explanation": "In WAP, data is written to a staging area. Audits (queries) run against this area. If pass, the partition is swapped/published to production atomically.",
        "frequency_score": 8
    },
    {
        "id": 1202,
        "topic": "Apache Kafka",
        "companies": [
            "Google",
            "LinkedIn"
        ],
        "question": "What happens if a Kafka Consumer Group has more consumers than partitions in the topic? ",
        "options": [
            "Some consumers will be idle",
            "Throughput increases linearly",
            "Kafka automatically creates more partitions",
            "The extra consumers duplicate the data"
        ],
        "answer": "Some consumers will be idle",
        "explanation": "A partition can be consumed by only one consumer within a group at a time. Extra consumers stay idle.",
        "frequency_score": 6
    },
    {
        "id": 1203,
        "topic": "Advanced SQL",
        "companies": [
            "Google",
            "Facebook"
        ],
        "question": "You need to rank employees by salary within each department, but skip ranks for ties (e.g., 1, 1, 3). Which window function should you use?",
        "options": [
            "RANK()",
            "DENSE_RANK()",
            "ROW_NUMBER()",
            "NTILE()"
        ],
        "answer": "RANK()",
        "explanation": "RANK() skips values after ties (1,1,3). DENSE_RANK() does not (1,1,2). ROW_NUMBER() gives unique incremental integers (1,2,3).",
        "frequency_score": 9
    },
    {
        "id": 1204,
        "topic": "Logic Puzzles",
        "companies": [
            "Google",
            "Hedge Funds"
        ],
        "question": "You have 25 horses and can race 5 at a time. No stopwatch. What is the minimum number of races to find the top 3 fastest horses?",
        "options": [
            "7 races",
            "6 races",
            "8 races",
            "5 races"
        ],
        "answer": "7 races",
        "explanation": "Race 5 groups (5 races). Race the winners (6th race). Then race the contenders from the top 3 winner's groups (7th race).",
        "frequency_score": 4
    },
    {
        "id": 1205,
        "topic": "Apache Kafka",
        "companies": [
            "Google",
            "LinkedIn",
            "Uber",
            "Netflix"
        ],
        "question": "You need to ensure strict ordering of messages in Kafka for a specific Transaction ID. How should you configure the producer? ",
        "options": [
            "Use the Transaction ID as the partition key",
            "Use a single partition for the entire topic",
            "Enable idempotent producer",
            "Increase replication factor"
        ],
        "answer": "Use the Transaction ID as the partition key",
        "explanation": "Kafka guarantees ordering WITHIN a partition. Using the Entity ID as the key ensures all messages for that entity go to the same partition.",
        "frequency_score": 6
    },
    {
        "id": 1206,
        "topic": "Apache Kafka",
        "companies": [
            "Google",
            "LinkedIn",
            "Uber",
            "Netflix"
        ],
        "question": "You need to ensure strict ordering of messages in Kafka for a specific Transaction ID. How should you configure the producer? ",
        "options": [
            "Use the Transaction ID as the partition key",
            "Use a single partition for the entire topic",
            "Enable idempotent producer",
            "Increase replication factor"
        ],
        "answer": "Use the Transaction ID as the partition key",
        "explanation": "Kafka guarantees ordering WITHIN a partition. Using the Entity ID as the key ensures all messages for that entity go to the same partition.",
        "frequency_score": 6
    },
    {
        "id": 1207,
        "topic": "Bigtable",
        "companies": [
            "Google",
            "Spotify"
        ],
        "question": "You are designing a Bigtable schema for financial transactions. Queries will primarily be retrieve latest events for a specific entity. Which row key design is optimal? ",
        "options": [
            "SensorID#Timestamp",
            "Timestamp#SensorID",
            "ReverseTimestamp#SensorID",
            "Random#SensorID"
        ],
        "answer": "SensorID#Timestamp",
        "explanation": "Avoid starting with timestamp to prevent hotspots. Use EntityID first for entity-lookup queries. Use ReverseTimestamp for 'latest items' queries globally.",
        "frequency_score": 7
    },
    {
        "id": 1208,
        "topic": "Apache Kafka",
        "companies": [
            "Google",
            "LinkedIn",
            "Uber",
            "Netflix"
        ],
        "question": "You need to ensure strict ordering of messages in Kafka for a specific Transaction ID. How should you configure the producer? ",
        "options": [
            "Use the Transaction ID as the partition key",
            "Use a single partition for the entire topic",
            "Enable idempotent producer",
            "Increase replication factor"
        ],
        "answer": "Use the Transaction ID as the partition key",
        "explanation": "Kafka guarantees ordering WITHIN a partition. Using the Entity ID as the key ensures all messages for that entity go to the same partition.",
        "frequency_score": 6
    },
    {
        "id": 1209,
        "topic": "Apache Spark",
        "companies": [
            "Google",
            "Databricks",
            "Facebook",
            "Netflix"
        ],
        "question": "You are optimizing a Spark job that is suffering from data skew. One task takes 10x longer than others during a wide transformation. Which technique is most effective? ",
        "options": [
            "Salting the key",
            "Increasing the number of executors",
            "Using a larger instance type",
            "Broadcasting the large table"
        ],
        "answer": "Salting the key",
        "explanation": "Salting adds a random prefix to the skewed key to distribute it. Broadcasting is best for Skewed Joins where one table is small.",
        "frequency_score": 6
    },
    {
        "id": 1210,
        "topic": "Apache Kafka",
        "companies": [
            "Google",
            "LinkedIn",
            "Uber",
            "Netflix"
        ],
        "question": "You need to ensure strict ordering of messages in Kafka for a specific Transaction ID. How should you configure the producer? ",
        "options": [
            "Use the Transaction ID as the partition key",
            "Use a single partition for the entire topic",
            "Enable idempotent producer",
            "Increase replication factor"
        ],
        "answer": "Use the Transaction ID as the partition key",
        "explanation": "Kafka guarantees ordering WITHIN a partition. Using the Entity ID as the key ensures all messages for that entity go to the same partition.",
        "frequency_score": 6
    },
    {
        "id": 1211,
        "topic": "Apache Spark",
        "companies": [
            "Google",
            "Databricks",
            "Facebook",
            "Netflix"
        ],
        "question": "You are optimizing a Spark job that is suffering from data skew. One task takes 10x longer than others during a wide transformation. Which technique is most effective? ",
        "options": [
            "Salting the key",
            "Increasing the number of executors",
            "Using a larger instance type",
            "Broadcasting the large table"
        ],
        "answer": "Salting the key",
        "explanation": "Salting adds a random prefix to the skewed key to distribute it. Broadcasting is best for Skewed Joins where one table is small.",
        "frequency_score": 6
    },
    {
        "id": 1212,
        "topic": "Pub/Sub",
        "companies": [
            "Google",
            "Uber"
        ],
        "question": "Your application publishes high throughput messages to Pub/Sub. You observe increased end-to-end latency and growing backlog. What is the most likely cause? ",
        "options": [
            "Subscribers are too slow (backlog)",
            "Publisher quota exceeded",
            "Message size too large",
            "Ordering keys are causing hotspots"
        ],
        "answer": "Subscribers are too slow (backlog)",
        "explanation": "If using ordering keys, high throughput on a single key can limit scalability (1MB/s limit per key). Slow subscribers cause increased backlog.",
        "frequency_score": 7
    },
    {
        "id": 1213,
        "topic": "System Design",
        "companies": [
            "Google"
        ],
        "question": "You need to store unstructured images and videos for ML training, but also need rich metadata (tags, unexpected attributes) for querying. What architecture fits? ",
        "options": [
            "Object Store (GCS) for blobs + NoSQL (Firestore) for metadata",
            "BigQuery for everything",
            "Bigtable for blobs",
            "MySQL for everything"
        ],
        "answer": "Object Store (GCS) for blobs + NoSQL (Firestore) for metadata",
        "explanation": "Store heavy blobs in Object Storage (GCS) for cost/performance. Store flexible, schemaless metadata in a NoSQL document store (Firestore/Datastore) for fast querying.",
        "frequency_score": 10
    },
    {
        "id": 1214,
        "topic": "System Design",
        "companies": [
            "Google",
            "Pinterest"
        ],
        "question": "You are designing a predictive search engine (like Google Search Autocomplete). You need sub-100ms latency for prefix lookups on billions of queries. Which data structure is optimal? ",
        "options": [
            "Trie (Prefix Tree) stored in memory",
            "B-Tree on disk",
            "Bloom Filter",
            "Inverted Index"
        ],
        "answer": "Trie (Prefix Tree) stored in memory",
        "explanation": "Tries are optimized for prefix lookups. Storing the top variations in memory (or using a distributed cache like Redis) ensures low latency.",
        "frequency_score": 10
    },
    {
        "id": 1215,
        "topic": "BigQuery Optimization",
        "companies": [
            "Google",
            "Spotify"
        ],
        "question": "You have a query filtering by 'event_date' (Partition Key) and sorting by 'user_id'. The query is still slow. What is the best optimization?",
        "options": [
            "Cluster the table by 'user_id'",
            "Add a secondary partition on 'user_id'",
            "Normalize the table",
            "Use a materialized view"
        ],
        "answer": "Cluster the table by 'user_id'",
        "explanation": "Clustering co-locates data with the same values, making sorts and high-cardinality filters much faster within a partition.",
        "frequency_score": 9
    },
    {
        "id": 1216,
        "topic": "Pub/Sub",
        "companies": [
            "Google",
            "Uber"
        ],
        "question": "Your application publishes high throughput messages to Pub/Sub. You observe throughput limits on specific keys. What is the most likely cause? ",
        "options": [
            "Subscribers are too slow (backlog)",
            "Publisher quota exceeded",
            "Message size too large",
            "Ordering keys are causing hotspots"
        ],
        "answer": "Ordering keys are causing hotspots",
        "explanation": "If using ordering keys, high throughput on a single key can limit scalability (1MB/s limit per key). Slow subscribers cause increased backlog.",
        "frequency_score": 7
    },
    {
        "id": 1217,
        "topic": "Advanced SQL",
        "companies": [
            "Google",
            "Facebook"
        ],
        "question": "You need to rank employees by salary within each department, but skip ranks for ties (e.g., 1, 1, 3). Which window function should you use? ",
        "options": [
            "RANK()",
            "DENSE_RANK()",
            "ROW_NUMBER()",
            "NTILE()"
        ],
        "answer": "RANK()",
        "explanation": "RANK() skips values after ties (1,1,3). DENSE_RANK() does not (1,1,2). ROW_NUMBER() gives unique incremental integers (1,2,3).",
        "frequency_score": 9
    },
    {
        "id": 1218,
        "topic": "Algorithms",
        "companies": [
            "Google",
            "Amazon",
            "Microsoft"
        ],
        "question": "What is the time complexity of a Bubble Sort algorithm in the worst case? ",
        "options": [
            "O(n log n)",
            "O(n^2)",
            "O(n)",
            "O(log n)"
        ],
        "answer": "O(n^2)",
        "explanation": "Merge Sort is O(n log n). Quick Sort is O(n^2) in worst case (though avg O(n log n)). Bubble Sort is O(n^2).",
        "frequency_score": 8
    },
    {
        "id": 1219,
        "topic": "Logic Puzzles",
        "companies": [
            "Google",
            "Hedge Funds"
        ],
        "question": "You have 25 horses and can race 5 at a time. No stopwatch. What is the minimum number of races to find the top 3 fastest horses? ",
        "options": [
            "7 races",
            "6 races",
            "8 races",
            "5 races"
        ],
        "answer": "7 races",
        "explanation": "Race 5 groups (5 races). Race the winners (6th race). Then race the contenders from the top 3 winner's groups (7th race).",
        "frequency_score": 4
    },
    {
        "id": 1220,
        "topic": "Logic Puzzles",
        "companies": [
            "Google",
            "Hedge Funds"
        ],
        "question": "You have 25 horses and can race 5 at a time. No stopwatch. What is the minimum number of races to find the top 3 fastest horses? ",
        "options": [
            "7 races",
            "6 races",
            "8 races",
            "5 races"
        ],
        "answer": "7 races",
        "explanation": "Race 5 groups (5 races). Race the winners (6th race). Then race the contenders from the top 3 winner's groups (7th race).",
        "frequency_score": 4
    },
    {
        "id": 1221,
        "topic": "Distributed Systems",
        "companies": [
            "Google",
            "Uber"
        ],
        "question": "You need to update data across two separate microservices (e.g., Payment and Order) transactionally. Traditional 2PC (Two-Phase Commit) is too slow/blocking. What is the modern alternative? ",
        "options": [
            "Saga Pattern",
            "3PC",
            "Write-Ahead Logging",
            "Stored Procedures"
        ],
        "answer": "Saga Pattern",
        "explanation": "The Saga pattern manages distributed transactions as a sequence of local transactions, with compensating actions (undo operations) to handle failures without long locks.",
        "frequency_score": 9
    },
    {
        "id": 1222,
        "topic": "Dataflow",
        "companies": [
            "Google",
            "Spotify",
            "New York Times"
        ],
        "question": "You are building a streaming pipeline to process user clickstreams. You need to handle periods of user activity separated by gaps. What windowing strategy is appropriate? ",
        "options": [
            "Fixed Windows",
            "Sliding Windows",
            "Session Windows",
            "Global Windows"
        ],
        "answer": "Session Windows",
        "explanation": "Session windows gap-fill based on activity. Sliding windows overlap (e.g. every 5 min show last 1 hour). Fixed windows are tumbling.",
        "frequency_score": 9
    },
    {
        "id": 1223,
        "topic": "System Design",
        "companies": [
            "Google",
            "Pinterest"
        ],
        "question": "You are designing a predictive search engine (like Google Search Autocomplete). You need sub-100ms latency for prefix lookups on billions of queries. Which data structure is optimal? ",
        "options": [
            "Trie (Prefix Tree) stored in memory",
            "B-Tree on disk",
            "Bloom Filter",
            "Inverted Index"
        ],
        "answer": "Trie (Prefix Tree) stored in memory",
        "explanation": "Tries are optimized for prefix lookups. Storing the top variations in memory (or using a distributed cache like Redis) ensures low latency.",
        "frequency_score": 10
    },
    {
        "id": 1224,
        "topic": "BigQuery",
        "companies": [
            "Google",
            "Spotify",
            "Twitter"
        ],
        "question": "You need to store 1 PB of transaction records data in BigQuery. The data is accessed once a quarter. Which storage class fits best to minimize costs? ",
        "options": [
            "Active Storage",
            "Long-term Storage",
            "Nearline Storage",
            "Coldline Storage"
        ],
        "answer": "Active Storage",
        "explanation": "BigQuery Long-term storage applies automatically after 90 days of no modification, reducing price by ~50%.",
        "frequency_score": 10
    },
    {
        "id": 1225,
        "topic": "Bigtable",
        "companies": [
            "Google",
            "Spotify"
        ],
        "question": "You are designing a Bigtable schema for financial transactions. Queries will primarily be retrieve latest events for a specific entity. Which row key design is optimal? ",
        "options": [
            "DeviceID#Timestamp",
            "Timestamp#DeviceID",
            "ReverseTimestamp#DeviceID",
            "Random#DeviceID"
        ],
        "answer": "DeviceID#Timestamp",
        "explanation": "Avoid starting with timestamp to prevent hotspots. Use EntityID first for entity-lookup queries. Use ReverseTimestamp for 'latest items' queries globally.",
        "frequency_score": 7
    },
    {
        "id": 1226,
        "topic": "System Design",
        "companies": [
            "Google",
            "Pinterest"
        ],
        "question": "You are designing a predictive search engine (like Google Search Autocomplete). You need sub-100ms latency for prefix lookups on billions of queries. Which data structure is optimal? ",
        "options": [
            "Trie (Prefix Tree) stored in memory",
            "B-Tree on disk",
            "Bloom Filter",
            "Inverted Index"
        ],
        "answer": "Trie (Prefix Tree) stored in memory",
        "explanation": "Tries are optimized for prefix lookups. Storing the top variations in memory (or using a distributed cache like Redis) ensures low latency.",
        "frequency_score": 10
    },
    {
        "id": 1227,
        "topic": "Data Quality",
        "companies": [
            "Google",
            "Netflix",
            "Airbnb"
        ],
        "question": "You use the 'Write-Audit-Publish' (WAP) pattern for data quality. Where does the data go immediately after transformation but BEFORE it is visible to users? ",
        "options": [
            "A hidden 'stage' partition or snapshot",
            "The production table directly",
            "A temporary CSV file",
            "The Dead Letter Queue"
        ],
        "answer": "A hidden 'stage' partition or snapshot",
        "explanation": "In WAP, data is written to a staging area. Audits (queries) run against this area. If pass, the partition is swapped/published to production atomically.",
        "frequency_score": 8
    },
    {
        "id": 1228,
        "topic": "Advanced SQL",
        "companies": [
            "Google",
            "Facebook"
        ],
        "question": "You need to rank employees by salary within each department, but skip ranks for ties (e.g., 1, 1, 3). Which window function should you use? ",
        "options": [
            "RANK()",
            "DENSE_RANK()",
            "ROW_NUMBER()",
            "NTILE()"
        ],
        "answer": "RANK()",
        "explanation": "RANK() skips values after ties (1,1,3). DENSE_RANK() does not (1,1,2). ROW_NUMBER() gives unique incremental integers (1,2,3).",
        "frequency_score": 9
    },
    {
        "id": 1229,
        "topic": "Data pipelines",
        "companies": [
            "Google",
            "Stripe",
            "PayPal"
        ],
        "question": "You are ingesting payment events from an external API that might send duplicates 1% of the time. You need 'Exactly-Once' processing in your warehouse. What is the most robust strategy? ",
        "options": [
            "Idempotent ingestion using unique Transaction IDs",
            "Trust the API to never send duplicates",
            "Run a DISTINCT query at the end",
            "Use a low isolation level"
        ],
        "answer": "Idempotent ingestion using unique Transaction IDs",
        "explanation": "Idempotency means applying the same operation multiple times has the same effect as applying it once. Using a unique key (Transaction ID) to merge/deduplicate is the standard.",
        "frequency_score": 9
    },
    {
        "id": 1230,
        "topic": "Dataflow",
        "companies": [
            "Google",
            "Spotify",
            "New York Times"
        ],
        "question": "You are building a streaming pipeline to process user clickstreams. You need to handle periods of user activity separated by gaps. What windowing strategy is appropriate? ",
        "options": [
            "Fixed Windows",
            "Sliding Windows",
            "Session Windows",
            "Global Windows"
        ],
        "answer": "Session Windows",
        "explanation": "Session windows gap-fill based on activity. Sliding windows overlap (e.g. every 5 min show last 1 hour). Fixed windows are tumbling.",
        "frequency_score": 9
    },
    {
        "id": 1231,
        "topic": "Apache Spark",
        "companies": [
            "Google",
            "Databricks",
            "Amazon"
        ],
        "question": "In Spark, what is the difference between a Transformation and an Action? ",
        "options": [
            "Transformations are lazy, Actions match strict execution",
            "Actions are lazy, Transformations trigger execution",
            "They are the same",
            "Transformations save to disk, Actions read from disk"
        ],
        "answer": "Transformations are lazy, Actions match strict execution",
        "explanation": "Transformations (like map, filter) build the DAG but do not execute. Actions (like count, collect, save) trigger the actual computation.",
        "frequency_score": 6
    },
    {
        "id": 1232,
        "topic": "Distributed Systems",
        "companies": [
            "Google",
            "Uber"
        ],
        "question": "You need to update data across two separate microservices (e.g., Payment and Order) transactionally. Traditional 2PC (Two-Phase Commit) is too slow/blocking. What is the modern alternative? ",
        "options": [
            "Saga Pattern",
            "3PC",
            "Write-Ahead Logging",
            "Stored Procedures"
        ],
        "answer": "Saga Pattern",
        "explanation": "The Saga pattern manages distributed transactions as a sequence of local transactions, with compensating actions (undo operations) to handle failures without long locks.",
        "frequency_score": 9
    },
    {
        "id": 1233,
        "topic": "IAM",
        "companies": [
            "Google"
        ],
        "question": "A developer needs to upload files to a bucket in a production project. Following the principle of least privilege, which role should you grant? ",
        "options": [
            "Viewer",
            "Editor",
            "Owner",
            "BigQuery Data Viewer"
        ],
        "answer": "BigQuery Data Viewer",
        "explanation": "Always prefer predefined specific roles (like BigQuery Data Viewer, Storage Object Admin) over basic roles (Viewer/Editor/Owner) to ensure least privilege.",
        "frequency_score": 9
    },
    {
        "id": 1234,
        "topic": "Data pipelines",
        "companies": [
            "Google",
            "Stripe",
            "PayPal"
        ],
        "question": "You are ingesting payment events from an external API that might send duplicates 1% of the time. You need 'Exactly-Once' processing in your warehouse. What is the most robust strategy? ",
        "options": [
            "Idempotent ingestion using unique Transaction IDs",
            "Trust the API to never send duplicates",
            "Run a DISTINCT query at the end",
            "Use a low isolation level"
        ],
        "answer": "Idempotent ingestion using unique Transaction IDs",
        "explanation": "Idempotency means applying the same operation multiple times has the same effect as applying it once. Using a unique key (Transaction ID) to merge/deduplicate is the standard.",
        "frequency_score": 9
    },
    {
        "id": 1235,
        "topic": "BigQuery Optimization",
        "companies": [
            "Google",
            "Spotify"
        ],
        "question": "You have a query filtering by 'event_date' (Partition Key) and sorting by 'user_id'. The query is still slow. What is the best optimization? ",
        "options": [
            "Cluster the table by 'user_id'",
            "Add a secondary partition on 'user_id'",
            "Normalize the table",
            "Use a materialized view"
        ],
        "answer": "Cluster the table by 'user_id'",
        "explanation": "Clustering co-locates data with the same values, making sorts and high-cardinality filters much faster within a partition.",
        "frequency_score": 9
    },
    {
        "id": 1236,
        "topic": "Cloud Storage",
        "companies": [
            "Google",
            "Snapchat"
        ],
        "question": "You are designing a storage solution for disaster recovery backups. The requirement is high frequency access. What storage class should you use? ",
        "options": [
            "Standard",
            "Nearline",
            "Coldline",
            "Archive"
        ],
        "answer": "Standard",
        "explanation": "Standard for hot data. Nearline < 1/month. Coldline < 1/quarter. Archive < 1/year.",
        "frequency_score": 6
    },
    {
        "id": 1237,
        "topic": "Apache Spark",
        "companies": [
            "Google",
            "Databricks",
            "Facebook",
            "Netflix"
        ],
        "question": "You are optimizing a Spark job that is suffering from data skew. One task takes 10x longer than others during a wide transformation. Which technique is most effective? ",
        "options": [
            "Salting the key",
            "Increasing the number of executors",
            "Using a larger instance type",
            "Broadcasting the large table"
        ],
        "answer": "Salting the key",
        "explanation": "Salting adds a random prefix to the skewed key to distribute it. Broadcasting is best for Skewed Joins where one table is small.",
        "frequency_score": 6
    },
    {
        "id": 1238,
        "topic": "Dataflow",
        "companies": [
            "Google",
            "Spotify",
            "New York Times"
        ],
        "question": "You are building a streaming pipeline to process user clickstreams. You need to handle rolling averages every minute for the last hour. What windowing strategy is appropriate? ",
        "options": [
            "Fixed Windows",
            "Sliding Windows",
            "Session Windows",
            "Global Windows"
        ],
        "answer": "Sliding Windows",
        "explanation": "Session windows gap-fill based on activity. Sliding windows overlap (e.g. every 5 min show last 1 hour). Fixed windows are tumbling.",
        "frequency_score": 9
    },
    {
        "id": 1239,
        "topic": "Bigtable",
        "companies": [
            "Google",
            "Spotify"
        ],
        "question": "You are designing a Bigtable schema for financial transactions. Queries will primarily be retrieve latest events for a specific entity. Which row key design is optimal? ",
        "options": [
            "UserID#Timestamp",
            "Timestamp#UserID",
            "ReverseTimestamp#UserID",
            "Random#UserID"
        ],
        "answer": "UserID#Timestamp",
        "explanation": "Avoid starting with timestamp to prevent hotspots. Use EntityID first for entity-lookup queries. Use ReverseTimestamp for 'latest items' queries globally.",
        "frequency_score": 7
    },
    {
        "id": 1240,
        "topic": "Data Structures",
        "companies": [
            "Google",
            "Amazon",
            "Microsoft",
            "Facebook"
        ],
        "question": "You need to implement a look-up service that checks if a user ID exists in a set of 1 billion users with O(1) average time complexity. Which data structure is best? ",
        "options": [
            "Hash Table / HashSet",
            "Binary Search Tree",
            "Linked List",
            "Array"
        ],
        "answer": "Hash Table / HashSet",
        "explanation": "Hash Tables provide O(1) average case lookup. BST is O(log n).",
        "frequency_score": 8
    },
    {
        "id": 1241,
        "topic": "System Design",
        "companies": [
            "Google",
            "Discord"
        ],
        "question": "You need to distribute a massive dataset across 1000 nodes. Nodes frequently join and leave. Which partitioning strategy minimizes data movement when the cluster resizes? ",
        "options": [
            "Consistent Hashing",
            "Round-Robin Partitioning",
            "Range Partitioning",
            "Modulo Hashing (Key % N)"
        ],
        "answer": "Consistent Hashing",
        "explanation": "Consistent Hashing maps both data and nodes to a ring. When a node is added/removed, only 1/k keys need to be remapped (neighbors), vs nearly all keys with Modulo Hashing.",
        "frequency_score": 10
    },
    {
        "id": 1242,
        "topic": "BigQuery",
        "companies": [
            "Google",
            "Spotify",
            "Twitter"
        ],
        "question": "You need to store 50 TB of transaction records data in BigQuery. The data is accessed rarely (every 6 months). Which storage class fits best to minimize costs? ",
        "options": [
            "Active Storage",
            "Long-term Storage",
            "Nearline Storage",
            "Coldline Storage"
        ],
        "answer": "Long-term Storage",
        "explanation": "BigQuery Long-term storage applies automatically after 90 days of no modification, reducing price by ~50%.",
        "frequency_score": 10
    },
    {
        "id": 1243,
        "topic": "Apache Kafka",
        "companies": [
            "Google",
            "LinkedIn",
            "Uber",
            "Netflix"
        ],
        "question": "You need to ensure strict ordering of messages in Kafka for a specific User ID. How should you configure the producer? ",
        "options": [
            "Use the User ID as the partition key",
            "Use a single partition for the entire topic",
            "Enable idempotent producer",
            "Increase replication factor"
        ],
        "answer": "Use the User ID as the partition key",
        "explanation": "Kafka guarantees ordering WITHIN a partition. Using the Entity ID as the key ensures all messages for that entity go to the same partition.",
        "frequency_score": 6
    },
    {
        "id": 1244,
        "topic": "System Design",
        "companies": [
            "Google",
            "YouTube",
            "TikTok"
        ],
        "question": "You are building a video recommendation engine. The 'Candidate Generation' phase filters millions of videos down to hundreds. Which approach is valid for this phase? ",
        "options": [
            "Collaborative Filtering / Two-Tower Neural Network",
            "Heavy learning-to-rank model",
            "A/B Testing",
            "Linear Regression"
        ],
        "answer": "Collaborative Filtering / Two-Tower Neural Network",
        "explanation": "Candidate generation must be fast and lightweight (high recall). Complex ranking models (high precision) are used only on the smaller subset of candidates.",
        "frequency_score": 10
    },
    {
        "id": 1245,
        "topic": "Apache Spark",
        "companies": [
            "Google",
            "Databricks",
            "Facebook",
            "Netflix"
        ],
        "question": "You are optimizing a Spark job that is suffering from data skew. You are joining a large skewed table with a small reference table. Which technique is most effective? ",
        "options": [
            "Salting the key",
            "Increasing the number of executors",
            "Using a larger instance type",
            "Broadcasting the large table"
        ],
        "answer": "Salting the key",
        "explanation": "Salting adds a random prefix to the skewed key to distribute it. Broadcasting is best for Skewed Joins where one table is small.",
        "frequency_score": 6
    },
    {
        "id": 1246,
        "topic": "Distributed Systems",
        "companies": [
            "Google",
            "Facebook",
            "Amazon"
        ],
        "question": "You are designing a distributed counter. You need strict consistency (Linearizability) so every read returns the latest write. What is the trade-off according to the CAP theorem? ",
        "options": [
            "Availability must be sacrificed during partitions",
            "Partition Tolerance can be ignored",
            "Latency will decrease",
            "Consistency is free"
        ],
        "answer": "Availability must be sacrificed during partitions",
        "explanation": "In a CP (Consistent + Partition Tolerant) system, if a partition occurs, the system must refuse requests (unavailable) to ensure it doesn't return stale data.",
        "frequency_score": 9
    },
    {
        "id": 1247,
        "topic": "Distributed Systems",
        "companies": [
            "Google",
            "Facebook",
            "Amazon"
        ],
        "question": "You are designing a distributed counter. You need strict consistency (Linearizability) so every read returns the latest write. What is the trade-off according to the CAP theorem? ",
        "options": [
            "Availability must be sacrificed during partitions",
            "Partition Tolerance can be ignored",
            "Latency will decrease",
            "Consistency is free"
        ],
        "answer": "Availability must be sacrificed during partitions",
        "explanation": "In a CP (Consistent + Partition Tolerant) system, if a partition occurs, the system must refuse requests (unavailable) to ensure it doesn't return stale data.",
        "frequency_score": 9
    },
    {
        "id": 1248,
        "topic": "Data Structures",
        "companies": [
            "Google",
            "Amazon",
            "Microsoft",
            "Facebook"
        ],
        "question": "You need to implement a look-up service that checks if a user ID exists in a set of 1 billion users with O(1) average time complexity. Which data structure is best? ",
        "options": [
            "Hash Table / HashSet",
            "Binary Search Tree",
            "Linked List",
            "Array"
        ],
        "answer": "Hash Table / HashSet",
        "explanation": "Hash Tables provide O(1) average case lookup. BST is O(log n).",
        "frequency_score": 8
    },
    {
        "id": 1249,
        "topic": "Data Structures",
        "companies": [
            "Google",
            "Amazon",
            "Microsoft",
            "Facebook"
        ],
        "question": "You need to implement a look-up service that checks if a user ID exists in a set of 1 billion users with O(1) average time complexity. Which data structure is best? ",
        "options": [
            "Hash Table / HashSet",
            "Binary Search Tree",
            "Linked List",
            "Array"
        ],
        "answer": "Hash Table / HashSet",
        "explanation": "Hash Tables provide O(1) average case lookup. BST is O(log n).",
        "frequency_score": 8
    },
    {
        "id": 1250,
        "topic": "Apache Spark",
        "companies": [
            "Google",
            "Databricks",
            "Facebook",
            "Netflix"
        ],
        "question": "You are optimizing a Spark job that is suffering from data skew. One task takes 10x longer than others during a wide transformation. Which technique is most effective? ",
        "options": [
            "Salting the key",
            "Increasing the number of executors",
            "Using a larger instance type",
            "Broadcasting the large table"
        ],
        "answer": "Salting the key",
        "explanation": "Salting adds a random prefix to the skewed key to distribute it. Broadcasting is best for Skewed Joins where one table is small.",
        "frequency_score": 6
    },
    {
        "id": 1251,
        "topic": "Advanced SQL",
        "companies": [
            "Google",
            "Facebook"
        ],
        "question": "You need to rank employees by salary within each department, but skip ranks for ties (e.g., 1, 1, 3). Which window function should you use? ",
        "options": [
            "RANK()",
            "DENSE_RANK()",
            "ROW_NUMBER()",
            "NTILE()"
        ],
        "answer": "RANK()",
        "explanation": "RANK() skips values after ties (1,1,3). DENSE_RANK() does not (1,1,2). ROW_NUMBER() gives unique incremental integers (1,2,3).",
        "frequency_score": 9
    },
    {
        "id": 1252,
        "topic": "Distributed Systems",
        "companies": [
            "Google",
            "Facebook",
            "Amazon"
        ],
        "question": "You are designing a distributed counter. You need strict consistency (Linearizability) so every read returns the latest write. What is the trade-off according to the CAP theorem? ",
        "options": [
            "Availability must be sacrificed during partitions",
            "Partition Tolerance can be ignored",
            "Latency will decrease",
            "Consistency is free"
        ],
        "answer": "Availability must be sacrificed during partitions",
        "explanation": "In a CP (Consistent + Partition Tolerant) system, if a partition occurs, the system must refuse requests (unavailable) to ensure it doesn't return stale data.",
        "frequency_score": 9
    },
    {
        "id": 1253,
        "topic": "Apache Spark",
        "companies": [
            "Google",
            "Databricks",
            "Facebook",
            "Netflix"
        ],
        "question": "You are optimizing a Spark job that is suffering from data skew. One task takes 10x longer than others during a wide transformation. Which technique is most effective? ",
        "options": [
            "Salting the key",
            "Increasing the number of executors",
            "Using a larger instance type",
            "Broadcasting the large table"
        ],
        "answer": "Salting the key",
        "explanation": "Salting adds a random prefix to the skewed key to distribute it. Broadcasting is best for Skewed Joins where one table is small.",
        "frequency_score": 6
    },
    {
        "id": 1254,
        "topic": "Data Structures",
        "companies": [
            "Google",
            "Amazon",
            "Microsoft",
            "Facebook"
        ],
        "question": "You need to implement a look-up service that checks if a user ID exists in a set of 1 billion users with O(1) average time complexity. Which data structure is best? ",
        "options": [
            "Hash Table / HashSet",
            "Binary Search Tree",
            "Linked List",
            "Array"
        ],
        "answer": "Hash Table / HashSet",
        "explanation": "Hash Tables provide O(1) average case lookup. BST is O(log n).",
        "frequency_score": 8
    },
    {
        "id": 1255,
        "topic": "Apache Kafka",
        "companies": [
            "Google",
            "LinkedIn",
            "Uber",
            "Netflix"
        ],
        "question": "You need to ensure strict ordering of messages in Kafka for a specific Device ID. How should you configure the producer? ",
        "options": [
            "Use the Device ID as the partition key",
            "Use a single partition for the entire topic",
            "Enable idempotent producer",
            "Increase replication factor"
        ],
        "answer": "Use the Device ID as the partition key",
        "explanation": "Kafka guarantees ordering WITHIN a partition. Using the Entity ID as the key ensures all messages for that entity go to the same partition.",
        "frequency_score": 6
    },
    {
        "id": 1256,
        "topic": "IAM",
        "companies": [
            "Google"
        ],
        "question": "A developer needs to deploy Cloud Functions in a production project. Following the principle of least privilege, which role should you grant? ",
        "options": [
            "Viewer",
            "Editor",
            "Owner",
            "BigQuery Data Viewer"
        ],
        "answer": "BigQuery Data Viewer",
        "explanation": "Always prefer predefined specific roles (like BigQuery Data Viewer, Storage Object Admin) over basic roles (Viewer/Editor/Owner) to ensure least privilege.",
        "frequency_score": 9
    },
    {
        "id": 1257,
        "topic": "Bigtable",
        "companies": [
            "Google",
            "Spotify"
        ],
        "question": "You are designing a Bigtable schema for social media posts. Queries will primarily be retrieve latest events for a specific entity. Which row key design is optimal? ",
        "options": [
            "DeviceID#Date",
            "Date#DeviceID",
            "ReverseTimestamp#DeviceID",
            "Random#DeviceID"
        ],
        "answer": "DeviceID#Date",
        "explanation": "Avoid starting with timestamp to prevent hotspots. Use EntityID first for entity-lookup queries. Use ReverseTimestamp for 'latest items' queries globally.",
        "frequency_score": 7
    },
    {
        "id": 1258,
        "topic": "Apache Kafka",
        "companies": [
            "Google",
            "LinkedIn"
        ],
        "question": "What happens if a Kafka Consumer Group has more consumers than partitions in the topic? ",
        "options": [
            "Some consumers will be idle",
            "Throughput increases linearly",
            "Kafka automatically creates more partitions",
            "The extra consumers duplicate the data"
        ],
        "answer": "Some consumers will be idle",
        "explanation": "A partition can be consumed by only one consumer within a group at a time. Extra consumers stay idle.",
        "frequency_score": 6
    },
    {
        "id": 1259,
        "topic": "Apache Kafka",
        "companies": [
            "Google",
            "LinkedIn"
        ],
        "question": "What happens if a Kafka Consumer Group has more consumers than partitions in the topic? ",
        "options": [
            "Some consumers will be idle",
            "Throughput increases linearly",
            "Kafka automatically creates more partitions",
            "The extra consumers duplicate the data"
        ],
        "answer": "Some consumers will be idle",
        "explanation": "A partition can be consumed by only one consumer within a group at a time. Extra consumers stay idle.",
        "frequency_score": 6
    },
    {
        "id": 1260,
        "topic": "Cloud Spanner",
        "companies": [
            "Google",
            "Uber",
            "Pokemon GO"
        ],
        "question": "You are designing a global banking ledger. You require strong consistency and 99.999% availability. Which database service should you choose? ",
        "options": [
            "Cloud Spanner",
            "Cloud SQL",
            "Bigtable",
            "Firestore"
        ],
        "answer": "Cloud Spanner",
        "explanation": "Cloud Spanner is the only service providing global strong consistency and horizontal scalability with relational semantics (SQL).",
        "frequency_score": 8
    },
    {
        "id": 1261,
        "topic": "Advanced SQL",
        "companies": [
            "Google",
            "Facebook"
        ],
        "question": "You need to rank employees by salary within each department, but skip ranks for ties (e.g., 1, 1, 3). Which window function should you use? ",
        "options": [
            "RANK()",
            "DENSE_RANK()",
            "ROW_NUMBER()",
            "NTILE()"
        ],
        "answer": "RANK()",
        "explanation": "RANK() skips values after ties (1,1,3). DENSE_RANK() does not (1,1,2). ROW_NUMBER() gives unique incremental integers (1,2,3).",
        "frequency_score": 9
    },
    {
        "id": 1262,
        "topic": "Dataflow",
        "companies": [
            "Google",
            "Spotify",
            "New York Times"
        ],
        "question": "You are building a streaming pipeline to process user clickstreams. You need to handle rolling averages every minute for the last hour. What windowing strategy is appropriate? ",
        "options": [
            "Fixed Windows",
            "Sliding Windows",
            "Session Windows",
            "Global Windows"
        ],
        "answer": "Sliding Windows",
        "explanation": "Session windows gap-fill based on activity. Sliding windows overlap (e.g. every 5 min show last 1 hour). Fixed windows are tumbling.",
        "frequency_score": 9
    },
    {
        "id": 1263,
        "topic": "Data Structures",
        "companies": [
            "Google",
            "Amazon",
            "Microsoft",
            "Facebook"
        ],
        "question": "You need to implement a look-up service that checks if a user ID exists in a set of 1 billion users with O(log n) average time complexity. Which data structure is best? ",
        "options": [
            "Hash Table / HashSet",
            "Binary Search Tree",
            "Linked List",
            "Array"
        ],
        "answer": "Binary Search Tree",
        "explanation": "Hash Tables provide O(1) average case lookup. BST is O(log n).",
        "frequency_score": 8
    },
    {
        "id": 1264,
        "topic": "IAM",
        "companies": [
            "Google"
        ],
        "question": "A developer needs to view BigQuery datasets in a production project. Following the principle of least privilege, which role should you grant? ",
        "options": [
            "Viewer",
            "Editor",
            "Owner",
            "Storage Object Creator"
        ],
        "answer": "Storage Object Creator",
        "explanation": "Always prefer predefined specific roles (like BigQuery Data Viewer, Storage Object Admin) over basic roles (Viewer/Editor/Owner) to ensure least privilege.",
        "frequency_score": 9
    },
    {
        "id": 1265,
        "topic": "Apache Spark",
        "companies": [
            "Google",
            "Databricks",
            "Facebook",
            "Netflix"
        ],
        "question": "You are optimizing a Spark job that is suffering from data skew. You are joining a large skewed table with a small reference table. Which technique is most effective? ",
        "options": [
            "Salting the key",
            "Increasing the number of executors",
            "Using a larger instance type",
            "Broadcasting the large table"
        ],
        "answer": "Salting the key",
        "explanation": "Salting adds a random prefix to the skewed key to distribute it. Broadcasting is best for Skewed Joins where one table is small.",
        "frequency_score": 6
    },
    {
        "id": 1266,
        "topic": "Bigtable",
        "companies": [
            "Google",
            "Spotify"
        ],
        "question": "You are designing a Bigtable schema for IoT events. Queries will primarily be retrieve most recent events globally. Which row key design is optimal? ",
        "options": [
            "DeviceID#Date",
            "Date#DeviceID",
            "ReverseTimestamp#DeviceID",
            "Random#DeviceID"
        ],
        "answer": "ReverseTimestamp#DeviceID",
        "explanation": "Avoid starting with timestamp to prevent hotspots. Use EntityID first for entity-lookup queries. Use ReverseTimestamp for 'latest items' queries globally.",
        "frequency_score": 7
    },
    {
        "id": 1267,
        "topic": "Apache Spark",
        "companies": [
            "Google",
            "Databricks",
            "Facebook",
            "Netflix"
        ],
        "question": "You are optimizing a Spark job that is suffering from data skew. One task takes 10x longer than others during a wide transformation. Which technique is most effective? ",
        "options": [
            "Salting the key",
            "Increasing the number of executors",
            "Using a larger instance type",
            "Broadcasting the large table"
        ],
        "answer": "Salting the key",
        "explanation": "Salting adds a random prefix to the skewed key to distribute it. Broadcasting is best for Skewed Joins where one table is small.",
        "frequency_score": 6
    },
    {
        "id": 1268,
        "topic": "Apache Spark",
        "companies": [
            "Google",
            "Databricks",
            "Amazon"
        ],
        "question": "In Spark, what is the difference between a Transformation and an Action? ",
        "options": [
            "Transformations are lazy, Actions match strict execution",
            "Actions are lazy, Transformations trigger execution",
            "They are the same",
            "Transformations save to disk, Actions read from disk"
        ],
        "answer": "Transformations are lazy, Actions match strict execution",
        "explanation": "Transformations (like map, filter) build the DAG but do not execute. Actions (like count, collect, save) trigger the actual computation.",
        "frequency_score": 6
    },
    {
        "id": 1269,
        "topic": "Logic Puzzles",
        "companies": [
            "Google",
            "Hedge Funds"
        ],
        "question": "You have 25 horses and can race 5 at a time. No stopwatch. What is the minimum number of races to find the top 3 fastest horses? ",
        "options": [
            "7 races",
            "6 races",
            "8 races",
            "5 races"
        ],
        "answer": "7 races",
        "explanation": "Race 5 groups (5 races). Race the winners (6th race). Then race the contenders from the top 3 winner's groups (7th race).",
        "frequency_score": 4
    },
    {
        "id": 1270,
        "topic": "System Design",
        "companies": [
            "Google",
            "Pinterest"
        ],
        "question": "You are designing a predictive search engine (like Google Search Autocomplete). You need sub-100ms latency for prefix lookups on billions of queries. Which data structure is optimal? ",
        "options": [
            "Trie (Prefix Tree) stored in memory",
            "B-Tree on disk",
            "Bloom Filter",
            "Inverted Index"
        ],
        "answer": "Trie (Prefix Tree) stored in memory",
        "explanation": "Tries are optimized for prefix lookups. Storing the top variations in memory (or using a distributed cache like Redis) ensures low latency.",
        "frequency_score": 10
    },
    {
        "id": 1271,
        "topic": "Distributed Systems",
        "companies": [
            "Google",
            "LinkedIn"
        ],
        "question": "Which replication strategy allows multiple nodes to accept writes, increasing write throughput but introducing potential update conflicts? ",
        "options": [
            "Multi-Leader (Master-Master) Replication",
            "Single-Leader Replication",
            "Leaderless Replication (Dynamo-style)",
            "Read Replicas only"
        ],
        "answer": "Multi-Leader (Master-Master) Replication",
        "explanation": "Multi-Leader replication allows writes at multiple datacenters/nodes. It improves performance and local availability but requires conflict resolution logic (e.g., Last Write Wins).",
        "frequency_score": 9
    },
    {
        "id": 1272,
        "topic": "Logic Puzzles",
        "companies": [
            "Google",
            "Microsoft"
        ],
        "question": "You have 8 balls. One is slightly heavier. You have a balance scale. What is the minimum number of weighings to find the heavy one?",
        "options": [
            "2 weighings",
            "3 weighings",
            "4 weighings",
            "1 weighing"
        ],
        "answer": "2 weighings",
        "explanation": "Weigh 3 vs 3. If equal, weigh remaining 2 (1 vs 1). If unequal, take heavy group of 3, weigh 1 vs 1. Total 2 steps (3^2 = 9 > 8).",
        "frequency_score": 4
    },
    {
        "id": 1273,
        "topic": "Apache Kafka",
        "companies": [
            "Google",
            "LinkedIn"
        ],
        "question": "What happens if a Kafka Consumer Group has more consumers than partitions in the topic? ",
        "options": [
            "Some consumers will be idle",
            "Throughput increases linearly",
            "Kafka automatically creates more partitions",
            "The extra consumers duplicate the data"
        ],
        "answer": "Some consumers will be idle",
        "explanation": "A partition can be consumed by only one consumer within a group at a time. Extra consumers stay idle.",
        "frequency_score": 6
    },
    {
        "id": 1274,
        "topic": "Cloud Spanner",
        "companies": [
            "Google",
            "Uber",
            "Pokemon GO"
        ],
        "question": "You are designing a global banking ledger. You require strong consistency and horizontal scalability. Which database service should you choose? ",
        "options": [
            "Cloud Spanner",
            "Cloud SQL",
            "Bigtable",
            "Firestore"
        ],
        "answer": "Cloud Spanner",
        "explanation": "Cloud Spanner is the only service providing global strong consistency and horizontal scalability with relational semantics (SQL).",
        "frequency_score": 8
    },
    {
        "id": 1275,
        "topic": "Distributed Systems",
        "companies": [
            "Google",
            "LinkedIn"
        ],
        "question": "Which replication strategy allows multiple nodes to accept writes, increasing write throughput but introducing potential update conflicts? ",
        "options": [
            "Multi-Leader (Master-Master) Replication",
            "Single-Leader Replication",
            "Leaderless Replication (Dynamo-style)",
            "Read Replicas only"
        ],
        "answer": "Multi-Leader (Master-Master) Replication",
        "explanation": "Multi-Leader replication allows writes at multiple datacenters/nodes. It improves performance and local availability but requires conflict resolution logic (e.g., Last Write Wins).",
        "frequency_score": 9
    },
    {
        "id": 1276,
        "topic": "Distributed Systems",
        "companies": [
            "Google",
            "LinkedIn"
        ],
        "question": "Which replication strategy allows multiple nodes to accept writes, increasing write throughput but introducing potential update conflicts? ",
        "options": [
            "Multi-Leader (Master-Master) Replication",
            "Single-Leader Replication",
            "Leaderless Replication (Dynamo-style)",
            "Read Replicas only"
        ],
        "answer": "Multi-Leader (Master-Master) Replication",
        "explanation": "Multi-Leader replication allows writes at multiple datacenters/nodes. It improves performance and local availability but requires conflict resolution logic (e.g., Last Write Wins).",
        "frequency_score": 9
    },
    {
        "id": 1277,
        "topic": "Distributed Systems",
        "companies": [
            "Google",
            "LinkedIn"
        ],
        "question": "Which replication strategy allows multiple nodes to accept writes, increasing write throughput but introducing potential update conflicts? ",
        "options": [
            "Multi-Leader (Master-Master) Replication",
            "Single-Leader Replication",
            "Leaderless Replication (Dynamo-style)",
            "Read Replicas only"
        ],
        "answer": "Multi-Leader (Master-Master) Replication",
        "explanation": "Multi-Leader replication allows writes at multiple datacenters/nodes. It improves performance and local availability but requires conflict resolution logic (e.g., Last Write Wins).",
        "frequency_score": 9
    },
    {
        "id": 1278,
        "topic": "Apache Kafka",
        "companies": [
            "Google",
            "LinkedIn",
            "Uber",
            "Netflix"
        ],
        "question": "You need to ensure strict ordering of messages in Kafka for a specific Device ID. How should you configure the producer? ",
        "options": [
            "Use the Device ID as the partition key",
            "Use a single partition for the entire topic",
            "Enable idempotent producer",
            "Increase replication factor"
        ],
        "answer": "Use the Device ID as the partition key",
        "explanation": "Kafka guarantees ordering WITHIN a partition. Using the Entity ID as the key ensures all messages for that entity go to the same partition.",
        "frequency_score": 6
    },
    {
        "id": 1279,
        "topic": "Bigtable",
        "companies": [
            "Google",
            "Spotify"
        ],
        "question": "You are designing a Bigtable schema for IoT events. Queries will primarily be retrieve most recent events globally. Which row key design is optimal? ",
        "options": [
            "UserID#Date",
            "Date#UserID",
            "ReverseTimestamp#UserID",
            "Random#UserID"
        ],
        "answer": "ReverseTimestamp#UserID",
        "explanation": "Avoid starting with timestamp to prevent hotspots. Use EntityID first for entity-lookup queries. Use ReverseTimestamp for 'latest items' queries globally.",
        "frequency_score": 7
    },
    {
        "id": 1280,
        "topic": "Logic Puzzles",
        "companies": [
            "Google",
            "Hedge Funds"
        ],
        "question": "You have 25 horses and can race 5 at a time. No stopwatch. What is the minimum number of races to find the top 3 fastest horses? ",
        "options": [
            "7 races",
            "6 races",
            "8 races",
            "5 races"
        ],
        "answer": "7 races",
        "explanation": "Race 5 groups (5 races). Race the winners (6th race). Then race the contenders from the top 3 winner's groups (7th race).",
        "frequency_score": 4
    },
    {
        "id": 1281,
        "topic": "Pub/Sub",
        "companies": [
            "Google",
            "Uber"
        ],
        "question": "Your application publishes high throughput messages to Pub/Sub. You observe throughput limits on specific keys. What is the most likely cause? ",
        "options": [
            "Subscribers are too slow (backlog)",
            "Publisher quota exceeded",
            "Message size too large",
            "Ordering keys are causing hotspots"
        ],
        "answer": "Ordering keys are causing hotspots",
        "explanation": "If using ordering keys, high throughput on a single key can limit scalability (1MB/s limit per key). Slow subscribers cause increased backlog.",
        "frequency_score": 7
    },
    {
        "id": 1282,
        "topic": "Cloud Storage",
        "companies": [
            "Google",
            "Snapchat"
        ],
        "question": "You are designing a storage solution for disaster recovery backups. The requirement is high frequency access. What storage class should you use? ",
        "options": [
            "Standard",
            "Nearline",
            "Coldline",
            "Archive"
        ],
        "answer": "Standard",
        "explanation": "Standard for hot data. Nearline < 1/month. Coldline < 1/quarter. Archive < 1/year.",
        "frequency_score": 6
    },
    {
        "id": 1283,
        "topic": "Apache Kafka",
        "companies": [
            "Google",
            "LinkedIn"
        ],
        "question": "What happens if a Kafka Consumer Group has more consumers than partitions in the topic? ",
        "options": [
            "Some consumers will be idle",
            "Throughput increases linearly",
            "Kafka automatically creates more partitions",
            "The extra consumers duplicate the data"
        ],
        "answer": "Some consumers will be idle",
        "explanation": "A partition can be consumed by only one consumer within a group at a time. Extra consumers stay idle.",
        "frequency_score": 6
    },
    {
        "id": 1284,
        "topic": "Data pipelines",
        "companies": [
            "Google",
            "Stripe",
            "PayPal"
        ],
        "question": "You are ingesting payment events from an external API that might send duplicates 1% of the time. You need 'Exactly-Once' processing in your warehouse. What is the most robust strategy? ",
        "options": [
            "Idempotent ingestion using unique Transaction IDs",
            "Trust the API to never send duplicates",
            "Run a DISTINCT query at the end",
            "Use a low isolation level"
        ],
        "answer": "Idempotent ingestion using unique Transaction IDs",
        "explanation": "Idempotency means applying the same operation multiple times has the same effect as applying it once. Using a unique key (Transaction ID) to merge/deduplicate is the standard.",
        "frequency_score": 9
    },
    {
        "id": 1285,
        "topic": "Cloud Spanner",
        "companies": [
            "Google",
            "Uber",
            "Pokemon GO"
        ],
        "question": "You are designing a global banking ledger. You require strong consistency and 99.999% availability. Which database service should you choose? ",
        "options": [
            "Cloud Spanner",
            "Cloud SQL",
            "Bigtable",
            "Firestore"
        ],
        "answer": "Cloud Spanner",
        "explanation": "Cloud Spanner is the only service providing global strong consistency and horizontal scalability with relational semantics (SQL).",
        "frequency_score": 8
    },
    {
        "id": 1286,
        "topic": "Apache Kafka",
        "companies": [
            "Google",
            "LinkedIn"
        ],
        "question": "What happens if a Kafka Consumer Group has more consumers than partitions in the topic? ",
        "options": [
            "Some consumers will be idle",
            "Throughput increases linearly",
            "Kafka automatically creates more partitions",
            "The extra consumers duplicate the data"
        ],
        "answer": "Some consumers will be idle",
        "explanation": "A partition can be consumed by only one consumer within a group at a time. Extra consumers stay idle.",
        "frequency_score": 6
    },
    {
        "id": 1287,
        "topic": "System Design",
        "companies": [
            "Google",
            "YouTube",
            "TikTok"
        ],
        "question": "You are building a video recommendation engine. The 'Candidate Generation' phase filters millions of videos down to hundreds. Which approach is valid for this phase? ",
        "options": [
            "Collaborative Filtering / Two-Tower Neural Network",
            "Heavy learning-to-rank model",
            "A/B Testing",
            "Linear Regression"
        ],
        "answer": "Collaborative Filtering / Two-Tower Neural Network",
        "explanation": "Candidate generation must be fast and lightweight (high recall). Complex ranking models (high precision) are used only on the smaller subset of candidates.",
        "frequency_score": 10
    },
    {
        "id": 1288,
        "topic": "Apache Spark",
        "companies": [
            "Google",
            "Databricks",
            "Facebook",
            "Netflix"
        ],
        "question": "You are optimizing a Spark job that is suffering from data skew. You are joining a large skewed table with a small reference table. Which technique is most effective? ",
        "options": [
            "Salting the key",
            "Increasing the number of executors",
            "Using a larger instance type",
            "Broadcasting the large table"
        ],
        "answer": "Salting the key",
        "explanation": "Salting adds a random prefix to the skewed key to distribute it. Broadcasting is best for Skewed Joins where one table is small.",
        "frequency_score": 6
    },
    {
        "id": 1289,
        "topic": "Cloud Spanner",
        "companies": [
            "Google",
            "Uber",
            "Pokemon GO"
        ],
        "question": "You are designing a global banking ledger. You require strong consistency and 99.999% availability. Which database service should you choose? ",
        "options": [
            "Cloud Spanner",
            "Cloud SQL",
            "Bigtable",
            "Firestore"
        ],
        "answer": "Cloud Spanner",
        "explanation": "Cloud Spanner is the only service providing global strong consistency and horizontal scalability with relational semantics (SQL).",
        "frequency_score": 8
    },
    {
        "id": 1290,
        "topic": "Dataflow",
        "companies": [
            "Google",
            "Spotify",
            "New York Times"
        ],
        "question": "You are building a streaming pipeline to process server logs. You need to handle periods of user activity separated by gaps. What windowing strategy is appropriate? ",
        "options": [
            "Fixed Windows",
            "Sliding Windows",
            "Session Windows",
            "Global Windows"
        ],
        "answer": "Session Windows",
        "explanation": "Session windows gap-fill based on activity. Sliding windows overlap (e.g. every 5 min show last 1 hour). Fixed windows are tumbling.",
        "frequency_score": 9
    },
    {
        "id": 1291,
        "topic": "BigQuery",
        "companies": [
            "Google",
            "Spotify",
            "Twitter"
        ],
        "question": "You need to store 50 TB of clickstream data data in BigQuery. The data is accessed rarely (every 6 months). Which storage class fits best to minimize costs? ",
        "options": [
            "Active Storage",
            "Long-term Storage",
            "Nearline Storage",
            "Coldline Storage"
        ],
        "answer": "Long-term Storage",
        "explanation": "BigQuery Long-term storage applies automatically after 90 days of no modification, reducing price by ~50%.",
        "frequency_score": 10
    },
    {
        "id": 1292,
        "topic": "IAM",
        "companies": [
            "Google"
        ],
        "question": "A developer needs to view BigQuery datasets in a production project. Following the principle of least privilege, which role should you grant? ",
        "options": [
            "Viewer",
            "Editor",
            "Owner",
            "BigQuery Data Viewer"
        ],
        "answer": "BigQuery Data Viewer",
        "explanation": "Always prefer predefined specific roles (like BigQuery Data Viewer, Storage Object Admin) over basic roles (Viewer/Editor/Owner) to ensure least privilege.",
        "frequency_score": 9
    },
    {
        "id": 1293,
        "topic": "Logic Puzzles",
        "companies": [
            "Google",
            "Hedge Funds"
        ],
        "question": "You have 25 horses and can race 5 at a time. No stopwatch. What is the minimum number of races to find the top 3 fastest horses? ",
        "options": [
            "7 races",
            "6 races",
            "8 races",
            "5 races"
        ],
        "answer": "7 races",
        "explanation": "Race 5 groups (5 races). Race the winners (6th race). Then race the contenders from the top 3 winner's groups (7th race).",
        "frequency_score": 4
    },
    {
        "id": 1294,
        "topic": "Distributed Systems",
        "companies": [
            "Google",
            "Uber"
        ],
        "question": "You need to update data across two separate microservices (e.g., Payment and Order) transactionally. Traditional 2PC (Two-Phase Commit) is too slow/blocking. What is the modern alternative? ",
        "options": [
            "Saga Pattern",
            "3PC",
            "Write-Ahead Logging",
            "Stored Procedures"
        ],
        "answer": "Saga Pattern",
        "explanation": "The Saga pattern manages distributed transactions as a sequence of local transactions, with compensating actions (undo operations) to handle failures without long locks.",
        "frequency_score": 9
    },
    {
        "id": 1295,
        "topic": "Cloud Storage",
        "companies": [
            "Google",
            "Snapchat"
        ],
        "question": "You are designing a storage solution for disaster recovery backups. The requirement is access once a month. What storage class should you use? ",
        "options": [
            "Standard",
            "Nearline",
            "Coldline",
            "Archive"
        ],
        "answer": "Nearline",
        "explanation": "Standard for hot data. Nearline < 1/month. Coldline < 1/quarter. Archive < 1/year.",
        "frequency_score": 6
    },
    {
        "id": 1296,
        "topic": "System Design",
        "companies": [
            "Google",
            "Discord"
        ],
        "question": "You need to distribute a massive dataset across 1000 nodes. Nodes frequently join and leave. Which partitioning strategy minimizes data movement when the cluster resizes? ",
        "options": [
            "Consistent Hashing",
            "Round-Robin Partitioning",
            "Range Partitioning",
            "Modulo Hashing (Key % N)"
        ],
        "answer": "Consistent Hashing",
        "explanation": "Consistent Hashing maps both data and nodes to a ring. When a node is added/removed, only 1/k keys need to be remapped (neighbors), vs nearly all keys with Modulo Hashing.",
        "frequency_score": 10
    },
    {
        "id": 1297,
        "topic": "Distributed Systems",
        "companies": [
            "Google",
            "Facebook",
            "Amazon"
        ],
        "question": "You are designing a distributed counter. You need strict consistency (Linearizability) so every read returns the latest write. What is the trade-off according to the CAP theorem? ",
        "options": [
            "Availability must be sacrificed during partitions",
            "Partition Tolerance can be ignored",
            "Latency will decrease",
            "Consistency is free"
        ],
        "answer": "Availability must be sacrificed during partitions",
        "explanation": "In a CP (Consistent + Partition Tolerant) system, if a partition occurs, the system must refuse requests (unavailable) to ensure it doesn't return stale data.",
        "frequency_score": 9
    },
    {
        "id": 1298,
        "topic": "Bigtable",
        "companies": [
            "Google",
            "Spotify"
        ],
        "question": "You are designing a Bigtable schema for IoT events. Queries will primarily be retrieve latest events for a specific entity. Which row key design is optimal? ",
        "options": [
            "DeviceID#Date",
            "Date#DeviceID",
            "ReverseTimestamp#DeviceID",
            "Random#DeviceID"
        ],
        "answer": "DeviceID#Date",
        "explanation": "Avoid starting with timestamp to prevent hotspots. Use EntityID first for entity-lookup queries. Use ReverseTimestamp for 'latest items' queries globally.",
        "frequency_score": 7
    },
    {
        "id": 1299,
        "topic": "Distributed Systems",
        "companies": [
            "Google",
            "Facebook",
            "Amazon"
        ],
        "question": "You are designing a distributed counter. You need strict consistency (Linearizability) so every read returns the latest write. What is the trade-off according to the CAP theorem? ",
        "options": [
            "Availability must be sacrificed during partitions",
            "Partition Tolerance can be ignored",
            "Latency will decrease",
            "Consistency is free"
        ],
        "answer": "Availability must be sacrificed during partitions",
        "explanation": "In a CP (Consistent + Partition Tolerant) system, if a partition occurs, the system must refuse requests (unavailable) to ensure it doesn't return stale data.",
        "frequency_score": 9
    },
    {
        "id": 1300,
        "topic": "Algorithms",
        "companies": [
            "Google",
            "Amazon",
            "Microsoft"
        ],
        "question": "What is the time complexity of a Quick Sort algorithm in the worst case? ",
        "options": [
            "O(n log n)",
            "O(n^2)",
            "O(n)",
            "O(log n)"
        ],
        "answer": "O(n^2)",
        "explanation": "Merge Sort is O(n log n). Quick Sort is O(n^2) in worst case (though avg O(n log n)). Bubble Sort is O(n^2).",
        "frequency_score": 8
    }
]